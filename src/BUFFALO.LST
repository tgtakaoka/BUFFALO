       1/       0 :                    ;*                  BUFFALO
       2/       0 :                    ;* "Bit User's Fast Friendly Aid to Logical Operation"
       3/       0 :                    ;*
       4/       0 :                    ;* Rev 2.0 - 4/23/85 - added disassembler.
       5/       0 :                    ;*                   - variables now PTRn and TMPn.
       6/       0 :                    ;* Rev 2.1 - 4/29/85 - added byte erase to chgbyt routine.
       7/       0 :                    ;* Rev 2.2 - 5/16/85 - added hooks for evb board - acia
       8/       0 :                    ;*                     drivers, init and host routines.
       9/       0 :                    ;*           7/8/85  - fixed dump wraparound problem.
      10/       0 :                    ;*           7/10/85 - added evm board commands.
      11/       0 :                    ;*                   - added fill instruction.
      12/       0 :                    ;*           7/18/85 - added jump to EEPROM.
      13/       0 :                    ;* Rev 2.3 - 8/22/85 - call targco to disconnect sci from host
      14/       0 :                    ;*                     in reset routine for evb board.
      15/       0 :                    ;*           10/3/85 - modified load for download through terminal.
      16/       0 :                    ;* Rev 2.4 - 7/1/86  - Changed DFLOP address to fix conflicts with
      17/       0 :                    ;*                     EEPROM.  (was at A000)
      18/       0 :                    ;* Rev 2.5 - 9/8/86  - Modified to provide additional protection from
      19/       0 :                    ;*                     program run-away on power down.  Also fixed bugs
      20/       0 :                    ;*                     in MM and MOVE.  Changed to 1 stop bit from 2.
      21/       0 :                    ;* Rev 2.6 - 9/25/86 - Modified boot routine for variable length download
      22/       0 :                    ;*                     for use with 'HC11E8.
      23/       0 :                    ;* Rev 3.0   1/15/87 - EEPROM programming routines consolidated into WRITE.
      24/       0 :                    ;*                     Fill, Assem, and breakpoints will now do EEPROM.
      25/       0 :                    ;*                   - Added compare a to $0D to WSKIP routine.
      26/       0 :                    ;*           2/11/87 - Set up load to detect receiver error.
      27/       0 :                    ;* Rev 3.2   7/7/87  - Add disassembly to trace.
      28/       0 :                    ;*                   - Add entries to jump table.
      29/       0 :                    ;*           9/20/87 - Rewrote trace to use XIRQ, added STOPAT Command
      30/       0 :                    ;*           11/24/87- Write block protect reg for 'E9 version
      31/       0 :                    ;*                   - Modified variable length download for use
      32/       0 :                    ;*                       with 'E9 bootloader (XBOOT command)
      33/       0 :                    ;* Rev 3.3   3/17/88 - Set I bit to block interrupts on Warm Start and
      34/       0 :                    ;*                       return from CALL command.
      35/       0 :                    ;*                   - Added EEMOD Command.
      36/       0 :                    ;*                   - Rearranged source so that HELP command overlaps
      37/       0 :                    ;*                       EEPROM in test mode.
      38/       0 :                    ;*           3/24/88 - Added '+', '-', '=', '.' to MEM and ASM commands.
      39/       0 :                    ;*                   - Added check for 16 byte boundary to MEM
      40/       0 :                    ;*                       space sub-command.
      41/       0 :                    ;*                   - LOAD command now puts dummy (~) command into
      42/       0 :                    ;*                       inbuff so that any stray cr's won`t hang.
      43/       0 :                    ;* Rev 3.4   8/15/88 - Changed WRITE subroutine so that config register
      44/       0 :                    ;*                       gets byte erased before programmed.  The original
      45/       0 :                    ;*                       value of config is used for EEBYTE so that config
      46/       0 :                    ;*                       RAM value doesn't get changed in test mode.
      47/       0 :                    ;*           8/17/88 - Fixed MOVE command so that it doesn't hang when move
      48/       0 :                    ;*                       is done to a ROM location.
      49/       0 :                    ;*                   - Added OFFSET command for download offset capability.
      50/       0 :                    ;*
      51/       0 :                    ;****************************************************
      52/       0 :                    ;*    Although the information contained herein,    *
      53/       0 :                    ;*    as well as any information provided relative  *
      54/       0 :                    ;*    thereto, has been carefully reviewed and is   *
      55/       0 :                    ;*    believed accurate, Motorola assumes no        *
      56/       0 :                    ;*    liability arising out of its application or   *
      57/       0 :                    ;*    use, neither does it convey any license under *
      58/       0 :                    ;*    its patent rights nor the rights of others.   *
      59/       0 :                    ;****************************************************
      60/       0 :
      61/       0 :                    ;***************
      62/       0 :                    ;*   EQUATES   *
      63/       0 :                    ;***************
      64/       0 :                    ;*Author EQU  Tony Fourcroy
      65/       0 : =0                 RAMBS   EQU  $0000      ;start of ram
      66/       0 : =0                 REGBS   EQU  $0000      ;start of registers MC68HC11D
      67/       0 : =E000              ROMBS   EQU  $E000      ;start of rom
      68/       0 : =B600              DSTREE  EQU  $B600      ;start of eeprom
      69/       0 : =B7FF              DENDEE  EQU  $B7FF      ;end of eeprom
      70/       0 : =A                 PORTE   EQU  REGBS+$0A  ;port e
      71/       0 : =B                 CFORC   EQU  REGBS+$0B  ;force output compare
      72/       0 : =E                 TCNT    EQU  REGBS+$0E  ;timer count
      73/       0 : =1E                TOC5    EQU  REGBS+$1E  ;oc5 reg
      74/       0 : =20                TCTL1   EQU  REGBS+$20  ;timer control 1
      75/       0 : =22                TMSK1   EQU  REGBS+$22  ;timer mask 1
      76/       0 : =23                TFLG1   EQU  REGBS+$23  ;timer flag 1
      77/       0 : =24                TMSK2   EQU  REGBS+$24  ;timer mask 2
      78/       0 : =2B                BAUD    EQU  REGBS+$2B  ;sci baud reg
      79/       0 : =2C                SCCR1   EQU  REGBS+$2C  ;sci control1 reg
      80/       0 : =2D                SCCR2   EQU  REGBS+$2D  ;sci control2 reg
      81/       0 : =2E                SCSR    EQU  REGBS+$2E  ;sci status reg
      82/       0 : =2F                SCDAT   EQU  REGBS+$2F  ;sci data reg
      83/       0 : =35                BPROT   EQU  REGBS+$35  ;block protect reg
      84/       0 : =39                OPTION  EQU  REGBS+$39  ;option reg
      85/       0 : =3A                COPRST  EQU  REGBS+$3A  ;cop reset reg
      86/       0 : =3B                PPROG   EQU  REGBS+$3B  ;ee prog reg
      87/       0 : =3C                HPRIO   EQU  REGBS+$3C  ;hprio reg
      88/       0 : =3F                CONFIG  EQU  REGBS+$3F  ;config register
      89/       0 : =4000              DFLOP   EQU  $4000      ;evb d flip flop
      90/       0 : =D000              DUART   EQU  $D000      ;duart address
      91/       0 : =D000              PORTA   EQU  DUART
      92/       0 : =D008              PORTB   EQU  DUART+8
      93/       0 : =DF00              ACIA    EQU  $DF00      ;acia address of BionicMC68HC11D
      94/       0 : =3E                PROMPT  EQU  '>'
      95/       0 : =23                BUFFLNG EQU  35
      96/       0 : =1                 CTLA    EQU  $01        ;exit host or assembler
      97/       0 : =2                 CTLB    EQU  $02        ;send break to host
      98/       0 : =17                CTLW    EQU  $17        ;wait
      99/       0 : =18                CTLX    EQU  $18        ;abort
     100/       0 : =7F                DEL     EQU  $7F        ;abort
     101/       0 : =4                 EOT     EQU  $04        ;end of text/table
     102/       0 : =3F                SWI     EQU  $3F
     103/       0 :
     104/       0 :                    ;***************
     105/       0 :                    ;*     RAM     *
     106/       0 :                    ;***************
     107/      2D :                            ORG  $2D
     108/      2D :                    ;*** Buffalo ram space ***
     109/      2D :                            RMB  20    ;user stack area
     110/      41 :                    USTACK  RMB  30    ;monitor stack area
     111/      5F :                    STACK   RMB  1
     112/      60 :                    REGS    RMB  9     ;user's pc,y,x,a,b,c
     113/      69 :                    SP      RMB  2     ;user's sp
     114/      6B :                    INBUFF  RMB  BUFFLNG    ;input buffer
     115/      8E : =8E                ENDBUFF EQU  *
     116/      8E :                    COMBUFF RMB  8     ;command buffer
     117/      96 :                    SHFTREG RMB  2     ;input shift register
     118/      98 :                    STREE   RMB  2     ;eeprom start address
     119/      9A :                    ENDEE   RMB  2     ;eeprom end address
     120/      9C :                    BRKTABL RMB  8     ;breakpoint table
     121/      A4 :                    AUTOLF  RMB  1     ;auto lf flag for i/o
     122/      A5 :                    IODEV   RMB  1     ;0=sci,  1=acia, 2=duartA, 3=duartB
     123/      A6 :                    EXTDEV  RMB  1     ;0=none, 1=acia, 2=duart,
     124/      A7 :                    HOSTDEV RMB  1     ;0=sci,  1=acia,           3=duartB
     125/      A8 :                    COUNT   RMB  1     ;# characters read
     126/      A9 :                    CHRCNT  RMB  1     ;# characters output on current line
     127/      AA :                    PTRMEM  RMB  2     ;current memory location
     128/      AC :                    LDOFFST RMB  2     ;offset for download
     129/      AE :
     130/      AE :                    ;*** Buffalo variables - used by: ***
     131/      AE :                    PTR0    RMB  2     ;main,readbuff,incbuff,AS
     132/      B0 :                    PTR1    RMB  2     ;main,BR,DU,MO,AS,EX
     133/      B2 :                    PTR2    RMB  2     ;EX,DU,MO,AS
     134/      B4 :                    PTR3    RMB  2     ;EX,HO,MO,AS
     135/      B6 :                    PTR4    RMB  2     ;EX,AS
     136/      B8 :                    PTR5    RMB  2     ;EX,AS,BOOT
     137/      BA :                    PTR6    RMB  2     ;EX,AS,BOOT
     138/      BC :                    PTR7    RMB  2     ;EX,AS
     139/      BE :                    PTR8    RMB  2     ;AS
     140/      C0 :                    TMP1    RMB  1     ;main,hexbin,buffarg,termarg
     141/      C1 :                    TMP2    RMB  1     ;GO,HO,AS,LOAD
     142/      C2 :                    TMP3    RMB  1     ;AS,LOAD
     143/      C3 :                    TMP4    RMB  1     ;TR,HO,ME,AS,LOAD
     144/      C4 :                    ;*** Vector jump table ***
     145/      C4 :                    JSCI    RMB   3
     146/      C7 :                    JSPI    RMB   3
     147/      CA :                    JPAIE   RMB   3
     148/      CD :                    JPAO    RMB   3
     149/      D0 :                    JTOF    RMB   3
     150/      D3 :                    JTOC5   RMB   3
     151/      D6 :                    JTOC4   RMB   3
     152/      D9 :                    JTOC3   RMB   3
     153/      DC :                    JTOC2   RMB   3
     154/      DF :                    JTOC1   RMB   3
     155/      E2 :                    JTIC3   RMB   3
     156/      E5 :                    JTIC2   RMB   3
     157/      E8 :                    JTIC1   RMB   3
     158/      EB :                    JRTI    RMB   3
     159/      EE :                    JIRQ    RMB   3
     160/      F1 :                    JXIRQ   RMB   3
     161/      F4 :                    JSWI    RMB   3
     162/      F7 :                    JILLOP  RMB   3
     163/      FA :                    JCOP    RMB   3
     164/      FD :                    JCLM    RMB   3
     165/     100 :
     166/     100 :                    ;*****************
     167/     100 :                    ;*
     168/     100 :                    ;* ROM starts here *
     169/     100 :                    ;*
     170/     100 :                    ;*****************
     171/     100 :
     172/    E000 :                            ORG  ROMBS
     173/    E000 :
     174/    E000 :                    ;*****************
     175/    E000 :                    ;**  BUFFALO - This is where Buffalo starts
     176/    E000 :                    ;** out of reset.  All initialization is done
     177/    E000 :                    ;** here including determination of where the
     178/    E000 :                    ;** user terminal is (SCI,ACIA, or DUART).
     179/    E000 :                    ;*****************
     180/    E000 :
     181/    E000 : CE 00 0A           BUFFALO  LDX  #PORTE
     182/    E003 : 1F 00 01 03                 BRCLR 0,X,#01,BUFISIT ;if bit 0 of port e is 1
     183/    E007 : 7E B6 00                    JMP  DSTREE      ;then jump to the start of EEPROM
     184/    E00A : 86 93              BUFISIT  LDAA #$93
     185/    E00C : 97 39                       STAA OPTION      ;adpu, dly, irqe, cop
     186/    E00E : 86 00                       LDAA #$00
     187/    E010 : 97 24                       STAA TMSK2       ;timer pre = %1 for trace
     188/    E012 : 86 00                       LDAA #$00
     189/    E014 : 97 35                       STAA BPROT       ;clear 'E9 eeprom block protect
     190/    E016 : CE B6 00                    LDX  #DSTREE     ;set up default eeprom address range
     191/    E019 : DF 98                       STX  STREE
     192/    E01B : CE B7 FF                    LDX  #DENDEE
     193/    E01E : DF 9A                       STX  ENDEE
     194/    E020 : CE 00 00                    LDX  #$0000      ;set up default download offset
     195/    E023 : DF AC                       STX  LDOFFST
     196/    E025 : 8E 00 5F                    LDS  #STACK      ;monitor stack pointer
     197/    E028 : BD E3 4D                    JSR  VECINIT
     198/    E02B : CE 00 41                    LDX  #USTACK
     199/    E02E : DF 69                       STX  SP          ;default user stack
     200/    E030 : 96 20                       LDAA TCTL1
     201/    E032 : 8A 03                       ORAA #$03
     202/    E034 : 97 20                       STAA TCTL1       ;force oc5 pin high for trace
     203/    E036 : 86 D0                       LDAA #$D0
     204/    E038 : 97 68                       STAA REGS+8      ;default user ccr
     205/    E03A : CC 3F 0D                    LDD  #$3F0D      ;initial command is ?
     206/    E03D : DD 6B                       STD  INBUFF
     207/    E03F : BD E1 B2                    JSR  BPCLR       ;clear breakpoints
     208/    E042 : 7F 00 A4                    CLR  AUTOLF
     209/    E045 : 7C 00 A4                    INC  AUTOLF      ;auto cr/lf = on
     210/    E048 :
     211/    E048 :                    ;* Determine type of external comm device - none, or acia *
     212/    E048 :
     213/    E048 : 7F 00 A6                    CLR  EXTDEV      ;default is none
     214/    E04B : 96 3C                       LDAA HPRIO
     215/    E04D : 84 20                       ANDA #$20
     216/    E04F : 27 35                       BEQ  BUFF2       ;jump if single chip mode
     217/    E051 : 86 03                       LDAA #$03        ;see if external acia exists
     218/    E053 : B7 DF 00                    STAA ACIA        ;master reset
     219/    E056 : B6 DF 00                    LDAA ACIA
     220/    E059 : 84 7F                       ANDA #$7F        ;mask irq bit from status register
     221/    E05B : 26 12                       BNE  BUFF1       ;jump if status reg not 0
     222/    E05D : 86 12                       LDAA #$12
     223/    E05F : B7 DF 00                    STAA ACIA        ;turn on acia
     224/    E062 : B6 DF 00                    LDAA ACIA
     225/    E065 : 84 02                       ANDA #$02
     226/    E067 : 27 06                       BEQ  BUFF1       ;jump if tdre not set
     227/    E069 : 86 01                       LDAA #$01
     228/    E06B : 97 A6                       STAA EXTDEV      ;external device is acia
     229/    E06D : 20 17                       BRA  BUFF2
     230/    E06F :
     231/    E06F : =E06F              BUFF1    EQU  *           ;see if duart exists
     232/    E06F : B6 D0 0C                    LDAA  DUART+$0C  ;read IRQ vector register
     233/    E072 : 81 0F                       CMPA  #$0F       ;should be out of reset
     234/    E074 : 26 10                       BNE   BUFF2
     235/    E076 : 86 AA                       LDAA #$AA
     236/    E078 : B7 D0 0C                    STAA DUART+$0C   ;write irq vector register
     237/    E07B : B6 D0 0C                    LDAA DUART+$0C   ;read irq vector register
     238/    E07E : 81 AA                       CMPA #$AA
     239/    E080 : 26 04                       BNE  BUFF2
     240/    E082 : 86 02                       LDAA #$02
     241/    E084 : 97 A6                       STAA EXTDEV      ;external device is duart A
     242/    E086 :
     243/    E086 :                    ;* Find terminal port - SCI or external. *
     244/    E086 :
     245/    E086 : 7F 00 A5           BUFF2    CLR  IODEV
     246/    E089 : BD E3 45                    JSR  TARGCO    ;disconnect sci for evb board
     247/    E08C : BD E0 B1                    JSR  SIGNON    ;initialize sci
     248/    E08F : 96 A6                       LDAA EXTDEV
     249/    E091 : 27 05                       BEQ  BUFF3     ;jump if no external device
     250/    E093 : 97 A5                       STAA IODEV
     251/    E095 : BD E0 B1                    JSR  SIGNON    ;initialize external device
     252/    E098 : 7F 00 A5           BUFF3    CLR  IODEV
     253/    E09B : BD E3 94                    JSR  INPUT     ;get input from sci port
     254/    E09E : 81 0D                       CMPA #$0D
     255/    E0A0 : 27 19                       BEQ  BUFF4     ;jump if cr - sci is terminal port
     256/    E0A2 : 96 A6                       LDAA EXTDEV
     257/    E0A4 : 27 F2                       BEQ  BUFF3     ;jump if no external device
     258/    E0A6 : 97 A5                       STAA IODEV
     259/    E0A8 : BD E3 94                    JSR  INPUT     ;get input from external device
     260/    E0AB : 81 0D                       CMPA #$0D
     261/    E0AD : 27 0C                       BEQ  BUFF4     ;jump if cr - terminal found ext
     262/    E0AF : 20 E7                       BRA  BUFF3
     263/    E0B1 :
     264/    E0B1 : BD E3 6E           SIGNON   JSR  INIT        ;initialize device
     265/    E0B4 : CE E6 2D                    LDX  #MSG1       ;buffalo message
     266/    E0B7 : BD E5 05                    JSR  OUTSTRG
     267/    E0BA : 39                          RTS
     268/    E0BB :
     269/    E0BB :                    ;* Determine where host port should be. *
     270/    E0BB :
     271/    E0BB : 7F 00 A7           BUFF4    CLR  HOSTDEV     ;default - host = sci port
     272/    E0BE : 96 A5                       LDAA IODEV
     273/    E0C0 : 81 01                       CMPA #$01
     274/    E0C2 : 27 04                       BEQ  BUFF5       ;default host if term = acia
     275/    E0C4 : 86 03                       LDAA #$03
     276/    E0C6 : 97 A7                       STAA HOSTDEV     ;else host is duart port b
     277/    E0C8 : =E0C8              BUFF5    EQU  *
     278/    E0C8 :
     279/    E0C8 :                    ;*****************
     280/    E0C8 :                    ;**  MAIN - This module reads the user's input into
     281/    E0C8 :                    ;** a buffer called INBUFF.  The first field (assumed
     282/    E0C8 :                    ;** to be the command field) is then parsed into a
     283/    E0C8 :                    ;** second buffer called COMBUFF.  The command table
     284/    E0C8 :                    ;** is then searched for the contents of COMBUFF and
     285/    E0C8 :                    ;** if found, the address of the corresponding task
     286/    E0C8 :                    ;** routine is fetched from the command table.  The
     287/    E0C8 :                    ;** task is then called as a subroutine so that
     288/    E0C8 :                    ;** control returns back to here upon completion of
     289/    E0C8 :                    ;** the task.  Buffalo expects the following format
     290/    E0C8 :                    ;** for commands:
     291/    E0C8 :                    ;**     <cmd>[<wsp><arg><wsp><arg>...]<cr>
     292/    E0C8 :                    ;** [] implies contents optional.
     293/    E0C8 :                    ;** <wsp> means whitespace character (space,comma,tab).
     294/    E0C8 :                    ;** <cmd> = command string of 1-8 characters.
     295/    E0C8 :                    ;** <arg> = Argument particular to the command.
     296/    E0C8 :                    ;** <cr> = Carriage return signifying end of input string.
     297/    E0C8 :                    ;*****************
     298/    E0C8 :                    ;* Prompt user
     299/    E0C8 :                    ;*do
     300/    E0C8 :                    ;*   a=input();
     301/    E0C8 :                    ;*   if(a==(cntlx or del)) continue;
     302/    E0C8 :                    ;*   elseif(a==backspace)
     303/    E0C8 :                    ;*      b--;
     304/    E0C8 :                    ;*      if(b<0) b=0;
     305/    E0C8 :                    ;*   else
     306/    E0C8 :                    ;*      if(a==cr && buffer empty)
     307/    E0C8 :                    ;*         repeat last command;
     308/    E0C8 :                    ;*      else put a into buffer;
     309/    E0C8 :                    ;*         check if buffer full;
     310/    E0C8 :                    ;*while(a != (cr or /)
     311/    E0C8 : 0F                 MAIN     SEI            ;block interrupts
     312/    E0C9 : 8E 00 5F                    LDS  #STACK    ;initialize sp every time
     313/    E0CC : 7F 00 A4                    CLR  AUTOLF
     314/    E0CF : 7C 00 A4                    INC  AUTOLF    ;auto cr/lf = on
     315/    E0D2 : BD E4 F5                    JSR  OUTCRLF
     316/    E0D5 : 86 3E                       LDAA #PROMPT   ;prompt user
     317/    E0D7 : BD E3 BE                    JSR  OUTPUT
     318/    E0DA : 5F                          CLRB
     319/    E0DB : BD E5 31           MAIN1    JSR  INCHAR    ;read terminal
     320/    E0DE : CE 00 6B                    LDX  #INBUFF
     321/    E0E1 : 3A                          ABX            ;pointer into buffer
     322/    E0E2 : 81 18                       CMPA #CTLX
     323/    E0E4 : 27 E2                       BEQ  MAIN      ;jump if cntl X
     324/    E0E6 : 81 7F                       CMPA #DEL
     325/    E0E8 : 27 DE                       BEQ  MAIN      ;jump if del
     326/    E0EA : 81 08                       CMPA #$08
     327/    E0EC : 26 05                       BNE  MAIN2     ;jump if not bckspc
     328/    E0EE : 5A                          DECB
     329/    E0EF : 2D D7                       BLT  MAIN      ;jump if buffer empty
     330/    E0F1 : 20 E8                       BRA  MAIN1
     331/    E0F3 : 81 0D              MAIN2    CMPA #$D
     332/    E0F5 : 26 07                       BNE  MAIN3     ;jump if not cr
     333/    E0F7 : 5D                          TSTB
     334/    E0F8 : 27 17                       BEQ  COMM0     ;jump if buffer empty
     335/    E0FA : A7 00                       STAA 0,X       ;put a in buffer
     336/    E0FC : 20 13                       BRA  COMM0
     337/    E0FE : A7 00              MAIN3    STAA 0,X       ;put a in buffer
     338/    E100 : 5C                          INCB
     339/    E101 : C1 23                       CMPB #BUFFLNG
     340/    E103 : 2F 08                       BLE  MAIN4     ;jump if not long
     341/    E105 : CE E6 77                    LDX  #MSG3     ;"long"
     342/    E108 : BD E5 05                    JSR  OUTSTRG
     343/    E10B : 20 BB                       BRA  MAIN
     344/    E10D : 81 2F              MAIN4    CMPA #'/'
     345/    E10F : 26 CA                       BNE  MAIN1     ;jump if not "/"
     346/    E111 :                    ;*        *******************
     347/    E111 :
     348/    E111 :                    ;*****************
     349/    E111 :                    ;*  Parse out and evaluate the command field.
     350/    E111 :                    ;*****************
     351/    E111 :                    ;*Initialize
     352/    E111 :
     353/    E111 : =E111              COMM0    EQU  *
     354/    E111 : 7F 00 C0                    CLR  TMP1        ;Enable "/" command
     355/    E114 : 7F 00 96                    CLR  SHFTREG
     356/    E117 : 7F 00 97                    CLR  SHFTREG+1
     357/    E11A : 5F                          CLRB
     358/    E11B : CE 00 6B                    LDX  #INBUFF     ;ptrbuff[] = inbuff[]
     359/    E11E : DF AE                       STX  PTR0
     360/    E120 : BD E2 FC                    JSR  WSKIP       ;find first char
     361/    E123 :
     362/    E123 :                    ;*while((a=readbuff) != (cr or wspace))
     363/    E123 :                    ;*     upcase(a);
     364/    E123 :                    ;*     buffptr[b] = a
     365/    E123 :                    ;*     b++
     366/    E123 :                    ;*     if (b > 8) error(too long);
     367/    E123 :                    ;*     if(a == "/")
     368/    E123 :                    ;*          if(enabled) mslash();
     369/    E123 :                    ;*          else error(command?);
     370/    E123 :                    ;*     else hexbin(a);
     371/    E123 :
     372/    E123 : =E123              COMM1    EQU  *
     373/    E123 : BD E2 E7                    JSR  READBUFF  ;read from buffer
     374/    E126 : CE 00 8E                    LDX  #COMBUFF
     375/    E129 : 3A                          ABX
     376/    E12A : BD E1 A7                    JSR  UPCASE    ;convert to upper case
     377/    E12D : A7 00                       STAA 0,X       ;put in command buffer
     378/    E12F : 81 0D                       CMPA #$0D
     379/    E131 : 27 36                       BEQ  SRCH      ;jump if cr
     380/    E133 : BD E3 0C                    JSR  WCHEK
     381/    E136 : 27 31                       BEQ  SRCH      ;jump if wspac
     382/    E138 : BD E2 EE                    JSR  INCBUFF   ;move buffer pointer
     383/    E13B : 5C                          INCB
     384/    E13C : C1 08                       CMPB #$8
     385/    E13E : 2F 09                       BLE  COMM2
     386/    E140 : CE E6 77                    LDX  #MSG3     ;"long"
     387/    E143 : BD E5 05                    JSR  OUTSTRG
     388/    E146 : 7E E0 C8                    JMP  MAIN
     389/    E149 :
     390/    E149 : =E149              COMM2    EQU  *
     391/    E149 : 81 2F                       CMPA #'/'
     392/    E14B : 26 17                       BNE  COMM4       ;jump if not "/"
     393/    E14D : 7D 00 C0                    TST  TMP1
     394/    E150 : 26 09                       BNE  COMM3       ;jump if not enabled
     395/    E152 : 5A                          DECB
     396/    E153 : D7 A8                       STAB COUNT
     397/    E155 : CE E9 04                    LDX  #MSLASH
     398/    E158 : 7E E1 A2                    JMP  EXEC        ;execute "/"
     399/    E15B : CE E6 8F           COMM3    LDX  #MSG8       ;"command?"
     400/    E15E : BD E5 05                    JSR  OUTSTRG
     401/    E161 : 7E E0 C8                    JMP  MAIN
     402/    E164 : =E164              COMM4    EQU  *
     403/    E164 : BD E2 01                    JSR  HEXBIN
     404/    E167 : 20 BA                       BRA  COMM1
     405/    E169 :
     406/    E169 :                    ;*****************
     407/    E169 :                    ;*   Search tables for command.  At this point,
     408/    E169 :                    ;* COMBUFF holds the command field to be executed,
     409/    E169 :                    ;* and B = # of characters in the command field.
     410/    E169 :                    ;* The command table holds the whole command name
     411/    E169 :                    ;* but only the first n characters of the command
     412/    E169 :                    ;* must match what is in COMBUFF where n is the
     413/    E169 :                    ;* number of characters entered by the user.
     414/    E169 :                    ;*****************
     415/    E169 :                    ;*count = b;
     416/    E169 :                    ;*ptr1 = comtabl;
     417/    E169 :                    ;*while(ptr1[0] != end of table)
     418/    E169 :                    ;*   ptr1 = next entry
     419/    E169 :                    ;*   for(b=1; b=count; b++)
     420/    E169 :                    ;*      if(ptr1[b] == combuff[b]) continue;
     421/    E169 :                    ;*      else error(not found);
     422/    E169 :                    ;*   execute task;
     423/    E169 :                    ;*  return();
     424/    E169 :                    ;*return(command not found);
     425/    E169 :
     426/    E169 : D7 A8              SRCH    STAB COUNT     ;size of command entered
     427/    E16B : CE E5 3B                   LDX  #COMTABL  ;pointer to table
     428/    E16E : DF B0                      STX  PTR1      ;pointer to next entry
     429/    E170 : DE B0              SRCH1   LDX  PTR1
     430/    E172 : 18 CE 00 8E                LDY  #COMBUFF  ;pointer to command buffer
     431/    E176 : E6 00                      LDAB 0,X
     432/    E178 : C1 FF                      CMPB #$FF
     433/    E17A : 26 09                      BNE  SRCH2
     434/    E17C : CE E6 71                   LDX  #MSG2     ;"command not found"
     435/    E17F : BD E5 05                   JSR  OUTSTRG
     436/    E182 : 7E E0 C8                   JMP  MAIN
     437/    E185 : 3C                 SRCH2   PSHX            ;compute next table entry
     438/    E186 : CB 03                      ADDB #$3
     439/    E188 : 3A                         ABX
     440/    E189 : DF B0                      STX  PTR1
     441/    E18B : 38                         PULX
     442/    E18C : 5F                         CLRB
     443/    E18D : 5C                 SRCHLP  INCB            ;match characters loop
     444/    E18E : A6 01                      LDAA 1,X        ;read table
     445/    E190 : 18 A1 00                   CMPA 0,Y        ;compare to combuff
     446/    E193 : 26 DB                      BNE  SRCH1      ;try next entry
     447/    E195 : 08                         INX             ;move pointers
     448/    E196 : 18 08                      INY
     449/    E198 : D1 A8                      CMPB COUNT
     450/    E19A : 2D F1                      BLT  SRCHLP     ;loop countu1 times
     451/    E19C : DE B0                      LDX  PTR1
     452/    E19E : 09                         DEX
     453/    E19F : 09                         DEX
     454/    E1A0 : EE 00                      LDX  0,X     ;jump address from table
     455/    E1A2 : AD 00              EXEC    JSR  0,X     ;call task as subroutine
     456/    E1A4 : 7E E0 C8                   JMP  MAIN
     457/    E1A7 :                    ;*
     458/    E1A7 :                    ;*****************
     459/    E1A7 :                    ;*   UTILITY SUBROUTINES - These routines
     460/    E1A7 :                    ;* are called by any of the task routines.
     461/    E1A7 :                    ;*****************
     462/    E1A7 :                    ;*****************
     463/    E1A7 :                    ;*  UPCASE(a) - If the contents of A is alpha,
     464/    E1A7 :                    ;* returns a converted to uppercase.
     465/    E1A7 :                    ;*****************
     466/    E1A7 : 81 61              UPCASE   CMPA #'a'
     467/    E1A9 : 2D 06                       BLT  UPCASE1      ;jump if < a
     468/    E1AB : 81 7A                       CMPA #'z'
     469/    E1AD : 2E 02                       BGT  UPCASE1      ;jump if > z
     470/    E1AF : 80 20                       SUBA #$20         ;convert
     471/    E1B1 : 39                 UPCASE1  RTS
     472/    E1B2 :
     473/    E1B2 :                    ;*****************
     474/    E1B2 :                    ;*  BPCLR() - Clear all entries in the
     475/    E1B2 :                    ;* table of breakpoints.
     476/    E1B2 :                    ;*****************
     477/    E1B2 : CE 00 9C           BPCLR    LDX  #BRKTABL
     478/    E1B5 : C6 08                       LDAB #8
     479/    E1B7 : 6F 00              BPCLR1   CLR  0,X
     480/    E1B9 : 08                          INX
     481/    E1BA : 5A                          DECB
     482/    E1BB : 2E FA                       BGT  BPCLR1      ;loop 8 times
     483/    E1BD : 39                          RTS
     484/    E1BE :
     485/    E1BE :                    ;*****************
     486/    E1BE :                    ;*  RPRNT1(x) - Prints name and contents of a single
     487/    E1BE :                    ;* user register. On entry X points to name of register
     488/    E1BE :                    ;* in reglist.  On exit, a=register name.
     489/    E1BE :                    ;*****************
     490/    E1BE : 50 59 58 41 42 43  REGLIST  FCC  'PYXABCS'       ;names
             E1C4 : 53
     491/    E1C5 : 00 02 04 06 07 08           FCB  0,2,4,6,7,8,9   ;offset
             E1CB : 09
     492/    E1CC : 01 01 01 00 00 00           FCB  1,1,1,0,0,0,1   ;size
             E1D2 : 01
     493/    E1D3 : A6 00              RPRNT1   LDAA 0,X
     494/    E1D5 : 36                          PSHA
     495/    E1D6 : 3C                          PSHX
     496/    E1D7 : BD E3 BE                    JSR  OUTPUT      ;name
     497/    E1DA : 86 2D                       LDAA #'-'
     498/    E1DC : BD E3 BE                    JSR  OUTPUT      ;dash
     499/    E1DF : E6 07                       LDAB 7,X         ;contents offset
     500/    E1E1 : A6 0E                       LDAA 14,X        ;bytesize
     501/    E1E3 : CE 00 60                    LDX  #REGS       ;address
     502/    E1E6 : 3A                          ABX
     503/    E1E7 : 4D                          TSTA
     504/    E1E8 : 27 03                       BEQ  RPRN2       ;jump if 1 byte
     505/    E1EA : BD E4 DD                    JSR  OUT1BYT     ;2 bytes
     506/    E1ED : BD E4 EC           RPRN2    JSR  OUT1BSP
     507/    E1F0 : 38                          PULX
     508/    E1F1 : 32                          PULA
     509/    E1F2 : 39                          RTS
     510/    E1F3 :
     511/    E1F3 :                    ;*****************
     512/    E1F3 :                    ;*  RPRINT() - Print the name and contents
     513/    E1F3 :                    ;* of all the user registers.
     514/    E1F3 :                    ;*****************
     515/    E1F3 : 3C                 RPRINT   PSHX
     516/    E1F4 : CE E1 BE                    LDX  #REGLIST
     517/    E1F7 : BD E1 D3           RPRI1    JSR  RPRNT1      ;print name
     518/    E1FA : 08                          INX
     519/    E1FB : 81 53                       CMPA #'S'        ;s is last register
     520/    E1FD : 26 F8                       BNE  RPRI1       ;jump if not done
     521/    E1FF : 38                          PULX
     522/    E200 : 39                          RTS
     523/    E201 :
     524/    E201 :                    ;*****************
     525/    E201 :                    ;*   HEXBIN(a) - Convert the ASCII character in a
     526/    E201 :                    ;* to binary and shift into shftreg.  Returns value
     527/    E201 :                    ;* in tmp1 incremented if a is not hex.
     528/    E201 :                    ;*****************
     529/    E201 : 36                 HEXBIN  PSHA
     530/    E202 : 37                         PSHB
     531/    E203 : 3C                         PSHX
     532/    E204 : BD E1 A7                   JSR  UPCASE     ;convert to upper case
     533/    E207 : 81 30                      CMPA #'0'
     534/    E209 : 2D 22                      BLT  HEXNOT     ;jump if a < $30
     535/    E20B : 81 39                      CMPA #'9'
     536/    E20D : 2F 0A                      BLE  HEXNMB     ;jump if 0-9
     537/    E20F : 81 41                      CMPA #'A'
     538/    E211 : 2D 1A                      BLT  HEXNOT     ;jump if $39> a <$41
     539/    E213 : 81 46                      CMPA #'F'
     540/    E215 : 2E 16                      BGT  HEXNOT     ;jump if a > $46
     541/    E217 : 8B 09                      ADDA #$9        ;convert $A-$F
     542/    E219 : 84 0F              HEXNMB  ANDA #$0F       ;convert to binary
     543/    E21B : CE 00 96                   LDX  #SHFTREG
     544/    E21E : C6 04                      LDAB #4
     545/    E220 : 68 01              HEXSHFT ASL  1,X        ;2 byte shift through
     546/    E222 : 69 00                      ROL  0,X        ;       carry bit
     547/    E224 : 5A                         DECB
     548/    E225 : 2E F9                      BGT  HEXSHFT    ;shift 4 times
     549/    E227 : AA 01                      ORAA 1,X
     550/    E229 : A7 01                      STAA 1,X
     551/    E22B : 20 03                      BRA  HEXRTS
     552/    E22D : 7C 00 C0           HEXNOT  INC  TMP1       ;indicate not hex
     553/    E230 : 38                 HEXRTS  PULX
     554/    E231 : 33                         PULB
     555/    E232 : 32                         PULA
     556/    E233 : 39                         RTS
     557/    E234 :
     558/    E234 :                    ;*****************
     559/    E234 :                    ;*  BUFFARG() - Build a hex argument from the
     560/    E234 :                    ;* contents of the input buffer. Characters are
     561/    E234 :                    ;* converted to binary and shifted into shftreg
     562/    E234 :                    ;* until a non-hex character is found.  On exit
     563/    E234 :                    ;* shftreg holds the last four digits read, count
     564/    E234 :                    ;* holds the number of digits read, ptrbuff points
     565/    E234 :                    ;* to the first non-hex character read, and A holds
     566/    E234 :                    ;* that first non-hex character.
     567/    E234 :                    ;*****************
     568/    E234 :                    ;*Initialize
     569/    E234 :                    ;*while((a=readbuff()) not hex)
     570/    E234 :                    ;*     hexbin(a);
     571/    E234 :                    ;*return();
     572/    E234 :
     573/    E234 : 7F 00 C0           BUFFARG  CLR  TMP1        ;not hex indicator
     574/    E237 : 7F 00 A8                    CLR  COUNT       ;# or digits
     575/    E23A : 7F 00 96                    CLR  SHFTREG
     576/    E23D : 7F 00 97                    CLR  SHFTREG+1
     577/    E240 : BD E2 FC                    JSR  WSKIP
     578/    E243 : BD E2 E7           BUFFLP   JSR  READBUFF    ;read char
     579/    E246 : BD E2 01                    JSR  HEXBIN
     580/    E249 : 7D 00 C0                    TST  TMP1
     581/    E24C : 26 08                       BNE  BUFFRTS     ;jump if not hex
     582/    E24E : 7C 00 A8                    INC  COUNT
     583/    E251 : BD E2 EE                    JSR  INCBUFF     ;move buffer pointer
     584/    E254 : 20 ED                       BRA  BUFFLP
     585/    E256 : 39                 BUFFRTS  RTS
     586/    E257 :
     587/    E257 :                    ;*****************
     588/    E257 :                    ;*  TERMARG() - Build a hex argument from the
     589/    E257 :                    ;* terminal.  Characters are converted to binary
     590/    E257 :                    ;* and shifted into shftreg until a non-hex character
     591/    E257 :                    ;* is found.  On exit shftreg holds the last four
     592/    E257 :                    ;* digits read, count holds the number of digits
     593/    E257 :                    ;* read, and A holds the first non-hex character.
     594/    E257 :                    ;*****************
     595/    E257 :                    ;*initialize
     596/    E257 :                    ;*while((a=inchar()) == hex)
     597/    E257 :                    ;*     if(a = cntlx or del)
     598/    E257 :                    ;*          abort;
     599/    E257 :                    ;*     else
     600/    E257 :                    ;*          hexbin(a); countu1++;
     601/    E257 :                    ;*return();
     602/    E257 :
     603/    E257 : 7F 00 A8           TERMARG  CLR  COUNT
     604/    E25A : 7F 00 96                    CLR  SHFTREG
     605/    E25D : 7F 00 97                    CLR  SHFTREG+1
     606/    E260 : BD E5 31           TERM0    JSR  INCHAR
     607/    E263 : 81 18                       CMPA #CTLX
     608/    E265 : 27 04                       BEQ  TERM1     ;jump if controlx
     609/    E267 : 81 7F                       CMPA #DEL
     610/    E269 : 26 03                       BNE  TERM2     ;jump if not delete
     611/    E26B : 7E E0 C8           TERM1    JMP  MAIN      ;abort
     612/    E26E : 7F 00 C0           TERM2    CLR  TMP1      ;hex indicator
     613/    E271 : BD E2 01                    JSR  HEXBIN
     614/    E274 : 7D 00 C0                    TST  TMP1
     615/    E277 : 26 05                       BNE  TERM3     ;jump if not hex
     616/    E279 : 7C 00 A8                    INC  COUNT
     617/    E27C : 20 E2                       BRA  TERM0
     618/    E27E : 39                 TERM3    RTS
     619/    E27F :
     620/    E27F :                    ;*****************
     621/    E27F :                    ;*   CHGBYT() - If shftreg is not empty, put
     622/    E27F :                    ;* contents of shftreg at address in X.  If X
     623/    E27F :                    ;* is an address in EEPROM then program it.
     624/    E27F :                    ;*****************
     625/    E27F :                    ;*if(count != 0)
     626/    E27F :                    ;*   (x) = a;
     627/    E27F : 7D 00 A8           CHGBYT   TST  COUNT
     628/    E282 : 27 05                       BEQ  CHGBYT4   ;quit if shftreg empty
     629/    E284 : 96 97                       LDAA SHFTREG+1 ;get data into a
     630/    E286 : BD E2 8A                    JSR  WRITE
     631/    E289 : 39                 CHGBYT4  RTS
     632/    E28A :
     633/    E28A :
     634/    E28A :                    ;*****************
     635/    E28A :                    ;* WRITE() - This routine is used to write the
     636/    E28A :                    ;*contents of A to the address of X.  If the
     637/    E28A :                    ;*address is in EEPROM, it will be programmed
     638/    E28A :                    ;*and if it is already programmed, it will be
     639/    E28A :                    ;*byte erased first.
     640/    E28A :                    ;******************
     641/    E28A :                    ;*if(X == config) then
     642/    E28A :                    ;*   byte erase config;
     643/    E28A :                    ;*if(X is eeprom)then
     644/    E28A :                    ;*   if(not erased) then erase;
     645/    E28A :                    ;*   program (x) = A;
     646/    E28A :                    ;*write (x) = A;
     647/    E28A :                    ;*if((x) != A) error(rom);
     648/    E28A : =E28A              WRITE   EQU  *
     649/    E28A : 8C 00 3F                   CPX  #CONFIG
     650/    E28D : 27 10                      BEQ  WRITE0     ;jump if config
     651/    E28F : 9C 98                      CPX  STREE      ;start of EE
     652/    E291 : 25 12                      BLO  WRITE2     ;jump if not EE
     653/    E293 : 9C 9A                      CPX  ENDEE      ;end of EE
     654/    E295 : 22 0E                      BHI  WRITE2     ;jump if not EE
     655/    E297 : 37                 WRITEE  PSHB            ;check if byte erased
     656/    E298 : E6 00                      LDAB 0,X
     657/    E29A : C1 FF                      CMPB #$FF
     658/    E29C : 33                         PULB
     659/    E29D : 27 03                      BEQ  WRITE1     ;jump if erased
     660/    E29F : BD E2 BF           WRITE0  JSR  EEBYTE     ;byte erase
     661/    E2A2 : BD E2 B4           WRITE1  JSR  EEWRIT     ;byte program
     662/    E2A5 : A7 00              WRITE2  STAA 0,X        ;write for non EE
     663/    E2A7 : A1 00                      CMPA 0,X
     664/    E2A9 : 27 08                      BEQ  WRITE3     ;jump if write ok
     665/    E2AB : 3C                         PSHX
     666/    E2AC : CE E6 8A                   LDX  #MSG6      ;"rom"
     667/    E2AF : BD E5 05                   JSR  OUTSTRG
     668/    E2B2 : 38                         PULX
     669/    E2B3 : 39                 WRITE3  RTS
     670/    E2B4 :
     671/    E2B4 :
     672/    E2B4 :                    ;*****************
     673/    E2B4 :                    ;*   EEWRIT(), EEBYTE(), EEBULK() -
     674/    E2B4 :                    ;* These routines are used to program and eeprom
     675/    E2B4 :                    ;*locations.  eewrite programs the address in X with
     676/    E2B4 :                    ;*the value in A, eebyte does a byte address at X,
     677/    E2B4 :                    ;*and eebulk does a bulk of eeprom.  Whether eebulk
     678/    E2B4 :                    ;*erases the config or not depends on the address it
     679/    E2B4 :                    ;*receives in X.
     680/    E2B4 :                    ;****************
     681/    E2B4 : =E2B4              EEWRIT  EQU  *          ;program one byte at x
     682/    E2B4 : 37                         PSHB
     683/    E2B5 : C6 02                      LDAB #$02
     684/    E2B7 : D7 3B                      STAB PPROG
     685/    E2B9 : A7 00                      STAA 0,X
     686/    E2BB : C6 03                      LDAB #$03
     687/    E2BD : 20 16                      BRA  EEPROG
     688/    E2BF :                    ;***
     689/    E2BF : =E2BF              EEBYTE  EQU  *          ;byte erase address x
     690/    E2BF : 37                         PSHB
     691/    E2C0 : C6 16                      LDAB #$16
     692/    E2C2 : D7 3B                      STAB PPROG
     693/    E2C4 : C6 FF                      LDAB #$FF
     694/    E2C6 : E7 00                      STAB 0,X
     695/    E2C8 : C6 17                      LDAB #$17
     696/    E2CA : 20 09                      BRA  EEPROG
     697/    E2CC :                    ;***
     698/    E2CC : =E2CC              EEBULK  EQU  *          ;bulk erase eeprom
     699/    E2CC : 37                         PSHB
     700/    E2CD : C6 06                      LDAB #$06
     701/    E2CF : D7 3B                      STAB PPROG
     702/    E2D1 : A7 00                      STAA 0,X        ;erase config or not ...
     703/    E2D3 : C6 07                      LDAB #$07       ;  ... depends on X addr
     704/    E2D5 : 26 01              EEPROG  BNE  ACL1
     705/    E2D7 : 5F                         CLRB            ;fail safe
     706/    E2D8 : D7 3B              ACL1    STAB PPROG
     707/    E2DA : 33                         PULB
     708/    E2DB :                    ;***
     709/    E2DB : =E2DB              DLY10MS EQU  *          ;delay 10ms at E = 2MHz
     710/    E2DB : 3C                         PSHX
     711/    E2DC : CE 0D 06                   LDX  #$0D06
     712/    E2DF : 09                 DLYLP   DEX
     713/    E2E0 : 26 FD                      BNE  DLYLP
     714/    E2E2 : 38                         PULX
     715/    E2E3 : 7F 00 3B                   CLR  PPROG
     716/    E2E6 : 39                         RTS
     717/    E2E7 :
     718/    E2E7 :
     719/    E2E7 :                    ;*****************
     720/    E2E7 :                    ;*  READBUFF() -  Read the character in INBUFF
     721/    E2E7 :                    ;* pointed at by ptrbuff into A.  Returns ptrbuff
     722/    E2E7 :                    ;* unchanged.
     723/    E2E7 :                    ;*****************
     724/    E2E7 : 3C                 READBUFF PSHX
     725/    E2E8 : DE AE                       LDX  PTR0
     726/    E2EA : A6 00                       LDAA 0,X
     727/    E2EC : 38                          PULX
     728/    E2ED : 39                          RTS
     729/    E2EE :
     730/    E2EE :                    ;*****************
     731/    E2EE :                    ;*  INCBUFF(), DECBUFF() - Increment or decrement
     732/    E2EE :                    ;* ptrbuff.
     733/    E2EE :                    ;*****************
     734/    E2EE : 3C                 INCBUFF  PSHX
     735/    E2EF : DE AE                       LDX  PTR0
     736/    E2F1 : 08                          INX
     737/    E2F2 : 20 04                       BRA  INCDEC
     738/    E2F4 : 3C                 DECBUFF  PSHX
     739/    E2F5 : DE AE                       LDX  PTR0
     740/    E2F7 : 09                          DEX
     741/    E2F8 : DF AE              INCDEC   STX  PTR0
     742/    E2FA : 38                          PULX
     743/    E2FB : 39                          RTS
     744/    E2FC :
     745/    E2FC :                    ;*****************
     746/    E2FC :                    ;*  WSKIP() - Read from the INBUFF until a
     747/    E2FC :                    ;* non whitespace (space, comma, tab) character
     748/    E2FC :                    ;* is found.  Returns ptrbuff pointing to the
     749/    E2FC :                    ;* first non-whitespace character and a holds
     750/    E2FC :                    ;* that character.  WSKIP also compares a to
     751/    E2FC :                    ;* $0D (CR) and cond codes indicating the
     752/    E2FC :                    ;* results of that compare.
     753/    E2FC :                    ;*****************
     754/    E2FC : BD E2 E7           WSKIP    JSR  READBUFF  ;read character
     755/    E2FF : BD E3 0C                    JSR  WCHEK
     756/    E302 : 26 05                       BNE  WSKIP1    ;jump if not wspc
     757/    E304 : BD E2 EE                    JSR  INCBUFF   ;move pointer
     758/    E307 : 20 F3                       BRA  WSKIP     ;loop
     759/    E309 : 81 0D              WSKIP1   CMPA #$0D
     760/    E30B : 39                          RTS
     761/    E30C :
     762/    E30C :                    ;*****************
     763/    E30C :                    ;*  WCHEK(a) - Returns z=1 if a holds a
     764/    E30C :                    ;* whitespace character, else z=0.
     765/    E30C :                    ;*****************
     766/    E30C : 81 2C              WCHEK    CMPA #$2C      ;comma
     767/    E30E : 27 06                       BEQ  WCHEK1
     768/    E310 : 81 20                       CMPA #$20      ;space
     769/    E312 : 27 02                       BEQ  WCHEK1
     770/    E314 : 81 09                       CMPA #$09      ;tab
     771/    E316 : 39                 WCHEK1   RTS
     772/    E317 :
     773/    E317 :                    ;*****************
     774/    E317 :                    ;*   DCHEK(a) - Returns Z=1 if a = whitespace
     775/    E317 :                    ;* or carriage return.  Else returns z=0.
     776/    E317 :                    ;*****************
     777/    E317 : BD E3 0C           DCHEK   JSR  WCHEK
     778/    E31A : 27 02                      BEQ  DCHEK1     ;jump if whitespace
     779/    E31C : 81 0D                      CMPA #$0D
     780/    E31E : 39                 DCHEK1  RTS
     781/    E31F :
     782/    E31F :                    ;*****************
     783/    E31F :                    ;*  CHKABRT() - Checks for a control x or delete
     784/    E31F :                    ;* from the terminal.  If found, the stack is
     785/    E31F :                    ;* reset and the control is transferred to main.
     786/    E31F :                    ;* Note that this is an abnormal termination.
     787/    E31F :                    ;*   If the input from the terminal is a control W
     788/    E31F :                    ;* then this routine keeps waiting until any other
     789/    E31F :                    ;* character is read.
     790/    E31F :                    ;*****************
     791/    E31F :                    ;*a=input();
     792/    E31F :                    ;*if(a=cntl w) wait until any other key;
     793/    E31F :                    ;*if(a = cntl x or del) abort;
     794/    E31F :
     795/    E31F : BD E3 94           CHKABRT  JSR  INPUT
     796/    E322 : 27 18                       BEQ  CHK4      ;jump if no input
     797/    E324 : 81 17                       CMPA #CTLW
     798/    E326 : 26 05                       BNE  CHK2      ;jump in not cntlw
     799/    E328 : BD E3 94           CHKABRT1 JSR  INPUT
     800/    E32B : 27 FB                       BEQ  CHKABRT1  ;jump if no input
     801/    E32D : 81 7F              CHK2     CMPA #DEL
     802/    E32F : 27 08                       BEQ  CHK3      ;jump if delete
     803/    E331 : 81 18                       CMPA #CTLX
     804/    E333 : 27 04                       BEQ  CHK3      ;jump if control x
     805/    E335 : 81 01                       CMPA #CTLA
     806/    E337 : 26 03                       BNE  CHK4      ;jump not control a
     807/    E339 : 7E E0 C8           CHK3     JMP  MAIN      ;abort
     808/    E33C : 39                 CHK4     RTS            ;return
     809/    E33D :
     810/    E33D :                    ;***********************
     811/    E33D :                    ;*  HOSTCO - connect sci to host for evb board.
     812/    E33D :                    ;*  TARGCO - connect sci to target for evb board.
     813/    E33D :                    ;***********************
     814/    E33D : 36                 HOSTCO   PSHA
     815/    E33E : 86 01                       LDAA #$01
     816/    E340 : B7 40 00                    STAA DFLOP     ;send 1 to d-flop
     817/    E343 : 32                          PULA
     818/    E344 : 39                          RTS
     819/    E345 :
     820/    E345 : 36                 TARGCO   PSHA
     821/    E346 : 86 00                       LDAA #$00
     822/    E348 : B7 40 00                    STAA DFLOP     ;send 0 to d-flop
     823/    E34B : 32                          PULA
     824/    E34C : 39                          RTS
     825/    E34D :
     826/    E34D :                    ;*
     827/    E34D :                    ;**********
     828/    E34D :                    ;*
     829/    E34D :                    ;*     VECINIT - This routine checks for
     830/    E34D :                    ;*        vectors in the RAM table.  All
     831/    E34D :                    ;*        uninitialized vectors are programmed
     832/    E34D :                    ;*        to JMP STOPIT
     833/    E34D :                    ;*
     834/    E34D :                    ;**********
     835/    E34D :                    ;*
     836/    E34D : CE 00 C4           VECINIT  LDX  #JSCI     ;Point to First RAM Vector
     837/    E350 : 18 CE E3 67                 LDY  #STOPIT   ;Pointer to STOPIT routine
     838/    E354 : CC 7E 03                    LDD  #$7E03    ;A=JMP opcode; B=offset
     839/    E357 : A1 00              VECLOOP  CMPA 0,X
     840/    E359 : 27 05                       BEQ  VECNEXT   ;If vector already in
     841/    E35B : A7 00                       STAA 0,X       ;install JMP
     842/    E35D : 1A EF 01                    STY  1,X       ;to STOPIT routine
     843/    E360 : 3A                 VECNEXT  ABX            ;Add 3 to point at next vector
     844/    E361 : 8C 01 00                    CPX  #JCLM+3   ;Done?
     845/    E364 : 26 F1                       BNE  VECLOOP   ;If not, continue loop
     846/    E366 : 39                          RTS
     847/    E367 :                    ;*
     848/    E367 : 86 50              STOPIT   LDAA #$50      ;Stop-enable; IRQ, XIRQ-Off
     849/    E369 : 06                          TAP
     850/    E36A : CF                          STOP           ;You are lost!  Shut down
     851/    E36B : 7E E3 67                    JMP  STOPIT    ;In case continue by XIRQ
     852/    E36E :
     853/    E36E :                    ;**********
     854/    E36E :                    ;*
     855/    E36E :                    ;*   I/O MODULE
     856/    E36E :                    ;*     Communications with the outside world.
     857/    E36E :                    ;* 3 I/O routines (INIT, INPUT, and OUTPUT) call
     858/    E36E :                    ;* drivers specified by IODEV (0=SCI, 1=ACIA,
     859/    E36E :                    ;* 2=DUARTA, 3=DUARTB).
     860/    E36E :                    ;*
     861/    E36E :                    ;**********
     862/    E36E :                    ;*   INIT() - Initialize device specified by iodev.
     863/    E36E :                    ;*********
     864/    E36E :                    ;*
     865/    E36E : =E36E              INIT     EQU  *
     866/    E36E : 36                          PSHA        ;save registers
     867/    E36F : 3C                          PSHX
     868/    E370 : 96 A5                       LDAA IODEV
     869/    E372 : 81 00                       CMPA #$00
     870/    E374 : 26 05                       BNE  INIT1    ;jump not sci
     871/    E376 : BD E4 3D                    JSR  ONSCI     ;initialize sci
     872/    E379 : 20 16                       BRA  INIT4
     873/    E37B : 81 01              INIT1    CMPA #$01
     874/    E37D : 26 05                       BNE  INIT2     ;jump not acia
     875/    E37F : BD E4 75                    JSR  ONACIA    ;initialize acia
     876/    E382 : 20 0D                       BRA  INIT4
     877/    E384 : CE D0 00           INIT2    LDX  #PORTA
     878/    E387 : 81 02                       CMPA #$02
     879/    E389 : 27 03                       BEQ  INIT3     ;jump duart a
     880/    E38B : CE D0 08                    LDX  #PORTB
     881/    E38E : BD E3 E7           INIT3    JSR  ONUART    ;initialize duart
     882/    E391 : 38                 INIT4    PULX         ;restore registers
     883/    E392 : 32                          PULA
     884/    E393 : 39                          RTS
     885/    E394 :
     886/    E394 :                    ;**********
     887/    E394 :                    ;*  INPUT() - Read device. Returns a=char or 0.
     888/    E394 :                    ;*    This routine also disarms the cop.
     889/    E394 :                    ;**********
     890/    E394 : =E394              INPUT    EQU  *
     891/    E394 : 3C                          PSHX
     892/    E395 : 86 55                       LDAA #$55    ;reset cop
     893/    E397 : 97 3A                       STAA COPRST
     894/    E399 : 86 AA                       LDAA #$AA
     895/    E39B : 97 3A                       STAA COPRST
     896/    E39D : 96 A5                       LDAA IODEV
     897/    E39F : 26 05                       BNE  INPUT1    ;jump not sci
     898/    E3A1 : BD E4 4A                    JSR  INSCI     ;read sci
     899/    E3A4 : 20 16                       BRA  INPUT4
     900/    E3A6 : 81 01              INPUT1   CMPA #$01
     901/    E3A8 : 26 05                       BNE  INPUT2    ;jump not acia
     902/    E3AA : BD E4 81                    JSR  INACIA    ;read acia
     903/    E3AD : 20 0D                       BRA  INPUT4
     904/    E3AF : CE D0 00           INPUT2   LDX  #PORTA
     905/    E3B2 : 81 02                       CMPA #$02
     906/    E3B4 : 27 03                       BEQ  INPUT3    ;jump if duart a
     907/    E3B6 : CE D0 08                    LDX  #PORTB
     908/    E3B9 : BD E4 12           INPUT3   JSR  INUART    ;read uart
     909/    E3BC : 38                 INPUT4   PULX
     910/    E3BD : 39                          RTS
     911/    E3BE :
     912/    E3BE :                    ;**********
     913/    E3BE :                    ;*   OUTPUT() - Output character in A.
     914/    E3BE :                    ;* chrcnt indicates the current column on the
     915/    E3BE :                    ;*output display.  It is incremented every time
     916/    E3BE :                    ;*a character is outputted, and cleared whenever
     917/    E3BE :                    ;*the subroutine outcrlf is called.
     918/    E3BE :                    ;**********
     919/    E3BE :
     920/    E3BE : =E3BE              OUTPUT   EQU  *
     921/    E3BE : 36                          PSHA         ;save registers
     922/    E3BF : 37                          PSHB
     923/    E3C0 : 3C                          PSHX
     924/    E3C1 : D6 A5                       LDAB IODEV
     925/    E3C3 : 26 05                       BNE  OUTPUT1   ;jump not sci
     926/    E3C5 : BD E4 55                    JSR  OUTSCI    ;write sci
     927/    E3C8 : 20 16                       BRA  OUTPUT4
     928/    E3CA : C1 01              OUTPUT1  CMPB #$01
     929/    E3CC : 26 05                       BNE  OUTPUT2   ;jump not acia
     930/    E3CE : BD E4 9B                    JSR  OUTACIA   ;write acia
     931/    E3D1 : 20 0D                       BRA  OUTPUT4
     932/    E3D3 : CE D0 00           OUTPUT2  LDX  #PORTA
     933/    E3D6 : C1 02                       CMPB #$02
     934/    E3D8 : 27 03                       BEQ  OUTPUT3   ;jump if duart a
     935/    E3DA : CE D0 08                    LDX  #PORTB
     936/    E3DD : BD E4 1D           OUTPUT3  JSR  OUTUART   ;write uart
     937/    E3E0 : 38                 OUTPUT4  PULX
     938/    E3E1 : 33                          PULB
     939/    E3E2 : 32                          PULA
     940/    E3E3 : 7C 00 A9                    INC  CHRCNT    ;increment column count
     941/    E3E6 : 39                          RTS
     942/    E3E7 :
     943/    E3E7 :                    ;**********
     944/    E3E7 :                    ;*   ONUART(port) - Initialize a duart port.
     945/    E3E7 :                    ;* Sets duart to internal clock, divide by 16,
     946/    E3E7 :                    ;* 8 data + 1 stop bits.
     947/    E3E7 :                    ;**********
     948/    E3E7 :
     949/    E3E7 : 86 22              ONUART   LDAA #$22
     950/    E3E9 : A7 02                       STAA 2,X         ;reset receiver
     951/    E3EB : 86 38                       LDAA #$38
     952/    E3ED : A7 02                       STAA 2,X         ;reset transmitter
     953/    E3EF : 86 40                       LDAA #$40
     954/    E3F1 : A7 02                       STAA 2,X         ;reset error status
     955/    E3F3 : 86 10                       LDAA #$10
     956/    E3F5 : A7 02                       STAA 2,X         ;reset pointer
     957/    E3F7 : 86 00                       LDAA #$00
     958/    E3F9 : B7 D0 04                    STAA DUART+4     ;clock source
     959/    E3FC : 86 00                       LDAA #$00
     960/    E3FE : B7 D0 05                    STAA DUART+5     ;interrupt mask
     961/    E401 : 86 13                       LDAA #$13
     962/    E403 : A7 00                       STAA 0,X         ;8 data, no parity
     963/    E405 : 86 07                       LDAA #$07
     964/    E407 : A7 00                       STAA 0,X         ;1 stop bits
     965/    E409 : 86 BB                       LDAA #$BB        ;baud rate (9600)
     966/    E40B : A7 01                       STAA 1,X         ;tx and rcv baud rate
     967/    E40D : 86 05                       LDAA #$05
     968/    E40F : A7 02                       STAA 2,X         ;enable tx and rcv
     969/    E411 : 39                          RTS
     970/    E412 :
     971/    E412 :                    ;**********
     972/    E412 :                    ;*   INUART(port) - Check duart for any input.
     973/    E412 :                    ;**********
     974/    E412 : A6 01              INUART   LDAA 1,X         ;read status
     975/    E414 : 84 01                       ANDA #$01        ;check rxrdy
     976/    E416 : 27 04                       BEQ  INUART1     ;jump if no data
     977/    E418 : A6 03                       LDAA 3,X         ;read data
     978/    E41A : 84 7F                       ANDA #$7F        ;mask parity
     979/    E41C : 39                 INUART1  RTS
     980/    E41D :
     981/    E41D :                    ;**********
     982/    E41D :                    ;*   OUTUART(port) - Output the character in a.
     983/    E41D :                    ;*        if autolf=1, transmits cr or lf as crlf.
     984/    E41D :                    ;**********
     985/    E41D : 7D 00 A4           OUTUART  TST  AUTOLF
     986/    E420 : 27 10                       BEQ  OUTUART2    ;jump if no autolf
     987/    E422 : 8D 0E                       BSR  OUTUART2
     988/    E424 : 81 0D                       CMPA #$0D
     989/    E426 : 26 04                       BNE  OUTUART1
     990/    E428 : 86 0A                       LDAA #$0A        ;if cr, output lf
     991/    E42A : 20 06                       BRA  OUTUART2
     992/    E42C : 81 0A              OUTUART1 CMPA #$0A
     993/    E42E : 26 0C                       BNE  OUTUART3
     994/    E430 : 86 0D                       LDAA #$0D        ;if lf, output cr
     995/    E432 : E6 01              OUTUART2 LDAB 1,X         ;check status
     996/    E434 : C4 04                       ANDB #$4
     997/    E436 : 27 FA                       BEQ  OUTUART2    ;loop until tdre=1
     998/    E438 : 84 7F                       ANDA #$7F        ;mask parity
     999/    E43A : A7 03                       STAA 3,X         ;send character
    1000/    E43C : 39                 OUTUART3 RTS
    1001/    E43D :
    1002/    E43D :                    ;**********
    1003/    E43D :                    ;*   ONSCI() - Initialize the SCI for 9600
    1004/    E43D :                    ;*                 baud at 8 MHz Extal.
    1005/    E43D :                    ;**********
    1006/    E43D : 86 00              ONSCI    LDAA #$00        ; use E/16 clock on BionicMC68HC11D
    1007/    E43F : 97 2B                       STAA BAUD        ;baud register
    1008/    E441 : 86 00                       LDAA #$00
    1009/    E443 : 97 2C                       STAA SCCR1
    1010/    E445 : 86 0C                       LDAA #$0C
    1011/    E447 : 97 2D                       STAA SCCR2       ;enable
    1012/    E449 : 39                          RTS
    1013/    E44A :
    1014/    E44A :                    ;**********
    1015/    E44A :                    ;*   INSCI() - Read from SCI.  Return a=char or 0.
    1016/    E44A :                    ;**********
    1017/    E44A : 96 2E              INSCI    LDAA SCSR      ;read status reg
    1018/    E44C : 84 20                       ANDA #$20      ;check rdrf
    1019/    E44E : 27 04                       BEQ  INSCI1    ;jump if no data
    1020/    E450 : 96 2F                       LDAA SCDAT     ;read data
    1021/    E452 : 84 7F                       ANDA #$7F      ;mask parity
    1022/    E454 : 39                 INSCI1   RTS
    1023/    E455 :
    1024/    E455 :                    ;**********
    1025/    E455 :                    ;*  OUTSCI() - Output A to sci. IF autolf = 1,
    1026/    E455 :                    ;*               cr and lf sent as crlf.
    1027/    E455 :                    ;**********
    1028/    E455 : 7D 00 A4           OUTSCI   TST  AUTOLF
    1029/    E458 : 27 10                       BEQ  OUTSCI2     ;jump if autolf=0
    1030/    E45A : 8D 0E                       BSR  OUTSCI2
    1031/    E45C : 81 0D                       CMPA #$0D
    1032/    E45E : 26 04                       BNE  OUTSCI1
    1033/    E460 : 86 0A                       LDAA #$0A        ;if cr, send lf
    1034/    E462 : 20 06                       BRA  OUTSCI2
    1035/    E464 : 81 0A              OUTSCI1  CMPA #$0A
    1036/    E466 : 26 0C                       BNE  OUTSCI3
    1037/    E468 : 86 0D                       LDAA #$0D        ;if lf, send cr
    1038/    E46A : D6 2E              OUTSCI2  LDAB SCSR        ;read status
    1039/    E46C : C5 80                       BITB #$80
    1040/    E46E : 27 FA                       BEQ  OUTSCI2     ;loop until tdre=1
    1041/    E470 : 84 7F                       ANDA #$7F        ;mask parity
    1042/    E472 : 97 2F                       STAA SCDAT       ;send character
    1043/    E474 : 39                 OUTSCI3  RTS
    1044/    E475 :
    1045/    E475 :                    ;**********
    1046/    E475 :                    ;*   ONACIA - Initialize the ACIA for
    1047/    E475 :                    ;* 8 data bits, 1 stop bit, divide by 64 clock.
    1048/    E475 :                    ;**********
    1049/    E475 : CE DF 00           ONACIA   LDX  #ACIA
    1050/    E478 : 86 03                       LDAA #$03
    1051/    E47A : A7 00                       STAA 0,X       ;master reset
    1052/    E47C : 86 16                       LDAA #$16
    1053/    E47E : A7 00                       STAA 0,X       ;setup
    1054/    E480 : 39                          RTS
    1055/    E481 :
    1056/    E481 :                    ;**********
    1057/    E481 :                    ;*   INACIA - Read from the ACIA, Return a=char or 0.
    1058/    E481 :                    ;* Tmp3 is used to flag overrun or framing error.
    1059/    E481 :                    ;**********
    1060/    E481 : CE DF 00           INACIA   LDX  #ACIA
    1061/    E484 : A6 00                       LDAA 0,X       ;read status register
    1062/    E486 : 36                          PSHA
    1063/    E487 : 84 30                       ANDA #$30      ;check ov, fe
    1064/    E489 : 32                          PULA
    1065/    E48A : 27 06                       BEQ  INACIA1   ;jump - no error
    1066/    E48C : 86 01                       LDAA #$01
    1067/    E48E : 97 C2                       STAA TMP3      ;flag reciever error
    1068/    E490 : 20 04                       BRA  INACIA2   ;read data to clear status
    1069/    E492 : 84 01              INACIA1  ANDA #$01      ;check rdrf
    1070/    E494 : 27 04                       BEQ  INACIA3   ;jump if no data
    1071/    E496 : A6 01              INACIA2  LDAA 1,X       ;read data
    1072/    E498 : 84 7F                       ANDA #$7F      ;mask parity
    1073/    E49A : 39                 INACIA3  RTS
    1074/    E49B :
    1075/    E49B :                    ;**********
    1076/    E49B :                    ;*  OUTACIA - Output A to acia. IF autolf = 1,
    1077/    E49B :                    ;*               cr or lf sent as crlf.
    1078/    E49B :                    ;**********
    1079/    E49B : 8D 18              OUTACIA  BSR  OUTACIA3  ;output char
    1080/    E49D : 7D 00 A4                    TST  AUTOLF
    1081/    E4A0 : 27 12                       BEQ  OUTACIA2  ;jump no autolf
    1082/    E4A2 : 81 0D                       CMPA #$0D
    1083/    E4A4 : 26 06                       BNE  OUTACIA1
    1084/    E4A6 : 86 0A                       LDAA #$0A
    1085/    E4A8 : 8D 0B                       BSR  OUTACIA3  ;if cr, output lf
    1086/    E4AA : 20 08                       BRA  OUTACIA2
    1087/    E4AC : 81 0A              OUTACIA1 CMPA #$0A
    1088/    E4AE : 26 04                       BNE  OUTACIA2
    1089/    E4B0 : 86 0D                       LDAA #$0D
    1090/    E4B2 : 8D 01                       BSR  OUTACIA3  ;if lf, output cr
    1091/    E4B4 : 39                 OUTACIA2 RTS
    1092/    E4B5 :
    1093/    E4B5 : CE DF 00           OUTACIA3 LDX  #ACIA
    1094/    E4B8 : E6 00                       LDAB 0,X
    1095/    E4BA : C5 02                       BITB #$2
    1096/    E4BC : 27 F7                       BEQ  OUTACIA3  ;loop until tdre
    1097/    E4BE : 84 7F                       ANDA #$7F      ;mask parity
    1098/    E4C0 : A7 01                       STAA 1,X       ;output
    1099/    E4C2 : 39                          RTS
    1100/    E4C3 :                    ;*
    1101/    E4C3 :                    ;*        Space for modifying OUTACIA routine
    1102/    E4C3 :                    ;*
    1103/    E4C3 : FF FF FF FF FF FF           FDB  $FFFF,$FFFF,$FFFF,$FFFF
             E4C9 : FF FF
    1104/    E4CB :                    ;*******************************
    1105/    E4CB :                    ;*** I/O UTILITY SUBROUTINES ***
    1106/    E4CB :                    ;***These subroutines perform the neccesary
    1107/    E4CB :                    ;* data I/O operations.
    1108/    E4CB :                    ;* OUTLHLF-Convert left 4 bits of A from binary
    1109/    E4CB :                    ;*            to ASCII and output.
    1110/    E4CB :                    ;* OUTRHLF-Convert right 4 bits of A from binary
    1111/    E4CB :                    ;*            to ASCII and output.
    1112/    E4CB :                    ;* OUT1BYT-Convert byte addresed by X from binary
    1113/    E4CB :                    ;*           to ASCII and output.
    1114/    E4CB :                    ;* OUT1BSP-Convert byte addressed by X from binary
    1115/    E4CB :                    ;*           to ASCII and output followed by a space.
    1116/    E4CB :                    ;* OUT2BSP-Convert 2 bytes addressed by X from binary
    1117/    E4CB :                    ;*            to ASCII and  output followed by a space.
    1118/    E4CB :                    ;* OUTSPAC-Output a space.
    1119/    E4CB :                    ;*
    1120/    E4CB :                    ;* OUTCRLF-Output a line feed and carriage return.
    1121/    E4CB :                    ;*
    1122/    E4CB :                    ;* OUTSTRG-Output the string of ASCII bytes addressed
    1123/    E4CB :                    ;*            by X until $04.
    1124/    E4CB :                    ;* OUTA-Output the ASCII character in A.
    1125/    E4CB :                    ;*
    1126/    E4CB :                    ;* TABTO-Output spaces until column 20 is reached.
    1127/    E4CB :                    ;*
    1128/    E4CB :                    ;* INCHAR-Input to A and echo one character.  Loops
    1129/    E4CB :                    ;*            until character read.
    1130/    E4CB :                    ;*        *******************
    1131/    E4CB :
    1132/    E4CB :                    ;**********
    1133/    E4CB :                    ;*  OUTRHLF(), OUTLHLF(), OUTA()
    1134/    E4CB :                    ;*Convert A from binary to ASCII and output.
    1135/    E4CB :                    ;*Contents of A are destroyed..
    1136/    E4CB :                    ;**********
    1137/    E4CB : 44                 OUTLHLF  LSRA           ; shift data to right
    1138/    E4CC : 44                          LSRA
    1139/    E4CD : 44                          LSRA
    1140/    E4CE : 44                          LSRA
    1141/    E4CF : 84 0F              OUTRHLF  ANDA #$0F       ;mask top half
    1142/    E4D1 : 8B 30                       ADDA #$30       ;convert to ascii
    1143/    E4D3 : 81 39                       CMPA #$39
    1144/    E4D5 : 2F 02                       BLE  OUTA       ;jump if 0-9
    1145/    E4D7 : 8B 07                       ADDA #$07       ;convert to hex A-F
    1146/    E4D9 : BD E3 BE           OUTA     JSR  OUTPUT     ;output character
    1147/    E4DC : 39                          RTS
    1148/    E4DD :
    1149/    E4DD :                    ;**********
    1150/    E4DD :                    ;*  OUT1BYT(x) - Convert the byte at X to two
    1151/    E4DD :                    ;* ASCII characters and output. Return X pointing
    1152/    E4DD :                    ;* to next byte.
    1153/    E4DD :                    ;**********
    1154/    E4DD : 36                 OUT1BYT  PSHA
    1155/    E4DE : A6 00                       LDAA 0,X        ;get data in a
    1156/    E4E0 : 36                          PSHA            ;save copy
    1157/    E4E1 : 8D E8                       BSR  OUTLHLF    ;output left half
    1158/    E4E3 : 32                          PULA            ;retrieve copy
    1159/    E4E4 : 8D E9                       BSR  OUTRHLF    ;output right half
    1160/    E4E6 : 32                          PULA
    1161/    E4E7 : 08                          INX
    1162/    E4E8 : 39                          RTS
    1163/    E4E9 :
    1164/    E4E9 :                    ;**********
    1165/    E4E9 :                    ;*  OUT1BSP(x), OUT2BSP(x) - Output 1 or 2 bytes
    1166/    E4E9 :                    ;* at x followed by a space.  Returns x pointing to
    1167/    E4E9 :                    ;* next byte.
    1168/    E4E9 :                    ;**********
    1169/    E4E9 : BD E4 DD           OUT2BSP  JSR  OUT1BYT      ;do first byte
    1170/    E4EC : BD E4 DD           OUT1BSP  JSR  OUT1BYT      ;do next byte
    1171/    E4EF : 86 20              OUTSPAC  LDAA #$20         ;output a space
    1172/    E4F1 : BD E3 BE                    JSR  OUTPUT
    1173/    E4F4 : 39                          RTS
    1174/    E4F5 :
    1175/    E4F5 :                    ;**********
    1176/    E4F5 :                    ;*  OUTCRLF() - Output a Carriage return and
    1177/    E4F5 :                    ;* a line feed.  Returns a = cr.
    1178/    E4F5 :                    ;**********
    1179/    E4F5 : 86 0D              OUTCRLF  LDAA #$0D      ;cr
    1180/    E4F7 : BD E3 BE                    JSR  OUTPUT    ;output a
    1181/    E4FA : 86 00                       LDAA #$00
    1182/    E4FC : BD E3 BE                    JSR  OUTPUT    ;output padding
    1183/    E4FF : 86 0D                       LDAA #$0D
    1184/    E501 : 7F 00 A9                    CLR  CHRCNT    ;zero the column counter
    1185/    E504 : 39                          RTS
    1186/    E505 :
    1187/    E505 :                    ;**********
    1188/    E505 :                    ;*  OUTSTRG(x) - Output string of ASCII bytes
    1189/    E505 :                    ;* starting at x until end of text ($04).  Can
    1190/    E505 :                    ;* be paused by control w (any char restarts).
    1191/    E505 :                    ;**********
    1192/    E505 : BD E4 F5           OUTSTRG  JSR  OUTCRLF
    1193/    E508 : 36                 OUTSTRG0 PSHA
    1194/    E509 : A6 00              OUTSTRG1 LDAA 0,X          ;read char into a
    1195/    E50B : 81 04                       CMPA #EOT
    1196/    E50D : 27 14                       BEQ  OUTSTRG3     ;jump if eot
    1197/    E50F : BD E3 BE                    JSR  OUTPUT       ;output character
    1198/    E512 : 08                          INX
    1199/    E513 : BD E3 94                    JSR  INPUT
    1200/    E516 : 27 F1                       BEQ  OUTSTRG1     ;jump if no input
    1201/    E518 : 81 17                       CMPA #CTLW
    1202/    E51A : 26 ED                       BNE  OUTSTRG1     ;jump if not cntlw
    1203/    E51C : BD E3 94           OUTSTRG2 JSR  INPUT
    1204/    E51F : 27 FB                       BEQ  OUTSTRG2     ;jump if any input
    1205/    E521 : 20 E6                       BRA  OUTSTRG1
    1206/    E523 : 32                 OUTSTRG3 PULA
    1207/    E524 : 39                          RTS
    1208/    E525 :
    1209/    E525 :
    1210/    E525 :                    ;*********
    1211/    E525 :                    ;*  TABTO() - move cursor over to column 20.
    1212/    E525 :                    ;*while(chrcnt < 16) outspac.
    1213/    E525 : =E525              TABTO   EQU  *
    1214/    E525 : 36                         PSHA
    1215/    E526 : BD E4 EF           TABTOLP JSR  OUTSPAC
    1216/    E529 : 96 A9                      LDAA CHRCNT
    1217/    E52B : 81 14                      CMPA #20
    1218/    E52D : 2F F7                      BLE  TABTOLP
    1219/    E52F : 32                         PULA
    1220/    E530 : 39                         RTS
    1221/    E531 :
    1222/    E531 :                    ;**********
    1223/    E531 :                    ;*  INCHAR() - Reads input until character sent.
    1224/    E531 :                    ;*    Echoes char and returns with a = char.
    1225/    E531 : BD E3 94           INCHAR   JSR  INPUT
    1226/    E534 : 4D                          TSTA
    1227/    E535 : 27 FA                       BEQ  INCHAR      ;jump if no input
    1228/    E537 : BD E3 BE                    JSR  OUTPUT      ;echo
    1229/    E53A : 39                          RTS
    1230/    E53B :
    1231/    E53B :                    ;*********************
    1232/    E53B :                    ;*** COMMAND TABLE ***
    1233/    E53B : =E53B              COMTABL  EQU  *
    1234/    E53B : 05                          FCB  5
    1235/    E53C : 41 53 53 45 4D              FCC  'ASSEM'
    1236/    E541 : EB 11                       FDB  ASSEM
    1237/    E543 : 05                          FCB  5
    1238/    E544 : 42 52 45 41 4B              FCC  'BREAK'
    1239/    E549 : E6 DB                       FDB  BREAK
    1240/    E54B : 04                          FCB  4
    1241/    E54C : 42 55 4C 4B                 FCC  'BULK'
    1242/    E550 : E7 96                       FDB  BULK
    1243/    E552 : 07                          FCB  7
    1244/    E553 : 42 55 4C 4B 41 4C           FCC  'BULKALL'
             E559 : 4C
    1245/    E55A : E7 9A                       FDB  BULKALL
    1246/    E55C : 04                          FCB  4
    1247/    E55D : 43 41 4C 4C                 FCC  'CALL'
    1248/    E561 : F9 EA                       FDB  CALL
    1249/    E563 : 04                          FCB  4
    1250/    E564 : 44 55 4D 50                 FCC  'DUMP'
    1251/    E568 : E7 A3                       FDB  DUMP
    1252/    E56A : 05                          FCB  5
    1253/    E56B : 45 45 4D 4F 44              FCC  'EEMOD'
    1254/    E570 : E8 38                       FDB  EEMOD
    1255/    E572 : 04                          FCB  4
    1256/    E573 : 46 49 4C 4C                 FCC  'FILL'
    1257/    E577 : E8 88                       FDB  FILL
    1258/    E579 : 02                          FCB  2
    1259/    E57A : 47 4F                       FCC  'GO'
    1260/    E57C : FA 43                       FDB  GO
    1261/    E57E : 04                          FCB  4
    1262/    E57F : 48 45 4C 50                 FCC  'HELP'
    1263/    E583 : F5 F1                       FDB  HELP
    1264/    E585 : 04                          FCB  4
    1265/    E586 : 48 4F 53 54                 FCC  'HOST'
    1266/    E58A : FB B7                       FDB  HOST
    1267/    E58C : 04                          FCB  4
    1268/    E58D : 4C 4F 41 44                 FCC  'LOAD'
    1269/    E591 : FC 55                       FDB  LOAD
    1270/    E593 : 06                          FCB  6          ;LENGTH OF COMMAND
    1271/    E594 : 4D 45 4D 4F 52 59           FCC  'MEMORY'   ;ASCII COMMAND
    1272/    E59A : E8 F0                       FDB  MEMORY    ;COMMAND ADDRESS
    1273/    E59C : 04                          FCB  4
    1274/    E59D : 4D 4F 56 45                 FCC  'MOVE'
    1275/    E5A1 : E9 C4                       FDB  MOVE
    1276/    E5A3 : 06                          FCB  6
    1277/    E5A4 : 4F 46 46 53 45 54           FCC  'OFFSET'
    1278/    E5AA : FD 69                       FDB  OFFSET
    1279/    E5AC : 07                          FCB  7
    1280/    E5AD : 50 52 4F 43 45 45           FCC  'PROCEED'
             E5B3 : 44
    1281/    E5B4 : FA 31                       FDB  PROCEED
    1282/    E5B6 : 08                          FCB  8
    1283/    E5B7 : 52 45 47 49 53 54           FCC  'REGISTER'
             E5BD : 45 52
    1284/    E5BF : FD AA                       FDB  REGISTER
    1285/    E5C1 : 06                          FCB  6
    1286/    E5C2 : 53 54 4F 50 41 54           FCC  'STOPAT'
    1287/    E5C8 : FB 19                       FDB  STOPAT
    1288/    E5CA : 05                          FCB  5
    1289/    E5CB : 54 52 41 43 45              FCC  'TRACE'
    1290/    E5D0 : FA D4                       FDB  TRACE
    1291/    E5D2 : 06                          FCB  6
    1292/    E5D3 : 56 45 52 49 46 59           FCC  'VERIFY'
    1293/    E5D9 : FC 4D                       FDB  VERIFY
    1294/    E5DB : 01                          FCB  1
    1295/    E5DC : 3F                          FCC  '?'       ;initial command
    1296/    E5DD : F5 F1                       FDB  HELP
    1297/    E5DF : 05                          FCB  5
    1298/    E5E0 : 58 42 4F 4F 54              FCC  'XBOOT'
    1299/    E5E5 : FE 1A                       FDB  BOOT
    1300/    E5E7 : 01                          FCB  1         ;dummy command for load
    1301/    E5E8 : 7E                          FCC  '~'
    1302/    E5E9 : FE 92                       FDB  TILDE
    1303/    E5EB :                    ;*
    1304/    E5EB :                    ;*** Command names for evm compatability ***
    1305/    E5EB :                    ;*
    1306/    E5EB : 03                          FCB  3
    1307/    E5EC : 41 53 4D                    FCC  'ASM'
    1308/    E5EF : EB 11                       FDB  ASSEM
    1309/    E5F1 : 02                          FCB  2
    1310/    E5F2 : 42 46                       FCC  'BF'
    1311/    E5F4 : E8 88                       FDB  FILL
    1312/    E5F6 : 04                          FCB  4
    1313/    E5F7 : 43 4F 50 59                 FCC  'COPY'
    1314/    E5FB : E9 C4                       FDB  MOVE
    1315/    E5FD : 05                          FCB  5
    1316/    E5FE : 45 52 41 53 45              FCC  'ERASE'
    1317/    E603 : E7 96                       FDB  BULK
    1318/    E605 : 02                          FCB  2
    1319/    E606 : 4D 44                       FCC  'MD'
    1320/    E608 : E7 A3                       FDB  DUMP
    1321/    E60A : 02                          FCB  2
    1322/    E60B : 4D 4D                       FCC  'MM'
    1323/    E60D : E8 F0                       FDB  MEMORY
    1324/    E60F : 02                          FCB  2
    1325/    E610 : 52 44                       FCC  'RD'
    1326/    E612 : FD AA                       FDB  REGISTER
    1327/    E614 : 02                          FCB  2
    1328/    E615 : 52 4D                       FCC  'RM'
    1329/    E617 : FD AA                       FDB  REGISTER
    1330/    E619 : 04                          FCB  4
    1331/    E61A : 52 45 41 44                 FCC  'READ'
    1332/    E61E : E9 C4                       FDB  MOVE
    1333/    E620 : 02                          FCB  2
    1334/    E621 : 54 4D                       FCC  'TM'
    1335/    E623 : FB B7                       FDB  HOST
    1336/    E625 : 04                          FCB  4
    1337/    E626 : 54 45 53 54                 FCC  'TEST'
    1338/    E62A : FE 93                       FDB  EVBTEST
    1339/    E62C : FF                          FCB  $FF
    1340/    E62D :
    1341/    E62D :                    ;*******************
    1342/    E62D :                    ;*** TEXT TABLES ***
    1343/    E62D :
    1344/    E62D : 42 55 46 46 41 4C  MSG1    FCC   'BUFFALO 3.4 (ext) - Bit User Fast Friendly Aid to Logical Operation'
             E633 : 4F 20 33 2E 34 20
             E639 : 28 65 78 74 29 20
             E63F : 2D 20 42 69 74 20
             E645 : 55 73 65 72 20 46
             E64B : 61 73 74 20 46 72
             E651 : 69 65 6E 64 6C 79
             E657 : 20 41 69 64 20 74
             E65D : 6F 20 4C 6F 67 69
             E663 : 63 61 6C 20 4F 70
             E669 : 65 72 61 74 69 6F
             E66F : 6E
    1345/    E670 : 04                         FCB   EOT
    1346/    E671 : 57 68 61 74 3F     MSG2    FCC   'What?'
    1347/    E676 : 04                         FCB   EOT
    1348/    E677 : 54 6F 6F 20 4C 6F  MSG3    FCC   'Too Long'
             E67D : 6E 67
    1349/    E67F : 04                         FCB   EOT
    1350/    E680 : 46 75 6C 6C        MSG4    FCC   'Full'
    1351/    E684 : 04                         FCB   EOT
    1352/    E685 : 4F 70 2D 20        MSG5    FCC   'Op- '
    1353/    E689 : 04                         FCB   EOT
    1354/    E68A : 72 6F 6D 2D        MSG6    FCC   'rom-'
    1355/    E68E : 04                         FCB   EOT
    1356/    E68F : 43 6F 6D 6D 61 6E  MSG8    FCC   'Command?'
             E695 : 64 3F
    1357/    E697 : 04                         FCB   EOT
    1358/    E698 : 42 61 64 20 61 72  MSG9    FCC   'Bad argument'
             E69E : 67 75 6D 65 6E 74
    1359/    E6A4 : 04                         FCB   EOT
    1360/    E6A5 : 4E 6F 20 68 6F 73  MSG10   FCC   'No host port'
             E6AB : 74 20 70 6F 72 74
    1361/    E6B1 : 04                         FCB   EOT
    1362/    E6B2 : 64 6F 6E 65        MSG11   FCC   'done'
    1363/    E6B6 : 04                         FCB   EOT
    1364/    E6B7 : 63 68 6B 73 75 6D  MSG12   FCC   'chksum error'
             E6BD : 20 65 72 72 6F 72
    1365/    E6C3 : 04                         FCB   EOT
    1366/    E6C4 : 65 72 72 6F 72 20  MSG13   FCC   'error addr '
             E6CA : 61 64 64 72 20
    1367/    E6CF : 04                         FCB   EOT
    1368/    E6D0 : 72 63 76 72 20 65  MSG14   FCC   'rcvr error'
             E6D6 : 72 72 6F 72
    1369/    E6DA : 04                         FCB   EOT
    1370/    E6DB :
    1371/    E6DB :                    ;**********
    1372/    E6DB :                    ;*   break [-][<addr>] . . .
    1373/    E6DB :                    ;* Modifies the breakpoint table.  More than
    1374/    E6DB :                    ;* one argument can be entered on the command
    1375/    E6DB :                    ;* line but the table will hold only 4 entries.
    1376/    E6DB :                    ;* 4 types of arguments are implied above:
    1377/    E6DB :                    ;* break           Prints table contents.
    1378/    E6DB :                    ;* break <addr>    Inserts <addr>.
    1379/    E6DB :                    ;* break -<addr>   Deletes <addr>.
    1380/    E6DB :                    ;* break -         Clears all entries.
    1381/    E6DB :                    ;**********
    1382/    E6DB :                    ;* while 1
    1383/    E6DB :                    ;*     a = wskip();
    1384/    E6DB :                    ;*     switch(a)
    1385/    E6DB :                    ;*          case(cr):
    1386/    E6DB :                    ;*               bprint(); return;
    1387/    E6DB :
    1388/    E6DB : BD E2 FC           BREAK   JSR  WSKIP
    1389/    E6DE : 26 04                      BNE  BRKDEL     ;jump if not cr
    1390/    E6E0 : BD E7 72                   JSR  BPRINT     ;print table
    1391/    E6E3 : 39                         RTS
    1392/    E6E4 :
    1393/    E6E4 :                    ;*          case("-"):
    1394/    E6E4 :                    ;*               incbuff(); readbuff();
    1395/    E6E4 :                    ;*               if(dchek(a))          /* look for wspac or cr */
    1396/    E6E4 :                    ;*                    bpclr();
    1397/    E6E4 :                    ;*                    breaksw;
    1398/    E6E4 :                    ;*               a = buffarg();
    1399/    E6E4 :                    ;*               if( !dchek(a) ) return(bad argument);
    1400/    E6E4 :                    ;*               b = bpsrch();
    1401/    E6E4 :                    ;*               if(b >= 0)
    1402/    E6E4 :                    ;*                    brktabl[b] = 0;
    1403/    E6E4 :                    ;*               breaksw;
    1404/    E6E4 :
    1405/    E6E4 : 81 2D              BRKDEL  CMPA #'-'
    1406/    E6E6 : 26 31                      BNE  BRKDEF     ;jump if not -
    1407/    E6E8 : BD E2 EE                   JSR  INCBUFF
    1408/    E6EB : BD E2 E7                   JSR  READBUFF
    1409/    E6EE : BD E3 17                   JSR  DCHEK
    1410/    E6F1 : 26 06                      BNE  BRKDEL1    ;jump if not delimeter
    1411/    E6F3 : BD E1 B2                   JSR  BPCLR      ;clear table
    1412/    E6F6 : 7E E6 DB                   JMP  BREAK      ;do next argument
    1413/    E6F9 : BD E2 34           BRKDEL1 JSR  BUFFARG    ;get address to delete
    1414/    E6FC : BD E3 17                   JSR  DCHEK
    1415/    E6FF : 27 07                      BEQ  BRKDEL2    ;jump if delimeter
    1416/    E701 : CE E6 98                   LDX  #MSG9      ;"bad argument"
    1417/    E704 : BD E5 05                   JSR  OUTSTRG
    1418/    E707 : 39                         RTS
    1419/    E708 : BD E7 81           BRKDEL2 JSR  BPSRCH     ;look for addr in table
    1420/    E70B : 5D                         TSTB
    1421/    E70C : 2B 08                      BMI  BRKDEL3    ;jump if not found
    1422/    E70E : CE 00 9C                   LDX  #BRKTABL
    1423/    E711 : 3A                         ABX
    1424/    E712 : 6F 00                      CLR  0,X        ;clear entry
    1425/    E714 : 6F 01                      CLR  1,X
    1426/    E716 : 7E E6 DB           BRKDEL3 JMP  BREAK      ;do next argument
    1427/    E719 :
    1428/    E719 :                    ;*          default:
    1429/    E719 :                    ;*               a = buffarg();
    1430/    E719 :                    ;*               if( !dchek(a) ) return(bad argument);
    1431/    E719 :                    ;*               b = bpsrch();
    1432/    E719 :                    ;*               if(b < 0)            /* not already in table */
    1433/    E719 :                    ;*                    x = shftreg;
    1434/    E719 :                    ;*                    shftreg = 0;
    1435/    E719 :                    ;*                    a = x[0]; x[0] = $3F
    1436/    E719 :                    ;*                    b = x[0]; x[0] = a;
    1437/    E719 :                    ;*                    if(b != $3F) return(rom);
    1438/    E719 :                    ;*                    b = bpsrch();   /* look for hole */
    1439/    E719 :                    ;*                    if(b >= 0) return(table full);
    1440/    E719 :                    ;*                    brktabl[b] = x;
    1441/    E719 :                    ;*               breaksw;
    1442/    E719 :
    1443/    E719 : BD E2 34           BRKDEF  JSR  BUFFARG    ;get argument
    1444/    E71C : BD E3 17                   JSR  DCHEK
    1445/    E71F : 27 07                      BEQ  BRKDEF1    ;jump if delimiter
    1446/    E721 : CE E6 98                   LDX  #MSG9      ;"bad argument"
    1447/    E724 : BD E5 05                   JSR  OUTSTRG
    1448/    E727 : 39                         RTS
    1449/    E728 : BD E7 81           BRKDEF1 JSR  BPSRCH     ;look for entry in table
    1450/    E72B : 5D                         TSTB
    1451/    E72C : 2C AD                      BGE  BREAK      ;jump if already in table
    1452/    E72E :
    1453/    E72E : DE 96                      LDX  SHFTREG     ;x = new entry addr
    1454/    E730 : A6 00                      LDAA 0,X         ;save original contents
    1455/    E732 : 36                         PSHA
    1456/    E733 : 86 3F                      LDAA #SWI
    1457/    E735 : BD E2 8A                   JSR  WRITE       ;write to entry addr
    1458/    E738 : E6 00                      LDAB 0,X         ;read back
    1459/    E73A : 32                         PULA
    1460/    E73B : BD E2 8A                   JSR  WRITE       ;restore original
    1461/    E73E : C1 3F                      CMPB #SWI
    1462/    E740 : 27 0C                      BEQ  BRKDEF2    ;jump if writes ok
    1463/    E742 : DF B0                      STX  PTR1       ;save address
    1464/    E744 : CE 00 B0                   LDX  #PTR1
    1465/    E747 : BD E4 E9                   JSR  OUT2BSP     ;print address
    1466/    E74A : BD E7 72                   JSR  BPRINT
    1467/    E74D : 39                         RTS
    1468/    E74E : 7F 00 96           BRKDEF2 CLR  SHFTREG
    1469/    E751 : 7F 00 97                   CLR  SHFTREG+1
    1470/    E754 : 3C                         PSHX
    1471/    E755 : BD E7 81                   JSR  BPSRCH     ;look for 0 entry
    1472/    E758 : 38                         PULX
    1473/    E759 : 5D                         TSTB
    1474/    E75A : 2A 0A                      BPL  BRKDEF3    ;jump if table not full
    1475/    E75C : CE E6 80                   LDX  #MSG4      ;"full"
    1476/    E75F : BD E5 05                   JSR  OUTSTRG
    1477/    E762 : BD E7 72                   JSR  BPRINT
    1478/    E765 : 39                         RTS
    1479/    E766 : 18 CE 00 9C        BRKDEF3 LDY  #BRKTABL
    1480/    E76A : 18 3A                      ABY
    1481/    E76C : CD EF 00                   STX  0,Y        ;put new entry in
    1482/    E76F : 7E E6 DB                   JMP  BREAK      ;do next argument
    1483/    E772 :
    1484/    E772 :                    ;**********
    1485/    E772 :                    ;*   bprint() - print the contents of the table.
    1486/    E772 :                    ;**********
    1487/    E772 : BD E4 F5           BPRINT   JSR  OUTCRLF
    1488/    E775 : CE 00 9C                    LDX  #BRKTABL
    1489/    E778 : C6 04                       LDAB #4
    1490/    E77A : BD E4 E9           BPRINT1  JSR  OUT2BSP
    1491/    E77D : 5A                          DECB
    1492/    E77E : 2E FA                       BGT  BPRINT1     ;loop 4 times
    1493/    E780 : 39                          RTS
    1494/    E781 :
    1495/    E781 :                    ;**********
    1496/    E781 :                    ;*   bpsrch() - search table for address in
    1497/    E781 :                    ;* shftreg. Returns b = index to entry or
    1498/    E781 :                    ;* b = -1 if not found.
    1499/    E781 :                    ;**********
    1500/    E781 :                    ;*for(b=0; b=6; b=+2)
    1501/    E781 :                    ;*     x[] = brktabl + b;
    1502/    E781 :                    ;*     if(x[0] = shftreg)
    1503/    E781 :                    ;*          return(b);
    1504/    E781 :                    ;*return(-1);
    1505/    E781 :
    1506/    E781 : 5F                 BPSRCH   CLRB
    1507/    E782 : CE 00 9C           BPSRCH1  LDX  #BRKTABL
    1508/    E785 : 3A                          ABX
    1509/    E786 : EE 00                       LDX  0,X       ;get table entry
    1510/    E788 : 9C 96                       CPX  SHFTREG
    1511/    E78A : 26 01                       BNE  BPSRCH2   ;jump if no match
    1512/    E78C : 39                          RTS
    1513/    E78D : 5C                 BPSRCH2  INCB
    1514/    E78E : 5C                          INCB
    1515/    E78F : C1 06                       CMPB #$6
    1516/    E791 : 2F EF                       BLE  BPSRCH1  ;loop 4 times
    1517/    E793 : C6 FF                       LDAB #$FF
    1518/    E795 : 39                          RTS
    1519/    E796 :
    1520/    E796 :
    1521/    E796 :                    ;**********
    1522/    E796 :                    ;*  bulk  - Bulk erase the eeprom not config.
    1523/    E796 :                    ;* bulkall - Bulk erase eeprom and config.
    1524/    E796 :                    ;*********
    1525/    E796 : =E796              BULK    EQU  *
    1526/    E796 : DE 98                      LDX  STREE
    1527/    E798 : 20 03                      BRA  BULK1
    1528/    E79A : CE 00 3F           BULKALL LDX  #CONFIG
    1529/    E79D : 86 FF              BULK1   LDAA #$FF
    1530/    E79F : BD E2 CC                   JSR  EEBULK
    1531/    E7A2 : 39                         RTS
    1532/    E7A3 :
    1533/    E7A3 :
    1534/    E7A3 :
    1535/    E7A3 :                    ;**********
    1536/    E7A3 :                    ;*  dump [<addr1> [<addr2>]]  - Dump memory
    1537/    E7A3 :                    ;* in 16 byte lines from <addr1> to <addr2>.
    1538/    E7A3 :                    ;*   Default starting address is "current
    1539/    E7A3 :                    ;* location" and default number of lines is 8.
    1540/    E7A3 :                    ;**********
    1541/    E7A3 :                    ;*ptr1 = ptrmem;        /* default start address */
    1542/    E7A3 :                    ;*ptr2 = ptr1 + $80;    /* default end address */
    1543/    E7A3 :                    ;*a = wskip();
    1544/    E7A3 :                    ;*if(a != cr)
    1545/    E7A3 :                    ;*     a = buffarg();
    1546/    E7A3 :                    ;*     if(countu1 = 0) return(bad argument);
    1547/    E7A3 :                    ;*     if( !dchek(a) ) return(bad argument);
    1548/    E7A3 :                    ;*     ptr1 = shftreg;
    1549/    E7A3 :                    ;*     ptr2 = ptr1 + $80;  /* default end address */
    1550/    E7A3 :                    ;*     a = wskip();
    1551/    E7A3 :                    ;*     if(a != cr)
    1552/    E7A3 :                    ;*          a = buffarg();
    1553/    E7A3 :                    ;*          if(countu1 = 0) return(bad argument);
    1554/    E7A3 :                    ;*          a = wskip();
    1555/    E7A3 :                    ;*          if(a != cr) return(bad argument);
    1556/    E7A3 :                    ;*          ptr2 = shftreg;
    1557/    E7A3 :
    1558/    E7A3 : DE AA              DUMP     LDX  PTRMEM    ;current location
    1559/    E7A5 : DF B0                       STX  PTR1      ;default start
    1560/    E7A7 : C6 80                       LDAB #$80
    1561/    E7A9 : 3A                          ABX
    1562/    E7AA : DF B2                       STX  PTR2      ;default end
    1563/    E7AC : BD E2 FC                    JSR  WSKIP
    1564/    E7AF : 27 35                       BEQ  DUMP1     ;jump - no arguments
    1565/    E7B1 : BD E2 34                    JSR  BUFFARG   ;read argument
    1566/    E7B4 : 7D 00 A8                    TST  COUNT
    1567/    E7B7 : 27 26                       BEQ  DUMPERR   ;jump if no argument
    1568/    E7B9 : BD E3 17                    JSR  DCHEK
    1569/    E7BC : 26 21                       BNE  DUMPERR   ;jump if delimiter
    1570/    E7BE : DE 96                       LDX  SHFTREG
    1571/    E7C0 : DF B0                       STX  PTR1
    1572/    E7C2 : C6 80                       LDAB #$80
    1573/    E7C4 : 3A                          ABX
    1574/    E7C5 : DF B2                       STX  PTR2      ;default end address
    1575/    E7C7 : BD E2 FC                    JSR  WSKIP
    1576/    E7CA : 27 1A                       BEQ  DUMP1     ;jump - 1 argument
    1577/    E7CC : BD E2 34                    JSR  BUFFARG   ;read argument
    1578/    E7CF : 7D 00 A8                    TST  COUNT
    1579/    E7D2 : 27 0B                       BEQ  DUMPERR   ;jump if no argument
    1580/    E7D4 : BD E2 FC                    JSR  WSKIP
    1581/    E7D7 : 26 06                       BNE  DUMPERR   ;jump if not cr
    1582/    E7D9 : DE 96                       LDX  SHFTREG
    1583/    E7DB : DF B2                       STX  PTR2
    1584/    E7DD : 20 07                       BRA  DUMP1     ;jump - 2 arguments
    1585/    E7DF : CE E6 98           DUMPERR  LDX  #MSG9     ;"bad argument"
    1586/    E7E2 : BD E5 05                    JSR  OUTSTRG
    1587/    E7E5 : 39                          RTS
    1588/    E7E6 :
    1589/    E7E6 :                    ;*ptrmem = ptr1;
    1590/    E7E6 :                    ;*ptr1 = ptr1 & $fff0;
    1591/    E7E6 :
    1592/    E7E6 : DC B0              DUMP1    LDD  PTR1
    1593/    E7E8 : DD AA                       STD  PTRMEM    ;new current location
    1594/    E7EA : C4 F0                       ANDB #$F0
    1595/    E7EC : DD B0                       STD  PTR1      ;start dump at 16 byte boundary
    1596/    E7EE :
    1597/    E7EE :                    ;*** dump loop starts here ***
    1598/    E7EE :                    ;*do:
    1599/    E7EE :                    ;*     output address of first byte;
    1600/    E7EE :
    1601/    E7EE : BD E4 F5           DUMPLP   JSR  OUTCRLF
    1602/    E7F1 : CE 00 B0                    LDX  #PTR1
    1603/    E7F4 : BD E4 E9                    JSR  OUT2BSP   ;first address
    1604/    E7F7 :
    1605/    E7F7 :                    ;*     x = ptr1;
    1606/    E7F7 :                    ;*     for(b=0; b=16; b++)
    1607/    E7F7 :                    ;*          output contents;
    1608/    E7F7 :
    1609/    E7F7 : DE B0                       LDX  PTR1      ;base address
    1610/    E7F9 : 5F                          CLRB           ;loop counter
    1611/    E7FA : BD E4 EC           DUMPDAT  JSR  OUT1BSP   ;hex value loop
    1612/    E7FD : 5C                          INCB
    1613/    E7FE : C1 10                       CMPB #$10
    1614/    E800 : 2D F8                       BLT  DUMPDAT    ;loop 16 times
    1615/    E802 :
    1616/    E802 :                    ;*     x = ptr1;
    1617/    E802 :                    ;*     for(b=0; b=16; b++)
    1618/    E802 :                    ;*          a = x[b];
    1619/    E802 :                    ;*          if($7A < a < $20)  a = $20;
    1620/    E802 :                    ;*          output ascii contents;
    1621/    E802 :
    1622/    E802 : 5F                          CLRB           ;loop counter
    1623/    E803 : DE B0              DUMPASC  LDX  PTR1      ;base address
    1624/    E805 : 3A                          ABX
    1625/    E806 : A6 00                       LDAA 0,X       ;ascii value loop
    1626/    E808 : 81 20                       CMPA #$20
    1627/    E80A : 25 04                       BLO  DUMP3     ;jump if non printable
    1628/    E80C : 81 7A                       CMPA #$7A
    1629/    E80E : 23 02                       BLS  DUMP4     ;jump if printable
    1630/    E810 : 86 20              DUMP3    LDAA #$20      ;space for non printables
    1631/    E812 : BD E3 BE           DUMP4    JSR  OUTPUT    ;output ascii value
    1632/    E815 : 5C                          INCB
    1633/    E816 : C1 10                       CMPB #$10
    1634/    E818 : 2D E9                       BLT  DUMPASC   ;loop 16 times
    1635/    E81A :
    1636/    E81A :                    ;*     chkabrt();
    1637/    E81A :                    ;*     ptr1 = ptr1 + $10;
    1638/    E81A :                    ;*while(ptr1 <= ptr2);
    1639/    E81A :                    ;*return;
    1640/    E81A :
    1641/    E81A : BD E3 1F                    JSR  CHKABRT   ;check abort or wait
    1642/    E81D : DC B0                       LDD  PTR1
    1643/    E81F : C3 00 10                    ADDD #$10      ;point to next 16 byte bound
    1644/    E822 : DD B0                       STD  PTR1      ;update ptr1
    1645/    E824 : 1A 93 B2                    CPD  PTR2
    1646/    E827 : 22 0E                       BHI  DUMP5     ;quit if ptr1 > ptr2
    1647/    E829 : 1A 83 00 00                 CPD  #$00      ;check wraparound at $ffff
    1648/    E82D : 26 BF                       BNE  DUMPLP    ;jump - no wraparound
    1649/    E82F : DC B2                       LDD  PTR2
    1650/    E831 : 1A 83 FF F0                 CPD  #$FFF0
    1651/    E835 : 25 B7                       BLO  DUMPLP    ;upper bound not at top
    1652/    E837 : 39                 DUMP5    RTS            ;quit
    1653/    E838 :
    1654/    E838 :
    1655/    E838 :
    1656/    E838 :                    ;**********
    1657/    E838 :                    ;*   eemod [<addr1> [<addr2>]]
    1658/    E838 :                    ;* Modifies the eeprom address range.
    1659/    E838 :                    ;*  EEMOD                 -show ee address range
    1660/    E838 :                    ;*  EEMOD <addr1>         -set range to addr1 -> addr1+2k
    1661/    E838 :                    ;*  EEMOD <addr1> <addr2> -set range to addr1 -> addr2
    1662/    E838 :                    ;**********
    1663/    E838 :                    ;*if(<addr1>)
    1664/    E838 :                    ;*    stree = addr1;
    1665/    E838 :                    ;*    endee = addr1 + 2k bytes;
    1666/    E838 :                    ;*if(<addr2>)
    1667/    E838 :                    ;*    endee = addr2;
    1668/    E838 :                    ;*print(stree,endee);
    1669/    E838 : =E838              EEMOD    EQU  *
    1670/    E838 : BD E2 FC                    JSR  WSKIP
    1671/    E83B : 27 34                       BEQ  EEMOD2    ;jump - no arguments
    1672/    E83D : BD E2 34                    JSR  BUFFARG   ;read argument
    1673/    E840 : 7D 00 A8                    TST  COUNT
    1674/    E843 : 27 3C                       BEQ  EEMODER   ;jump if no argument
    1675/    E845 : BD E3 17                    JSR  DCHEK
    1676/    E848 : 26 37                       BNE  EEMODER   ;jump if no delimeter
    1677/    E84A : DC 96                       LDD  SHFTREG
    1678/    E84C : DD B0                       STD  PTR1
    1679/    E84E : C3 07 FF                    ADDD #$07FF    ;add 2k bytes to stree
    1680/    E851 : DD B2                       STD  PTR2      ;default endee address
    1681/    E853 : BD E2 FC                    JSR  WSKIP
    1682/    E856 : 27 11                       BEQ  EEMOD1    ;jump - 1 argument
    1683/    E858 : BD E2 34                    JSR  BUFFARG   ;read argument
    1684/    E85B : 7D 00 A8                    TST  COUNT
    1685/    E85E : 27 21                       BEQ  EEMODER   ;jump if no argument
    1686/    E860 : BD E2 FC                    JSR  WSKIP
    1687/    E863 : 26 1C                       BNE  EEMODER   ;jump if not cr
    1688/    E865 : DE 96                       LDX  SHFTREG
    1689/    E867 : DF B2                       STX  PTR2
    1690/    E869 : DE B0              EEMOD1   LDX  PTR1
    1691/    E86B : DF 98                       STX  STREE     ;new stree address
    1692/    E86D : DE B2                       LDX  PTR2
    1693/    E86F : DF 9A                       STX  ENDEE     ;new endee address
    1694/    E871 : BD E4 F5           EEMOD2   JSR  OUTCRLF   ;display ee range
    1695/    E874 : CE 00 98                    LDX  #STREE
    1696/    E877 : BD E4 E9                    JSR  OUT2BSP
    1697/    E87A : CE 00 9A                    LDX  #ENDEE
    1698/    E87D : BD E4 E9                    JSR  OUT2BSP
    1699/    E880 : 39                          RTS
    1700/    E881 :
    1701/    E881 : CE E6 98           EEMODER  LDX  #MSG9     ;"bad argument"
    1702/    E884 : BD E5 05                    JSR  OUTSTRG
    1703/    E887 : 39                          RTS
    1704/    E888 :
    1705/    E888 :
    1706/    E888 :
    1707/    E888 :
    1708/    E888 :                    ;**********
    1709/    E888 :                    ;*  fill <addr1> <addr2> [<data>]  - Block fill
    1710/    E888 :                    ;*memory from addr1 to addr2 with data.  Data
    1711/    E888 :                    ;*defaults to $FF.
    1712/    E888 :                    ;**********
    1713/    E888 :                    ;*get addr1 and addr2
    1714/    E888 : =E888              FILL    EQU  *
    1715/    E888 : BD E2 FC                   JSR  WSKIP
    1716/    E88B : BD E2 34                   JSR  BUFFARG
    1717/    E88E : 7D 00 A8                   TST  COUNT
    1718/    E891 : 27 4F                      BEQ  FILLERR    ;jump if no argument
    1719/    E893 : BD E3 0C                   JSR  WCHEK
    1720/    E896 : 26 4A                      BNE  FILLERR    ;jump if bad argument
    1721/    E898 : DE 96                      LDX  SHFTREG
    1722/    E89A : DF B0                      STX  PTR1       ;address1
    1723/    E89C : BD E2 FC                   JSR  WSKIP
    1724/    E89F : BD E2 34                   JSR  BUFFARG
    1725/    E8A2 : 7D 00 A8                   TST  COUNT
    1726/    E8A5 : 27 3B                      BEQ  FILLERR    ;jump if no argument
    1727/    E8A7 : BD E3 17                   JSR  DCHEK
    1728/    E8AA : 26 36                      BNE  FILLERR    ;jump if bad argument
    1729/    E8AC : DE 96                      LDX  SHFTREG
    1730/    E8AE : DF B2                      STX  PTR2       ;address2
    1731/    E8B0 :
    1732/    E8B0 :                    ;*Get data if it exists
    1733/    E8B0 : 86 FF                      LDAA #$FF
    1734/    E8B2 : 97 C1                      STAA TMP2       ;default data
    1735/    E8B4 : BD E2 FC                   JSR  WSKIP
    1736/    E8B7 : 27 11                      BEQ  FILL1      ;jump if default data
    1737/    E8B9 : BD E2 34                   JSR  BUFFARG
    1738/    E8BC : 7D 00 A8                   TST  COUNT
    1739/    E8BF : 27 21                      BEQ  FILLERR    ;jump if no argument
    1740/    E8C1 : BD E2 FC                   JSR  WSKIP
    1741/    E8C4 : 26 1C                      BNE  FILLERR    ;jump if bad argument
    1742/    E8C6 : 96 97                      LDAA SHFTREG+1
    1743/    E8C8 : 97 C1                      STAA TMP2
    1744/    E8CA :
    1745/    E8CA :                    ;*while(ptr1 <= ptr2)
    1746/    E8CA :                    ;*   *ptr1 = data
    1747/    E8CA :                    ;*   if(*ptr1 != data) abort
    1748/    E8CA :
    1749/    E8CA : =E8CA              FILL1   EQU  *
    1750/    E8CA : BD E3 1F                   JSR  CHKABRT    ;check for abort
    1751/    E8CD : DE B0                      LDX  PTR1       ;starting address
    1752/    E8CF : 96 C1                      LDAA TMP2       ;data
    1753/    E8D1 : BD E2 8A                   JSR  WRITE      ;write the data to x
    1754/    E8D4 : A1 00                      CMPA 0,X
    1755/    E8D6 : 26 11                      BNE  FILLBAD    ;jump if no write
    1756/    E8D8 : 9C B2                      CPX  PTR2
    1757/    E8DA : 27 05                      BEQ  FILL2      ;quit yet?
    1758/    E8DC : 08                         INX
    1759/    E8DD : DF B0                      STX  PTR1
    1760/    E8DF : 20 E9                      BRA  FILL1      ;loop
    1761/    E8E1 : 39                 FILL2   RTS
    1762/    E8E2 :
    1763/    E8E2 : CE E6 98           FILLERR LDX  #MSG9     ;"bad argument"
    1764/    E8E5 : BD E5 05                   JSR  OUTSTRG
    1765/    E8E8 : 39                         RTS
    1766/    E8E9 :
    1767/    E8E9 : =E8E9              FILLBAD EQU  *
    1768/    E8E9 : CE 00 B0                   LDX  #PTR1     ;output bad address
    1769/    E8EC : BD E4 E9                   JSR  OUT2BSP
    1770/    E8EF : 39                         RTS
    1771/    E8F0 :
    1772/    E8F0 :
    1773/    E8F0 :
    1774/    E8F0 :                    ;*******************************************
    1775/    E8F0 :                    ;*   MEMORY [<addr>]
    1776/    E8F0 :                    ;*   [<addr>]/
    1777/    E8F0 :                    ;* Opens memory and allows user to modify the
    1778/    E8F0 :                    ;*contents at <addr> or the last opened location.
    1779/    E8F0 :                    ;*    Subcommands:
    1780/    E8F0 :                    ;* [<data>]<cr>       - Close current location and exit.
    1781/    E8F0 :                    ;* [<data>]<lf><+>    - Close current and open next.
    1782/    E8F0 :                    ;* [<data>]<^><-><bs> - Close current and open previous.
    1783/    E8F0 :                    ;* [<data>]<sp>       - Close current and open next.
    1784/    E8F0 :                    ;* [<data>]</><=>     - Reopen current location.
    1785/    E8F0 :                    ;*     The contents of the current location is only
    1786/    E8F0 :                    ;*  changed if valid data is entered before each
    1787/    E8F0 :                    ;*  subcommand.
    1788/    E8F0 :                    ;* [<addr>]O - Compute relative offset from current
    1789/    E8F0 :                    ;*     location to <addr>.  The current location must
    1790/    E8F0 :                    ;*     be the address of the offset byte.
    1791/    E8F0 :                    ;**********
    1792/    E8F0 :                    ;*a = wskip();
    1793/    E8F0 :                    ;*if(a != cr)
    1794/    E8F0 :                    ;*     a = buffarg();
    1795/    E8F0 :                    ;*     if(a != cr) return(bad argument);
    1796/    E8F0 :                    ;*     if(countu1 != 0) ptrmem[] = shftreg;
    1797/    E8F0 :
    1798/    E8F0 : BD E2 FC           MEMORY   JSR  WSKIP
    1799/    E8F3 : 27 18                       BEQ  MEM1      ;jump if cr
    1800/    E8F5 : BD E2 34                    JSR  BUFFARG
    1801/    E8F8 : BD E2 FC                    JSR  WSKIP
    1802/    E8FB : 27 07                       BEQ  MSLASH    ;jump if cr
    1803/    E8FD : CE E6 98                    LDX  #MSG9     ;"bad argument"
    1804/    E900 : BD E5 05                    JSR  OUTSTRG
    1805/    E903 : 39                          RTS
    1806/    E904 : 7D 00 A8           MSLASH   TST  COUNT
    1807/    E907 : 27 04                       BEQ  MEM1      ;jump if no argument
    1808/    E909 : DE 96                       LDX  SHFTREG
    1809/    E90B : DF AA                       STX  PTRMEM    ;update "current location"
    1810/    E90D :
    1811/    E90D :                    ;**********
    1812/    E90D :                    ;* Subcommands
    1813/    E90D :                    ;**********
    1814/    E90D :                    ;*outcrlf();
    1815/    E90D :                    ;*out2bsp(ptrmem[]);
    1816/    E90D :                    ;*out1bsp(ptrmem[0]);
    1817/    E90D :
    1818/    E90D : BD E4 F5           MEM1     JSR  OUTCRLF
    1819/    E910 : CE 00 AA           MEM2     LDX  #PTRMEM
    1820/    E913 : BD E4 E9                    JSR  OUT2BSP   ;output address
    1821/    E916 : DE AA              MEM3     LDX  PTRMEM
    1822/    E918 : BD E4 EC                    JSR  OUT1BSP   ;output contents
    1823/    E91B : 7F 00 96                    CLR  SHFTREG
    1824/    E91E : 7F 00 97                    CLR  SHFTREG+1
    1825/    E921 :                    ;*while 1
    1826/    E921 :                    ;*a = termarg();
    1827/    E921 :                    ;*     switch(a)
    1828/    E921 :                    ;*          case(space):
    1829/    E921 :                    ;*             chgbyt();
    1830/    E921 :                    ;*             ptrmem[]++;
    1831/    E921 :                    ;*             if(ptrmem%16 == 0) start new line;
    1832/    E921 :                    ;*          case(linefeed | +):
    1833/    E921 :                    ;*             chgbyt();
    1834/    E921 :                    ;*             ptrmem[]++;
    1835/    E921 :                    ;*          case(up arrow | backspace | -):
    1836/    E921 :                    ;*               chgbyt();
    1837/    E921 :                    ;*               ptrmem[]--;
    1838/    E921 :                    ;*          case('/' | '='):
    1839/    E921 :                    ;*               chgbyt();
    1840/    E921 :                    ;*               outcrlf();
    1841/    E921 :                    ;*          case(O):
    1842/    E921 :                    ;*               d = ptrmem[0] - (shftreg);
    1843/    E921 :                    ;*               if($80 < d < $ff81)
    1844/    E921 :                    ;*                    print(out of range);
    1845/    E921 :                    ;*               countt1 = d-1;
    1846/    E921 :                    ;*               out1bsp(countt1);
    1847/    E921 :                    ;*          case(carriage return):
    1848/    E921 :                    ;*               chgbyt();
    1849/    E921 :                    ;*               return;
    1850/    E921 :                    ;*          default: return(command?)
    1851/    E921 :
    1852/    E921 : BD E2 57           MEM4     JSR  TERMARG
    1853/    E924 : BD E1 A7                    JSR  UPCASE
    1854/    E927 : DE AA                       LDX  PTRMEM
    1855/    E929 : 81 20                       CMPA #$20
    1856/    E92B : 27 31                       BEQ  MEMSP     ;jump if space
    1857/    E92D : 81 0A                       CMPA #$0A
    1858/    E92F : 27 3E                       BEQ  MEMLF     ;jump if linefeed
    1859/    E931 : 81 2B                       CMPA #$2B
    1860/    E933 : 27 43                       BEQ  MEMPLUS   ;jump if +
    1861/    E935 : 81 5E                       CMPA #$5E
    1862/    E937 : 27 48                       BEQ  MEMUA     ;jump if up arrow
    1863/    E939 : 81 2D                       CMPA #$2D
    1864/    E93B : 27 44                       BEQ  MEMUA     ;jump if -
    1865/    E93D : 81 08                       CMPA #$08
    1866/    E93F : 27 40                       BEQ  MEMUA     ;jump if backspace
    1867/    E941 : 81 2F                       CMPA #'/'
    1868/    E943 : 27 45                       BEQ  MEMSL     ;jump if /
    1869/    E945 : 81 3D                       CMPA #'='
    1870/    E947 : 27 41                       BEQ  MEMSL     ;jump if =
    1871/    E949 : 81 4F                       CMPA #'O'
    1872/    E94B : 27 43                       BEQ  MEMOFF    ;jump if O
    1873/    E94D : 81 0D                       CMPA #$0D
    1874/    E94F : 27 6F                       BEQ  MEMCR     ;jump if carriage ret
    1875/    E951 : 81 2E                       CMPA #'.'
    1876/    E953 : 27 6E                       BEQ  MEMEND    ;jump if .
    1877/    E955 : CE E6 8F                    LDX  #MSG8     ;"command?"
    1878/    E958 : BD E5 05                    JSR  OUTSTRG
    1879/    E95B : 7E E9 0D                    JMP  MEM1
    1880/    E95E : BD E2 7F           MEMSP    JSR  CHGBYT
    1881/    E961 : 08                          INX
    1882/    E962 : DF AA                       STX  PTRMEM
    1883/    E964 : 8F                          XGDX
    1884/    E965 : C4 0F                       ANDB #$0F
    1885/    E967 : 27 03                       BEQ  MEMSP1    ;jump if mod16=0
    1886/    E969 : 7E E9 16                    JMP  MEM3      ;continue same line
    1887/    E96C : 7E E9 0D           MEMSP1   JMP  MEM1      ;.. else start new line
    1888/    E96F : BD E2 7F           MEMLF    JSR  CHGBYT
    1889/    E972 : 08                          INX
    1890/    E973 : DF AA                       STX  PTRMEM
    1891/    E975 : 7E E9 10                    JMP  MEM2      ;output next address
    1892/    E978 : BD E2 7F           MEMPLUS  JSR  CHGBYT
    1893/    E97B : 08                          INX
    1894/    E97C : DF AA                       STX  PTRMEM
    1895/    E97E : 7E E9 0D                    JMP  MEM1      ;output cr, next address
    1896/    E981 : BD E2 7F           MEMUA    JSR  CHGBYT
    1897/    E984 : 09                          DEX
    1898/    E985 : DF AA                       STX  PTRMEM
    1899/    E987 : 7E E9 0D                    JMP  MEM1      ;output cr, previous address
    1900/    E98A : BD E2 7F           MEMSL    JSR  CHGBYT
    1901/    E98D : 7E E9 0D                    JMP  MEM1      ;output cr, same address
    1902/    E990 : DC 96              MEMOFF   LDD  SHFTREG   ;destination addr
    1903/    E992 : 93 AA                       SUBD PTRMEM
    1904/    E994 : 81 00                       CMPA #$0
    1905/    E996 : 26 06                       BNE  MEMOFF1   ;jump if not 0
    1906/    E998 : C1 80                       CMPB #$80
    1907/    E99A : 23 13                       BLS  MEMOFF3   ;jump if in range
    1908/    E99C : 20 08                       BRA  MEMOFF2   ;out of range
    1909/    E99E : 81 FF              MEMOFF1  CMPA #$FF
    1910/    E9A0 : 26 04                       BNE  MEMOFF2   ;out of range
    1911/    E9A2 : C1 81                       CMPB #$81
    1912/    E9A4 : 24 09                       BHS  MEMOFF3   ;in range
    1913/    E9A6 : CE E6 77           MEMOFF2  LDX  #MSG3     ;"Too long"
    1914/    E9A9 : BD E5 05                    JSR  OUTSTRG
    1915/    E9AC : 7E E9 0D                    JMP  MEM1      ;output cr, addr, contents
    1916/    E9AF : 83 00 01           MEMOFF3  SUBD #$1       ;b now has offset
    1917/    E9B2 : D7 C3                       STAB TMP4
    1918/    E9B4 : BD E4 EF                    JSR  OUTSPAC
    1919/    E9B7 : CE 00 C3                    LDX  #TMP4
    1920/    E9BA : BD E4 EC                    JSR  OUT1BSP   ;output offset
    1921/    E9BD : 7E E9 0D                    JMP  MEM1      ;output cr, addr, contents
    1922/    E9C0 : BD E2 7F           MEMCR    JSR  CHGBYT
    1923/    E9C3 : 39                 MEMEND   RTS            ;exit task
    1924/    E9C4 :
    1925/    E9C4 :
    1926/    E9C4 :                    ;**********
    1927/    E9C4 :                    ;*   move <src1> <src2> [<dest>]  - move
    1928/    E9C4 :                    ;*block at <src1> to <src2> to <dest>.
    1929/    E9C4 :                    ;*  Moves block 1 byte up if no <dest>.
    1930/    E9C4 :                    ;**********
    1931/    E9C4 :                    ;*a = buffarg();
    1932/    E9C4 :                    ;*if(countu1 = 0) return(bad argument);
    1933/    E9C4 :                    ;*if( !wchek(a) ) return(bad argument);
    1934/    E9C4 :                    ;*ptr1 = shftreg;         /* src1 */
    1935/    E9C4 :
    1936/    E9C4 : =E9C4              MOVE     EQU  *
    1937/    E9C4 : BD E2 34                    JSR  BUFFARG
    1938/    E9C7 : 7D 00 A8                    TST  COUNT
    1939/    E9CA : 27 2B                       BEQ  MOVERR    ;jump if no arg
    1940/    E9CC : BD E3 0C                    JSR  WCHEK
    1941/    E9CF : 26 26                       BNE  MOVERR    ;jump if no delim
    1942/    E9D1 : DE 96                       LDX  SHFTREG   ;src1
    1943/    E9D3 : DF B0                       STX  PTR1
    1944/    E9D5 :
    1945/    E9D5 :                    ;*a = buffarg();
    1946/    E9D5 :                    ;*if(countu1 = 0) return(bad argument);
    1947/    E9D5 :                    ;*if( !dchek(a) ) return(bad argument);
    1948/    E9D5 :                    ;*ptr2 = shftreg;         /* src2 */
    1949/    E9D5 :
    1950/    E9D5 : BD E2 34                    JSR  BUFFARG
    1951/    E9D8 : 7D 00 A8                    TST  COUNT
    1952/    E9DB : 27 1A                       BEQ  MOVERR    ;jump if no arg
    1953/    E9DD : BD E3 17                    JSR  DCHEK
    1954/    E9E0 : 26 15                       BNE  MOVERR    ;jump if no delim
    1955/    E9E2 : DE 96                       LDX  SHFTREG   ;src2
    1956/    E9E4 : DF B2                       STX  PTR2
    1957/    E9E6 :
    1958/    E9E6 :                    ;*a = buffarg();
    1959/    E9E6 :                    ;*a = wskip();
    1960/    E9E6 :                    ;*if(a != cr) return(bad argument);
    1961/    E9E6 :                    ;*if(countu1 != 0) tmp2 = shftreg;  /* dest */
    1962/    E9E6 :                    ;*else tmp2 = ptr1 + 1;
    1963/    E9E6 :
    1964/    E9E6 : BD E2 34                    JSR  BUFFARG
    1965/    E9E9 : BD E2 FC                    JSR  WSKIP
    1966/    E9EC : 26 09                       BNE  MOVERR    ;jump if not cr
    1967/    E9EE : 7D 00 A8                    TST  COUNT
    1968/    E9F1 : 27 0B                       BEQ  MOVE1     ;jump if no arg
    1969/    E9F3 : DE 96                       LDX  SHFTREG   ;dest
    1970/    E9F5 : 20 0A                       BRA  MOVE2
    1971/    E9F7 : CE E6 98           MOVERR   LDX  #MSG9     ;"bad argument"
    1972/    E9FA : BD E5 05                    JSR  OUTSTRG
    1973/    E9FD : 39                          RTS
    1974/    E9FE :
    1975/    E9FE : DE B0              MOVE1    LDX  PTR1
    1976/    EA00 : 08                          INX            ;default dest
    1977/    EA01 : DF B4              MOVE2    STX  PTR3
    1978/    EA03 :
    1979/    EA03 :                    ;*if(src1 < dest <= src2)
    1980/    EA03 :                    ;*     dest = dest+(src2-src1);
    1981/    EA03 :                    ;*     for(x = src2; x = src1; x--)
    1982/    EA03 :                    ;*          dest[0]-- = x[0]--;
    1983/    EA03 : DE B4                       LDX  PTR3        ;dest
    1984/    EA05 : 9C B0                       CPX  PTR1        ;src1
    1985/    EA07 : 23 28                       BLS  MOVE3       ;jump if dest =< src1
    1986/    EA09 : 9C B2                       CPX  PTR2        ;src2
    1987/    EA0B : 22 24                       BHI  MOVE3       ;jump if dest > src2
    1988/    EA0D : DC B2                       LDD  PTR2
    1989/    EA0F : 93 B0                       SUBD PTR1
    1990/    EA11 : D3 B4                       ADDD PTR3
    1991/    EA13 : DD B4                       STD  PTR3        ;dest = dest+(src2-src1)
    1992/    EA15 : DE B2                       LDX  PTR2
    1993/    EA17 : BD E3 1F           MOVELP1  JSR  CHKABRT     ;check for abort
    1994/    EA1A : A6 00                       LDAA 0,X         ;char at src2
    1995/    EA1C : 3C                          PSHX
    1996/    EA1D : DE B4                       LDX  PTR3
    1997/    EA1F : BD E2 8A                    JSR  WRITE       ;write a to x
    1998/    EA22 : A1 00                       CMPA 0,X
    1999/    EA24 : 26 28                       BNE  MOVEBAD     ;jump if no write
    2000/    EA26 : 09                          DEX
    2001/    EA27 : DF B4                       STX  PTR3
    2002/    EA29 : 38                          PULX
    2003/    EA2A : 9C B0                       CPX  PTR1
    2004/    EA2C : 27 1F                       BEQ  MOVRTS
    2005/    EA2E : 09                          DEX
    2006/    EA2F : 20 E6                       BRA  MOVELP1    ;Loop SRC2 - SRC1 times
    2007/    EA31 :                    ;*
    2008/    EA31 :                    ;* else
    2009/    EA31 :                    ;*     for(x=src1; x=src2; x++)
    2010/    EA31 :                    ;*          dest[0]++ = x[0]++;
    2011/    EA31 :
    2012/    EA31 :
    2013/    EA31 : DE B0              MOVE3    LDX  PTR1        ;srce1
    2014/    EA33 : BD E3 1F           MOVELP2  JSR  CHKABRT     ;check for abort
    2015/    EA36 : A6 00                       LDAA 0,X
    2016/    EA38 : 3C                          PSHX
    2017/    EA39 : DE B4                       LDX  PTR3        ;dest
    2018/    EA3B : BD E2 8A                    JSR  WRITE       ;write a to x
    2019/    EA3E : A1 00                       CMPA 0,X
    2020/    EA40 : 26 0C                       BNE  MOVEBAD     ;jump if no write
    2021/    EA42 : 08                          INX
    2022/    EA43 : DF B4                       STX  PTR3
    2023/    EA45 : 38                          PULX
    2024/    EA46 : 9C B2                       CPX  PTR2
    2025/    EA48 : 27 03                       BEQ  MOVRTS
    2026/    EA4A : 08                          INX
    2027/    EA4B : 20 E6                       BRA  MOVELP2      ;Loop SRC2-SRC1 times
    2028/    EA4D : 39                 MOVRTS   RTS
    2029/    EA4E :
    2030/    EA4E : 38                 MOVEBAD  PULX              ;restore stack
    2031/    EA4F : CE 00 B4                    LDX  #PTR3
    2032/    EA52 : BD E4 E9                    JSR  OUT2BSP      ;output bad address
    2033/    EA55 : 39                          RTS
    2034/    EA56 :
    2035/    EA56 :
    2036/    EA56 :                    ;****************
    2037/    EA56 :                    ;*  assem(addr) -68HC11 line assembler/disassembler.
    2038/    EA56 :                    ;*       This routine will disassemble the opcode at
    2039/    EA56 :                    ;*<addr> and then allow the user to enter a line for
    2040/    EA56 :                    ;*assembly. Rules for assembly are as follows:
    2041/    EA56 :                    ;* -A '#' sign indicates immediate addressing.
    2042/    EA56 :                    ;* -A ',' (comma) indicates indexed addressing
    2043/    EA56 :                    ;*       and the next character must be X or Y.
    2044/    EA56 :                    ;* -All arguments are assumed to be hex and the
    2045/    EA56 :                    ;*       '$' sign shouldn't be used.
    2046/    EA56 :                    ;* -Arguments should be separated by 1 or more
    2047/    EA56 :                    ;*       spaces or tabs.
    2048/    EA56 :                    ;* -Any input after the required number of
    2049/    EA56 :                    ;*       arguments is ignored.
    2050/    EA56 :                    ;* -Upper or lower case makes no difference.
    2051/    EA56 :                    ;*
    2052/    EA56 :                    ;*       To signify end of input line, the following
    2053/    EA56 :                    ;*commands are available and have the indicated action:
    2054/    EA56 :                    ;*   <cr>      - Finds the next opcode for
    2055/    EA56 :                    ;*          assembly.  If there was no assembly input,
    2056/    EA56 :                    ;*          the next opcode disassembled is retrieved
    2057/    EA56 :                    ;*          from the disassembler.
    2058/    EA56 :                    ;*   <lf><+>   - Works the same as carriage return
    2059/    EA56 :                    ;*          except if there was no assembly input, the
    2060/    EA56 :                    ;*          <addr> is incremented and the next <addr> is
    2061/    EA56 :                    ;*          disassembled.
    2062/    EA56 :                    ;*    <^><->   - Decrements <addr> and the previous
    2063/    EA56 :                    ;*          address is then disassembled.
    2064/    EA56 :                    ;*    </><=>   - Redisassembles the current address.
    2065/    EA56 :                    ;*
    2066/    EA56 :                    ;*       To exit the assembler use CONTROL A or . (period).
    2067/    EA56 :                    ;*Of course control X and DEL will also allow you to abort.
    2068/    EA56 :                    ;*** Equates for assembler ***
    2069/    EA56 : =0                 PAGE1   EQU  $00     ;values for page opcodes
    2070/    EA56 : =18                PAGE2   EQU  $18
    2071/    EA56 : =1A                PAGE3   EQU  $1A
    2072/    EA56 : =CD                PAGE4   EQU  $CD
    2073/    EA56 : =0                 IMMED   EQU  $0      ;addressing modes
    2074/    EA56 : =1                 INDX    EQU  $1
    2075/    EA56 : =2                 INDY    EQU  $2
    2076/    EA56 : =3                 LIMMED  EQU  $3      ;(long immediate)
    2077/    EA56 : =4                 OTHER   EQU  $4
    2078/    EA56 :
    2079/    EA56 :                    ;*** Rename variables for assem/disassem ***
    2080/    EA56 : =C1                AMODE   EQU  TMP2    ;addressing mode
    2081/    EA56 : =C2                YFLAG   EQU  TMP3
    2082/    EA56 : =C3                PNORM   EQU  TMP4    ;page for normal opcode
    2083/    EA56 : =BE                OLDPC   EQU  PTR8
    2084/    EA56 : =B0                PC      EQU  PTR1    ;program counter
    2085/    EA56 : =B2                PX      EQU  PTR2    ;page for x indexed
    2086/    EA56 : =B3                PY      EQU  PTR2+1  ;page for y indexed
    2087/    EA56 : =B4                BASEOP  EQU  PTR3    ;base opcode
    2088/    EA56 : =B5                CLASS   EQU  PTR3+1  ;class
    2089/    EA56 : =B6                DISPC   EQU  PTR4    ;pc for disassembler
    2090/    EA56 : =B8                BRADDR  EQU  PTR5    ;relative branch offset
    2091/    EA56 : =BA                MNEPTR  EQU  PTR6    ;pointer to table for dis
    2092/    EA56 : =BC                ASSCOMM EQU  PTR7    ;subcommand for assembler
    2093/    EA56 :
    2094/    EA56 :                    ;*** Error messages for assembler ***
    2095/    EA56 : EA 68              MSGDIR  FDB  MSGA1   ;message table index
    2096/    EA58 : EA 7B                      FDB  MSGA2
    2097/    EA5A : EA 8E                      FDB  MSGA3
    2098/    EA5C : EA 9D                      FDB  MSGA4
    2099/    EA5E : EA AA                      FDB  MSGA5
    2100/    EA60 : EA BD                      FDB  MSGA6
    2101/    EA62 : EA D5                      FDB  MSGA7
    2102/    EA64 : EA F0                      FDB  MSGA8
    2103/    EA66 : EA FD                      FDB  MSGA9
    2104/    EA68 : 49 6D 6D 65 64 20  MSGA1   FCC  'Immed mode illegal'
             EA6E : 6D 6F 64 65 20 69
             EA74 : 6C 6C 65 67 61 6C
    2105/    EA7A : 04                         FCB  EOT
    2106/    EA7B : 45 72 72 6F 72 20  MSGA2   FCC  'Error in Mne table'
             EA81 : 69 6E 20 4D 6E 65
             EA87 : 20 74 61 62 6C 65
    2107/    EA8D : 04                         FCB  EOT
    2108/    EA8E : 49 6C 6C 65 67 61  MSGA3   FCC  'Illegal bit op'
             EA94 : 6C 20 62 69 74 20
             EA9A : 6F 70
    2109/    EA9C : 04                         FCB  EOT
    2110/    EA9D : 42 61 64 20 61 72  MSGA4   FCC  'Bad argument'
             EAA3 : 67 75 6D 65 6E 74
    2111/    EAA9 : 04                         FCB  EOT
    2112/    EAAA : 4D 6E 65 6D 6F 6E  MSGA5   FCC  'Mnemonic not found'
             EAB0 : 69 63 20 6E 6F 74
             EAB6 : 20 66 6F 75 6E 64
    2113/    EABC : 04                         FCB  EOT
    2114/    EABD : 55 6E 6B 6E 6F 77  MSGA6   FCC  'Unknown addressing mode'
             EAC3 : 6E 20 61 64 64 72
             EAC9 : 65 73 73 69 6E 67
             EACF : 20 6D 6F 64 65
    2115/    EAD4 : 04                         FCB  EOT
    2116/    EAD5 : 49 6E 64 65 78 65  MSGA7   FCC  'Indexed addressing assumed'
             EADB : 64 20 61 64 64 72
             EAE1 : 65 73 73 69 6E 67
             EAE7 : 20 61 73 73 75 6D
             EAED : 65 64
    2117/    EAEF : 04                         FCB  EOT
    2118/    EAF0 : 53 79 6E 74 61 78  MSGA8   FCC  'Syntax error'
             EAF6 : 20 65 72 72 6F 72
    2119/    EAFC : 04                         FCB  EOT
    2120/    EAFD : 42 72 61 6E 63 68  MSGA9   FCC  'Branch out of range'
             EB03 : 20 6F 75 74 20 6F
             EB09 : 66 20 72 61 6E 67
             EB0F : 65
    2121/    EB10 : 04                         FCB  EOT
    2122/    EB11 :
    2123/    EB11 :                    ;**********
    2124/    EB11 :                    ;*oldpc = rambase;
    2125/    EB11 :                    ;*a = wskip();
    2126/    EB11 :                    ;*if (a != cr)
    2127/    EB11 :                    ;*   buffarg()
    2128/    EB11 :                    ;*   a = wskip();
    2129/    EB11 :                    ;*   if ( a != cr ) return(error);
    2130/    EB11 :                    ;*   oldpc = a;
    2131/    EB11 : =EB11              ASSEM   EQU  *
    2132/    EB11 : CE 00 00                   LDX  #RAMBS
    2133/    EB14 : DF BE                      STX  OLDPC
    2134/    EB16 : BD E2 FC                   JSR  WSKIP
    2135/    EB19 : 27 13                      BEQ  ASSLOOP ;jump if no argument
    2136/    EB1B : BD E2 34                   JSR  BUFFARG
    2137/    EB1E : BD E2 FC                   JSR  WSKIP
    2138/    EB21 : 27 07                      BEQ  ASSEM1  ;jump if argument ok
    2139/    EB23 : CE EA 9D                   LDX  #MSGA4  ;"bad argument"
    2140/    EB26 : BD E5 05                   JSR  OUTSTRG
    2141/    EB29 : 39                         RTS
    2142/    EB2A : DE 96              ASSEM1  LDX  SHFTREG
    2143/    EB2C : DF BE                      STX  OLDPC
    2144/    EB2E :
    2145/    EB2E :                    ;*repeat
    2146/    EB2E :                    ;*  pc = oldpc;
    2147/    EB2E :                    ;*  out2bsp(pc);
    2148/    EB2E :                    ;*  disassem();
    2149/    EB2E :                    ;*  a=readln();
    2150/    EB2E :                    ;*  asscomm = a;  /* save command */
    2151/    EB2E :                    ;*  if(a == [^,+,-,/,=]) outcrlf;
    2152/    EB2E :                    ;*  if(a == 0) return(error);
    2153/    EB2E :
    2154/    EB2E : DE BE              ASSLOOP LDX  OLDPC
    2155/    EB30 : DF B0                      STX  PC
    2156/    EB32 : BD E4 F5                   JSR  OUTCRLF
    2157/    EB35 : CE 00 B0                   LDX  #PC
    2158/    EB38 : BD E4 E9                   JSR  OUT2BSP   ;output the address
    2159/    EB3B : BD F3 63                   JSR  DISASSM   ;disassemble opcode
    2160/    EB3E : BD E5 25                   JSR  TABTO
    2161/    EB41 : 86 3E                      LDAA #PROMPT   ;prompt user
    2162/    EB43 : BD E4 D9                   JSR  OUTA      ;output prompt character
    2163/    EB46 : BD EB F2                   JSR  READLN    ;read input for assembly
    2164/    EB49 : 97 BC                      STAA ASSCOMM
    2165/    EB4B : 81 5E                      CMPA #'^'
    2166/    EB4D : 27 15                      BEQ  ASSLP0    ;jump if '^'
    2167/    EB4F : 81 2B                      CMPA #'+'
    2168/    EB51 : 27 11                      BEQ  ASSLP0    ;jump if '+'
    2169/    EB53 : 81 2D                      CMPA #'-'
    2170/    EB55 : 27 0D                      BEQ  ASSLP0    ;jump if '-'
    2171/    EB57 : 81 2F                      CMPA #'/'
    2172/    EB59 : 27 09                      BEQ  ASSLP0    ;jump if '/'
    2173/    EB5B : 81 3D                      CMPA #'='
    2174/    EB5D : 27 05                      BEQ  ASSLP0    ;jump if '='
    2175/    EB5F : 81 00                      CMPA #$00
    2176/    EB61 : 26 04                      BNE  ASSLP1    ;jump if none of above
    2177/    EB63 : 39                         RTS            ;return if bad input
    2178/    EB64 : BD E4 F5           ASSLP0  JSR  OUTCRLF
    2179/    EB67 : =EB67              ASSLP1  EQU  *         ;come here for cr or lf
    2180/    EB67 : BD E4 EF                   JSR  OUTSPAC
    2181/    EB6A : BD E4 EF                   JSR  OUTSPAC
    2182/    EB6D : BD E4 EF                   JSR  OUTSPAC
    2183/    EB70 : BD E4 EF                   JSR  OUTSPAC
    2184/    EB73 : BD E4 EF                   JSR  OUTSPAC
    2185/    EB76 :
    2186/    EB76 :                    ;*  b = parse(input); /* get mnemonic */
    2187/    EB76 :                    ;*  if(b > 5) print("not found"); asscomm='/';
    2188/    EB76 :                    ;*  elseif(b >= 1)
    2189/    EB76 :                    ;*     msrch();
    2190/    EB76 :                    ;*     if(class==$FF)
    2191/    EB76 :                    ;*        print("not found"); asscomm='/';
    2192/    EB76 :                    ;*     else
    2193/    EB76 :                    ;*        a = doop(opcode,class);
    2194/    EB76 :                    ;*        if(a == 0) dispc=0;
    2195/    EB76 :                    ;*        else process error; asscomm='/';
    2196/    EB76 :
    2197/    EB76 : BD EC 3B                   JSR  PARSE
    2198/    EB79 : C1 05                      CMPB #$5
    2199/    EB7B : 2F 08                      BLE  ASSLP2  ;jump if mnemonic <= 5 chars
    2200/    EB7D : CE EA AA                   LDX  #MSGA5  ;"mnemonic not found"
    2201/    EB80 : BD E5 05                   JSR  OUTSTRG
    2202/    EB83 : 20 2F                      BRA  ASSLP5
    2203/    EB85 : =EB85              ASSLP2  EQU  *
    2204/    EB85 : C1 00                      CMPB #$0
    2205/    EB87 : 27 2E                      BEQ  ASSLP10 ;jump if no input
    2206/    EB89 : BD EC 82                   JSR  MSRCH
    2207/    EB8C : 96 B5                      LDAA CLASS
    2208/    EB8E : 81 FF                      CMPA #$FF
    2209/    EB90 : 26 08                      BNE  ASSLP3
    2210/    EB92 : CE EA AA                   LDX  #MSGA5  ;"mnemonic not found"
    2211/    EB95 : BD E5 05                   JSR  OUTSTRG
    2212/    EB98 : 20 1A                      BRA  ASSLP5
    2213/    EB9A : BD EC BA           ASSLP3  JSR  DOOP
    2214/    EB9D : 81 00                      CMPA #$00
    2215/    EB9F : 26 07                      BNE  ASSLP4  ;jump if doop error
    2216/    EBA1 : CE 00 00                   LDX  #$00
    2217/    EBA4 : DF B6                      STX  DISPC   ;indicate good assembly
    2218/    EBA6 : 20 0F                      BRA  ASSLP10
    2219/    EBA8 : 4A                 ASSLP4  DECA         ;a = error message index
    2220/    EBA9 : 16                         TAB
    2221/    EBAA : CE EA 56                   LDX  #MSGDIR
    2222/    EBAD : 3A                         ABX
    2223/    EBAE : 3A                         ABX
    2224/    EBAF : EE 00                      LDX  0,X
    2225/    EBB1 : BD E5 05                   JSR  OUTSTRG ;output error message
    2226/    EBB4 : 7F 00 BC           ASSLP5  CLR  ASSCOMM ;error command
    2227/    EBB7 :
    2228/    EBB7 :                    ;*  /* compute next address - asscomm holds subcommand
    2229/    EBB7 :                    ;*     and dispc indicates if valid assembly occured. */
    2230/    EBB7 :                    ;*  if(asscomm== ^ or -) oldpc--;
    2231/    EBB7 :                    ;*  if(asscomm==(lf or + or cr)
    2232/    EBB7 :                    ;*     if(dispc==0) oldpc=pc;   /* good assembly */
    2233/    EBB7 :                    ;*     else
    2234/    EBB7 :                    ;*        if(asscomm==lf or +) dispc= ++oldpc;
    2235/    EBB7 :                    ;*        oldpc=dispc;
    2236/    EBB7 :                    ;*until(eot)
    2237/    EBB7 : =EBB7              ASSLP10 EQU  *
    2238/    EBB7 : 96 BC                      LDAA ASSCOMM
    2239/    EBB9 : 81 5E                      CMPA #'^'
    2240/    EBBB : 27 04                      BEQ  ASSLPA     ;jump if '^'
    2241/    EBBD : 81 2D                      CMPA #'-'
    2242/    EBBF : 26 07                      BNE  ASSLP11    ;jump not '-'
    2243/    EBC1 : DE BE              ASSLPA  LDX  OLDPC      ;back up for '^' or '-'
    2244/    EBC3 : 09                         DEX
    2245/    EBC4 : DF BE                      STX  OLDPC
    2246/    EBC6 : 20 27                      BRA  ASSLP15
    2247/    EBC8 : 81 0A              ASSLP11 CMPA #$0A
    2248/    EBCA : 27 08                      BEQ  ASSLP12    ;jump if linefeed
    2249/    EBCC : 81 2B                      CMPA #'+'
    2250/    EBCE : 27 04                      BEQ  ASSLP12    ;jump if '+'
    2251/    EBD0 : 81 0D                      CMPA #$0D
    2252/    EBD2 : 26 1B                      BNE  ASSLP15    ;jump if not cr
    2253/    EBD4 : DE B6              ASSLP12 LDX  DISPC
    2254/    EBD6 : 26 06                      BNE  ASSLP13    ;jump if dispc != 0
    2255/    EBD8 : DE B0                      LDX  PC
    2256/    EBDA : DF BE                      STX  OLDPC
    2257/    EBDC : 20 11                      BRA  ASSLP15
    2258/    EBDE : 81 0A              ASSLP13 CMPA #$0A
    2259/    EBE0 : 27 04                      BEQ  ASSLPB    ;jump not lf
    2260/    EBE2 : 81 2B                      CMPA #'+'
    2261/    EBE4 : 26 05                      BNE  ASSLP14   ;jump not lf or '+'
    2262/    EBE6 : DE BE              ASSLPB  LDX  OLDPC
    2263/    EBE8 : 08                         INX
    2264/    EBE9 : DF B6                      STX  DISPC
    2265/    EBEB : DE B6              ASSLP14 LDX  DISPC
    2266/    EBED : DF BE                      STX  OLDPC
    2267/    EBEF : 7E EB 2E           ASSLP15 JMP  ASSLOOP
    2268/    EBF2 :
    2269/    EBF2 :                    ;****************
    2270/    EBF2 :                    ;*  readln() --- Read input from terminal into buffer
    2271/    EBF2 :                    ;* until a command character is read (cr,lf,/,^).
    2272/    EBF2 :                    ;* If more chars are typed than the buffer will hold,
    2273/    EBF2 :                    ;* the extra characters are overwritten on the end.
    2274/    EBF2 :                    ;*  On exit: b=number of chars read, a=0 if quit,
    2275/    EBF2 :                    ;* else a=next command.
    2276/    EBF2 :                    ;****************
    2277/    EBF2 :                    ;*for(b==0;b<=bufflng;b++) inbuff[b] = cr;
    2278/    EBF2 :
    2279/    EBF2 : 5F                 READLN  CLRB
    2280/    EBF3 : 86 0D                      LDAA #$0D    ;carriage ret
    2281/    EBF5 : CE 00 6B           RLN0    LDX  #INBUFF
    2282/    EBF8 : 3A                         ABX
    2283/    EBF9 : A7 00                      STAA 0,X     ;initialize input buffer
    2284/    EBFB : 5C                         INCB
    2285/    EBFC : C1 23                      CMPB #BUFFLNG
    2286/    EBFE : 2D F5                      BLT  RLN0
    2287/    EC00 :                    ;*b=0;
    2288/    EC00 :                    ;*repeat
    2289/    EC00 :                    ;*  if(a == (ctla, cntlc, cntld, cntlx, del))
    2290/    EC00 :                    ;*     return(a=0);
    2291/    EC00 :                    ;*  if(a == backspace)
    2292/    EC00 :                    ;*     if(b > 0) b--;
    2293/    EC00 :                    ;*     else b=0;
    2294/    EC00 :                    ;*  else  inbuff[b] = upcase(a);
    2295/    EC00 :                    ;*  if(b < bufflng) b++;
    2296/    EC00 :                    ;*until (a == [cr,lf,+,^,-,/,=])
    2297/    EC00 :                    ;*return(a);
    2298/    EC00 :
    2299/    EC00 : 5F                         CLRB
    2300/    EC01 : BD E5 31           RLN1    JSR  INCHAR
    2301/    EC04 : 81 7F                      CMPA #DEL    ;Delete
    2302/    EC06 : 27 31                      BEQ  RLNQUIT
    2303/    EC08 : 81 18                      CMPA #CTLX   ;Control X
    2304/    EC0A : 27 2D                      BEQ  RLNQUIT
    2305/    EC0C : 81 01                      CMPA #CTLA   ;Control A
    2306/    EC0E : 27 29                      BEQ  RLNQUIT
    2307/    EC10 : 81 2E                      CMPA #$2E    ;Period
    2308/    EC12 : 27 25                      BEQ  RLNQUIT
    2309/    EC14 : 81 03                      CMPA #$03    ;Control C
    2310/    EC16 : 27 21                      BEQ  RLNQUIT
    2311/    EC18 : 81 04                      CMPA #$04    ;Control D
    2312/    EC1A : 27 1D                      BEQ  RLNQUIT
    2313/    EC1C : 81 08                      CMPA #$08    ;backspace
    2314/    EC1E : 26 05                      BNE  RLN2
    2315/    EC20 : 5A                         DECB
    2316/    EC21 : 2E DE                      BGT  RLN1
    2317/    EC23 : 20 CD                      BRA  READLN  ;start over
    2318/    EC25 : CE 00 6B           RLN2    LDX  #INBUFF
    2319/    EC28 : 3A                         ABX
    2320/    EC29 : BD E1 A7                   JSR  UPCASE
    2321/    EC2C : A7 00                      STAA 0,X     ;put char in buffer
    2322/    EC2E : C1 23                      CMPB #BUFFLNG        ;max buffer length
    2323/    EC30 : 2C 01                      BGE  RLN3    ;jump if buffer full
    2324/    EC32 : 5C                         INCB         ;move buffer pointer
    2325/    EC33 : BD EC 67           RLN3    JSR  ASSCHEK ;check for subcommand
    2326/    EC36 : 26 C9                      BNE  RLN1
    2327/    EC38 : 39                         RTS
    2328/    EC39 : 4F                 RLNQUIT CLRA         ;quit
    2329/    EC3A : 39                         RTS          ;return
    2330/    EC3B :
    2331/    EC3B :
    2332/    EC3B :                    ;**********
    2333/    EC3B :                    ;*  parse() -parse out the mnemonic from INBUFF
    2334/    EC3B :                    ;* to COMBUFF. on exit: b=number of chars parsed.
    2335/    EC3B :                    ;**********
    2336/    EC3B :                    ;*combuff[3] = <space>;   initialize 4th character to space.
    2337/    EC3B :                    ;*ptrbuff[] = inbuff[];
    2338/    EC3B :                    ;*a=wskip();
    2339/    EC3B :                    ;*for (b = 0; b = 5; b++)
    2340/    EC3B :                    ;*   a=readbuff(); incbuff();
    2341/    EC3B :                    ;*   if (a = (cr,lf,^,/,wspace)) return(b);
    2342/    EC3B :                    ;*   combuff[b] = upcase(a);
    2343/    EC3B :                    ;*return(b);
    2344/    EC3B :
    2345/    EC3B : 86 20              PARSE   LDAA #$20
    2346/    EC3D : 97 91                      STAA COMBUFF+3
    2347/    EC3F : CE 00 6B                   LDX  #INBUFF         ;initialize buffer ptr
    2348/    EC42 : DF AE                      STX  PTR0
    2349/    EC44 : BD E2 FC                   JSR  WSKIP           ;find first character
    2350/    EC47 : 5F                         CLRB
    2351/    EC48 : BD E2 E7           PARSLP  JSR  READBUFF        ;read character
    2352/    EC4B : BD E2 EE                   JSR  INCBUFF
    2353/    EC4E : BD E3 0C                   JSR  WCHEK
    2354/    EC51 : 27 13                      BEQ  PARSRT          ;jump if whitespace
    2355/    EC53 : BD EC 67                   JSR  ASSCHEK
    2356/    EC56 : 27 0E                      BEQ  PARSRT          ;jump if end of line
    2357/    EC58 : BD E1 A7                   JSR  UPCASE          ;convert to upper case
    2358/    EC5B : CE 00 8E                   LDX  #COMBUFF
    2359/    EC5E : 3A                         ABX
    2360/    EC5F : A7 00                      STAA 0,X             ;store in combuff
    2361/    EC61 : 5C                         INCB
    2362/    EC62 : C1 05                      CMPB #$5
    2363/    EC64 : 2F E2                      BLE  PARSLP          ;loop 6 times
    2364/    EC66 : 39                 PARSRT  RTS
    2365/    EC67 :
    2366/    EC67 :
    2367/    EC67 :                    ;****************
    2368/    EC67 :                    ;*  asschek() -perform compares for
    2369/    EC67 :                    ;* lf, cr, ^, /, +, -, =
    2370/    EC67 :                    ;****************
    2371/    EC67 : 81 0A              ASSCHEK CMPA #$0A    ;linefeed
    2372/    EC69 : 27 16                      BEQ  ASSCHK1
    2373/    EC6B : 81 0D                      CMPA #$0D    ;carriage ret
    2374/    EC6D : 27 12                      BEQ  ASSCHK1
    2375/    EC6F : 81 5E                      CMPA #'^'    ;up arrow
    2376/    EC71 : 27 0E                      BEQ  ASSCHK1
    2377/    EC73 : 81 2F                      CMPA #'/'    ;slash
    2378/    EC75 : 27 0A                      BEQ  ASSCHK1
    2379/    EC77 : 81 2B                      CMPA #'+'    ;plus
    2380/    EC79 : 27 06                      BEQ  ASSCHK1
    2381/    EC7B : 81 2D                      CMPA #'-'    ;minus
    2382/    EC7D : 27 02                      BEQ  ASSCHK1
    2383/    EC7F : 81 3D                      CMPA #'='    ;equals
    2384/    EC81 : 39                 ASSCHK1 RTS
    2385/    EC82 :
    2386/    EC82 :
    2387/    EC82 :                    ;*********
    2388/    EC82 :                    ;*  msrch() --- Search MNETABL for mnemonic in COMBUFF.
    2389/    EC82 :                    ;*stores base opcode at baseop and class at class.
    2390/    EC82 :                    ;*  Class = FF if not found.
    2391/    EC82 :                    ;**********
    2392/    EC82 :                    ;*while ( != EOF )
    2393/    EC82 :                    ;*   if (COMBUFF[0-3] = MNETABL[0-3])
    2394/    EC82 :                    ;*      return(MNETABL[4],MNETABL[5]);
    2395/    EC82 :                    ;*   else *MNETABL =+ 6
    2396/    EC82 :
    2397/    EC82 : CE EF E4           MSRCH   LDX  #MNETABL        ;pointer to mnemonic table
    2398/    EC85 : 18 CE 00 8E                LDY  #COMBUFF        ;pointer to string
    2399/    EC89 : 20 03                      BRA  MSRCH1
    2400/    EC8B : =EC8B              MSNEXT  EQU  *
    2401/    EC8B : C6 06                      LDAB #6
    2402/    EC8D : 3A                         ABX                  ;point to next table entry
    2403/    EC8E : A6 00              MSRCH1  LDAA 0,X             ;read table
    2404/    EC90 : 81 04                      CMPA #EOT
    2405/    EC92 : 26 05                      BNE  MSRCH2          ;jump if not end of table
    2406/    EC94 : 86 FF                      LDAA #$FF
    2407/    EC96 : 97 B5                      STAA CLASS           ;FF = not in table
    2408/    EC98 : 39                         RTS
    2409/    EC99 : 18 A1 00           MSRCH2  CMPA 0,Y             ;op[0] = tabl[0] ?
    2410/    EC9C : 26 ED                      BNE  MSNEXT
    2411/    EC9E : A6 01                      LDAA 1,X
    2412/    ECA0 : 18 A1 01                   CMPA 1,Y             ;op[1] = tabl[1] ?
    2413/    ECA3 : 26 E6                      BNE  MSNEXT
    2414/    ECA5 : A6 02                      LDAA 2,X
    2415/    ECA7 : 18 A1 02                   CMPA 2,Y             ;op[2] = tabl[2] ?
    2416/    ECAA : 26 DF                      BNE  MSNEXT
    2417/    ECAC : A6 03                      LDAA 3,X
    2418/    ECAE : 18 A1 03                   CMPA 3,Y             ;op[2] = tabl[2] ?
    2419/    ECB1 : 26 D8                      BNE  MSNEXT
    2420/    ECB3 : EC 04                      LDD  4,X             ;opcode, class
    2421/    ECB5 : 97 B4                      STAA BASEOP
    2422/    ECB7 : D7 B5                      STAB CLASS
    2423/    ECB9 : 39                         RTS
    2424/    ECBA :
    2425/    ECBA :                    ;**********
    2426/    ECBA :                    ;**   doop(baseop,class) --- process mnemonic.
    2427/    ECBA :                    ;**   on exit: a=error code corresponding to error
    2428/    ECBA :                    ;**                                     messages.
    2429/    ECBA :                    ;**********
    2430/    ECBA :                    ;*amode = OTHER; /* addressing mode */
    2431/    ECBA :                    ;*yflag = 0;     /* ynoimm, nlimm, and cpd flag */
    2432/    ECBA :                    ;*x[] = ptrbuff[]
    2433/    ECBA :
    2434/    ECBA : =ECBA              DOOP    EQU  *
    2435/    ECBA : 86 04                      LDAA #OTHER
    2436/    ECBC : 97 C1                      STAA AMODE   ;mode
    2437/    ECBE : 7F 00 C2                   CLR  YFLAG
    2438/    ECC1 : DE AE                      LDX  PTR0
    2439/    ECC3 :
    2440/    ECC3 :                    ;*while (*x != end of buffer)
    2441/    ECC3 :                    ;*   if (x[0]++ == ',')
    2442/    ECC3 :                    ;*      if (x[0] == 'y') amode = INDY;
    2443/    ECC3 :                    ;*      else amod = INDX;
    2444/    ECC3 :                    ;*      break;
    2445/    ECC3 :                    ;*a = wskip()
    2446/    ECC3 :                    ;*if( a == '#' ) amode = IMMED;
    2447/    ECC3 :
    2448/    ECC3 : 8C 00 8E           DOPLP1  CPX  #ENDBUFF ;(end of buffer)
    2449/    ECC6 : 27 1B                      BEQ  DOOP1   ;jump if end of buffer
    2450/    ECC8 : EC 00                      LDD  0,X     ;read 2 chars from buffer
    2451/    ECCA : 08                         INX          ;move pointer
    2452/    ECCB : 81 2C                      CMPA #','
    2453/    ECCD : 26 F4                      BNE  DOPLP1
    2454/    ECCF : C1 59                      CMPB #'Y'    ;look for ",y"
    2455/    ECD1 : 26 06                      BNE  DOPLP2
    2456/    ECD3 : 86 02                      LDAA #INDY
    2457/    ECD5 : 97 C1                      STAA AMODE
    2458/    ECD7 : 20 0A                      BRA  DOOP1
    2459/    ECD9 : C1 58              DOPLP2  CMPB #'X'    ;look for ",x"
    2460/    ECDB : 26 06                      BNE  DOOP1   ;jump if not x
    2461/    ECDD : 86 01                      LDAA #INDX
    2462/    ECDF : 97 C1                      STAA AMODE
    2463/    ECE1 : 20 00                      BRA  DOOP1
    2464/    ECE3 : BD E2 FC           DOOP1   JSR  WSKIP
    2465/    ECE6 : 81 23                      CMPA #'#'    ;look for immediate mode
    2466/    ECE8 : 26 07                      BNE  DOOP2
    2467/    ECEA : BD E2 EE                   JSR  INCBUFF ;point at argument
    2468/    ECED : 86 00                      LDAA #IMMED
    2469/    ECEF : 97 C1                      STAA AMODE
    2470/    ECF1 : =ECF1              DOOP2   EQU  *
    2471/    ECF1 :
    2472/    ECF1 :                    ;*switch(class)
    2473/    ECF1 : D6 B5                      LDAB CLASS
    2474/    ECF3 : C1 02                      CMPB #P2INH
    2475/    ECF5 : 26 03                      BNE  DOSW1
    2476/    ECF7 : 7E ED 58                   JMP  DOP2I
    2477/    ECFA : C1 01              DOSW1   CMPB #INH
    2478/    ECFC : 26 03                      BNE  DOSW2
    2479/    ECFE : 7E ED 5D                   JMP  DOINH
    2480/    ED01 : C1 05              DOSW2   CMPB #REL
    2481/    ED03 : 26 03                      BNE  DOSW3
    2482/    ED05 : 7E ED 64                   JMP  DOREL
    2483/    ED08 : C1 08              DOSW3   CMPB #LIMM
    2484/    ED0A : 26 03                      BNE  DOSW4
    2485/    ED0C : 7E ED 93                   JMP  DOLIM
    2486/    ED0F : C1 07              DOSW4   CMPB #NIMM
    2487/    ED11 : 26 03                      BNE  DOSW5
    2488/    ED13 : 7E ED 9D                   JMP  DONOI
    2489/    ED16 : C1 03              DOSW5   CMPB #GEN
    2490/    ED18 : 26 03                      BNE  DOSW6
    2491/    ED1A : 7E ED A6                   JMP  DOGENE
    2492/    ED1D : C1 04              DOSW6   CMPB #GRP2
    2493/    ED1F : 26 03                      BNE  DOSW7
    2494/    ED21 : 7E ED B4                   JMP  DOGRP
    2495/    ED24 : C1 15              DOSW7   CMPB #CPD
    2496/    ED26 : 26 03                      BNE  DOSW8
    2497/    ED28 : 7E ED E6                   JMP  DOCPD
    2498/    ED2B : C1 10              DOSW8   CMPB #XNIMM
    2499/    ED2D : 26 03                      BNE  DOSW9
    2500/    ED2F : 7E EE 07                   JMP  DOXNOI
    2501/    ED32 : C1 09              DOSW9   CMPB #XLIMM
    2502/    ED34 : 26 03                      BNE  DOSW10
    2503/    ED36 : 7E EE 10                   JMP  DOXLI
    2504/    ED39 : C1 12              DOSW10  CMPB #YNIMM
    2505/    ED3B : 26 03                      BNE  DOSW11
    2506/    ED3D : 7E EE 28                   JMP  DOYNOI
    2507/    ED40 : C1 11              DOSW11  CMPB #YLIMM
    2508/    ED42 : 26 03                      BNE  DOSW12
    2509/    ED44 : 7E EE 31                   JMP  DOYLI
    2510/    ED47 : C1 13              DOSW12  CMPB #BTB
    2511/    ED49 : 26 03                      BNE  DOSW13
    2512/    ED4B : 7E EE 50                   JMP  DOBTB
    2513/    ED4E : C1 14              DOSW13  CMPB #SETCLR
    2514/    ED50 : 26 03                      BNE  DODEF
    2515/    ED52 : 7E EE 50                   JMP  DOSET
    2516/    ED55 :
    2517/    ED55 :                    ;*   default: return("error in mnemonic table");
    2518/    ED55 :
    2519/    ED55 : 86 02              DODEF   LDAA #$2
    2520/    ED57 : 39                         RTS
    2521/    ED58 :
    2522/    ED58 :                    ;*  case P2INH: emit(PAGE2)
    2523/    ED58 :
    2524/    ED58 : 86 18              DOP2I   LDAA #PAGE2
    2525/    ED5A : BD EF D9                   JSR  EMIT
    2526/    ED5D :
    2527/    ED5D :                    ;*  case INH: emit(baseop);
    2528/    ED5D :                    ;*       return(0);
    2529/    ED5D :
    2530/    ED5D : 96 B4              DOINH   LDAA BASEOP
    2531/    ED5F : BD EF D9                   JSR  EMIT
    2532/    ED62 : 4F                         CLRA
    2533/    ED63 : 39                         RTS
    2534/    ED64 :
    2535/    ED64 :                    ;*  case REL: a = assarg();
    2536/    ED64 :                    ;*            if(a=4) return(a);
    2537/    ED64 :                    ;*            d = address - pc + 2;
    2538/    ED64 :                    ;*            if ($7f >= d >= $ff82)
    2539/    ED64 :                    ;*               return (out of range);
    2540/    ED64 :                    ;*            emit(opcode);
    2541/    ED64 :                    ;*            emit(offset);
    2542/    ED64 :                    ;*            return(0);
    2543/    ED64 :
    2544/    ED64 : BD EF BB           DOREL   JSR  ASSARG
    2545/    ED67 : 81 04                      CMPA #$04
    2546/    ED69 : 26 01                      BNE  DOREL1  ;jump if arg ok
    2547/    ED6B : 39                         RTS
    2548/    ED6C : DC 96              DOREL1  LDD  SHFTREG ;get branch address
    2549/    ED6E : DE B0                      LDX  PC      ;get program counter
    2550/    ED70 : 08                         INX
    2551/    ED71 : 08                         INX          ;point to end of opcode
    2552/    ED72 : DF B8                      STX  BRADDR
    2553/    ED74 : 93 B8                      SUBD BRADDR  ;calculate offset
    2554/    ED76 : DD B8                      STD  BRADDR  ;save result
    2555/    ED78 : 1A 83 00 7F                CPD #$7F    ;in range ?
    2556/    ED7C : 23 09                      BLS  DOREL2  ;jump if in range
    2557/    ED7E : 1A 83 FF 80                CPD #$FF80
    2558/    ED82 : 24 03                      BHS  DOREL2  ;jump if in range
    2559/    ED84 : 86 09                      LDAA #$09    ;'Out of range'
    2560/    ED86 : 39                         RTS
    2561/    ED87 : 96 B4              DOREL2  LDAA BASEOP
    2562/    ED89 : BD EF D9                   JSR  EMIT    ;emit opcode
    2563/    ED8C : 96 B9                      LDAA BRADDR+1
    2564/    ED8E : BD EF D9                   JSR  EMIT    ;emit offset
    2565/    ED91 : 4F                         CLRA         ;normal return
    2566/    ED92 : 39                         RTS
    2567/    ED93 :
    2568/    ED93 :                    ;*  case LIMM: if (amode == IMMED) amode = LIMMED;
    2569/    ED93 :
    2570/    ED93 : 96 C1              DOLIM   LDAA AMODE
    2571/    ED95 : 81 00                      CMPA #IMMED
    2572/    ED97 : 26 04                      BNE  DONOI
    2573/    ED99 : 86 03                      LDAA #LIMMED
    2574/    ED9B : 97 C1                      STAA AMODE
    2575/    ED9D :
    2576/    ED9D :                    ;*  case NIMM: if (amode == IMMED)
    2577/    ED9D :                    ;*                return("Immediate mode illegal");
    2578/    ED9D :
    2579/    ED9D : 96 C1              DONOI   LDAA AMODE
    2580/    ED9F : 81 00                      CMPA #IMMED
    2581/    EDA1 : 26 03                      BNE  DOGENE  ;jump if not immediate
    2582/    EDA3 : 86 01                      LDAA #$1     ;"immediate mode illegal"
    2583/    EDA5 : 39                         RTS
    2584/    EDA6 :
    2585/    EDA6 :                    ;*  case GEN: dogen(baseop,amode,PAGE1,PAGE1,PAGE2);
    2586/    EDA6 :                    ;*            return;
    2587/    EDA6 :
    2588/    EDA6 : 86 00              DOGENE  LDAA #PAGE1
    2589/    EDA8 : 97 C3                      STAA PNORM
    2590/    EDAA : 97 B2                      STAA PX
    2591/    EDAC : 86 18                      LDAA #PAGE2
    2592/    EDAE : 97 B3                      STAA PY
    2593/    EDB0 : BD EE EC                   JSR  DOGEN
    2594/    EDB3 : 39                         RTS
    2595/    EDB4 :
    2596/    EDB4 :                    ;*  case GRP2: if (amode == INDY)
    2597/    EDB4 :                    ;*                emit(PAGE2);
    2598/    EDB4 :                    ;*                amode = INDX;
    2599/    EDB4 :                    ;*             if( amode == INDX )
    2600/    EDB4 :                    ;*                doindx(baseop);
    2601/    EDB4 :                    ;*             else a = assarg();
    2602/    EDB4 :                    ;*                if(a=4) return(a);
    2603/    EDB4 :                    ;*                emit(opcode+0x10);
    2604/    EDB4 :                    ;*                emit(extended address);
    2605/    EDB4 :                    ;*             return;
    2606/    EDB4 :
    2607/    EDB4 : 96 C1              DOGRP   LDAA AMODE
    2608/    EDB6 : 81 02                      CMPA #INDY
    2609/    EDB8 : 26 09                      BNE  DOGRP1
    2610/    EDBA : 86 18                      LDAA #PAGE2
    2611/    EDBC : BD EF D9                   JSR  EMIT
    2612/    EDBF : 86 01                      LDAA #INDX
    2613/    EDC1 : 97 C1                      STAA AMODE
    2614/    EDC3 : =EDC3              DOGRP1  EQU  *
    2615/    EDC3 : 96 C1                      LDAA AMODE
    2616/    EDC5 : 81 01                      CMPA #INDX
    2617/    EDC7 : 26 04                      BNE  DOGRP2
    2618/    EDC9 : BD EF 8C                   JSR  DOINDEX
    2619/    EDCC : 39                         RTS
    2620/    EDCD : =EDCD              DOGRP2  EQU  *
    2621/    EDCD : 96 B4                      LDAA BASEOP
    2622/    EDCF : 8B 10                      ADDA #$10
    2623/    EDD1 : BD EF D9                   JSR  EMIT
    2624/    EDD4 : BD EF BB                   JSR  ASSARG
    2625/    EDD7 : 81 04                      CMPA #$04
    2626/    EDD9 : 27 0A                      BEQ  DOGRPRT ;jump if bad arg
    2627/    EDDB : DC 96                      LDD  SHFTREG ;extended address
    2628/    EDDD : BD EF D9                   JSR  EMIT
    2629/    EDE0 : 17                         TBA
    2630/    EDE1 : BD EF D9                   JSR  EMIT
    2631/    EDE4 : 4F                         CLRA
    2632/    EDE5 : 39                 DOGRPRT RTS
    2633/    EDE6 :
    2634/    EDE6 :                    ;*  case CPD: if (amode == IMMED)
    2635/    EDE6 :                    ;*               amode = LIMMED; /* cpd */
    2636/    EDE6 :                    ;*            if( amode == INDY ) yflag = 1;
    2637/    EDE6 :                    ;*            dogen(baseop,amode,PAGE3,PAGE3,PAGE4);
    2638/    EDE6 :                    ;*            return;
    2639/    EDE6 :
    2640/    EDE6 : 96 C1              DOCPD   LDAA AMODE
    2641/    EDE8 : 81 00                      CMPA #IMMED
    2642/    EDEA : 26 04                      BNE  DOCPD1
    2643/    EDEC : 86 03                      LDAA #LIMMED
    2644/    EDEE : 97 C1                      STAA AMODE
    2645/    EDF0 : 96 C1              DOCPD1  LDAA AMODE
    2646/    EDF2 : 81 02                      CMPA #INDY
    2647/    EDF4 : 26 03                      BNE  DOCPD2
    2648/    EDF6 : 7C 00 C2                   INC  YFLAG
    2649/    EDF9 : 86 1A              DOCPD2  LDAA #PAGE3
    2650/    EDFB : 97 C3                      STAA PNORM
    2651/    EDFD : 97 B2                      STAA PX
    2652/    EDFF : 86 CD                      LDAA #PAGE4
    2653/    EE01 : 97 B3                      STAA PY
    2654/    EE03 : BD EE EC                   JSR  DOGEN
    2655/    EE06 : 39                         RTS
    2656/    EE07 :
    2657/    EE07 :                    ;*  case XNIMM: if (amode == IMMED)      /* stx */
    2658/    EE07 :                    ;*                 return("Immediate mode illegal");
    2659/    EE07 :
    2660/    EE07 : 96 C1              DOXNOI  LDAA AMODE
    2661/    EE09 : 81 00                      CMPA #IMMED
    2662/    EE0B : 26 03                      BNE  DOXLI
    2663/    EE0D : 86 01                      LDAA #$1     ;"immediate mode illegal"
    2664/    EE0F : 39                         RTS
    2665/    EE10 :
    2666/    EE10 :                    ;*  case XLIMM: if (amode == IMMED)  /* cpx, ldx */
    2667/    EE10 :                    ;*                 amode = LIMMED;
    2668/    EE10 :                    ;*              dogen(baseop,amode,PAGE1,PAGE1,PAGE4);
    2669/    EE10 :                    ;*              return;
    2670/    EE10 :
    2671/    EE10 : 96 C1              DOXLI   LDAA AMODE
    2672/    EE12 : 81 00                      CMPA #IMMED
    2673/    EE14 : 26 04                      BNE  DOXLI1
    2674/    EE16 : 86 03                      LDAA #LIMMED
    2675/    EE18 : 97 C1                      STAA AMODE
    2676/    EE1A : 86 00              DOXLI1  LDAA #PAGE1
    2677/    EE1C : 97 C3                      STAA PNORM
    2678/    EE1E : 97 B2                      STAA PX
    2679/    EE20 : 86 CD                      LDAA #PAGE4
    2680/    EE22 : 97 B3                      STAA PY
    2681/    EE24 : BD EE EC                   JSR  DOGEN
    2682/    EE27 : 39                         RTS
    2683/    EE28 :
    2684/    EE28 :                    ;*  case YNIMM: if (amode == IMMED)      /* sty */
    2685/    EE28 :                    ;*                 return("Immediate mode illegal");
    2686/    EE28 :
    2687/    EE28 : 96 C1              DOYNOI  LDAA AMODE
    2688/    EE2A : 81 00                      CMPA #IMMED
    2689/    EE2C : 26 03                      BNE  DOYLI
    2690/    EE2E : 86 01                      LDAA #$1     ;"immediate mode illegal"
    2691/    EE30 : 39                         RTS
    2692/    EE31 :
    2693/    EE31 :                    ;*  case YLIMM: if (amode == INDY) yflag = 1;/* cpy, ldy */
    2694/    EE31 :                    ;*              if(amode == IMMED) amode = LIMMED;
    2695/    EE31 :                    ;*              dogen(opcode,amode,PAGE2,PAGE3,PAGE2);
    2696/    EE31 :                    ;*              return;
    2697/    EE31 :
    2698/    EE31 : 96 C1              DOYLI   LDAA AMODE
    2699/    EE33 : 81 02                      CMPA #INDY
    2700/    EE35 : 26 03                      BNE  DOYLI1
    2701/    EE37 : 7C 00 C2                   INC  YFLAG
    2702/    EE3A : 81 00              DOYLI1  CMPA #IMMED
    2703/    EE3C : 26 04                      BNE  DOYLI2
    2704/    EE3E : 86 03                      LDAA #LIMMED
    2705/    EE40 : 97 C1                      STAA AMODE
    2706/    EE42 : 86 18              DOYLI2  LDAA #PAGE2
    2707/    EE44 : 97 C3                      STAA PNORM
    2708/    EE46 : 97 B3                      STAA PY
    2709/    EE48 : 86 1A                      LDAA #PAGE3
    2710/    EE4A : 97 B2                      STAA PX
    2711/    EE4C : BD EE EC                   JSR  DOGEN
    2712/    EE4F : 39                         RTS
    2713/    EE50 :
    2714/    EE50 :                    ;*  case BTB:        /* bset, bclr */
    2715/    EE50 :                    ;*  case SETCLR: a = bitop(baseop,amode,class);
    2716/    EE50 :                    ;*               if(a=0) return(a = 3);
    2717/    EE50 :                    ;*               if( amode == INDY )
    2718/    EE50 :                    ;*                  emit(PAGE2);
    2719/    EE50 :                    ;*                  amode = INDX;
    2720/    EE50 :
    2721/    EE50 : =EE50              DOBTB   EQU  *
    2722/    EE50 : BD EE C6           DOSET   JSR  BITOP
    2723/    EE53 : 81 00                      CMPA #$00
    2724/    EE55 : 26 03                      BNE  DOSET1
    2725/    EE57 : 86 03                      LDAA #$3     ;"illegal bit op"
    2726/    EE59 : 39                         RTS
    2727/    EE5A : 96 C1              DOSET1  LDAA AMODE
    2728/    EE5C : 81 02                      CMPA #INDY
    2729/    EE5E : 26 09                      BNE  DOSET2
    2730/    EE60 : 86 18                      LDAA #PAGE2
    2731/    EE62 : BD EF D9                   JSR  EMIT
    2732/    EE65 : 86 01                      LDAA #INDX
    2733/    EE67 : 97 C1                      STAA AMODE
    2734/    EE69 : =EE69              DOSET2  EQU  *
    2735/    EE69 :
    2736/    EE69 :                    ;*               emit(baseop);
    2737/    EE69 :                    ;*               a = assarg();
    2738/    EE69 :                    ;*               if(a = 4) return(a);
    2739/    EE69 :                    ;*               emit(index offset);
    2740/    EE69 :                    ;*               if( amode == INDX )
    2741/    EE69 :                    ;*                  Buffptr += 2;      /* skip ,x or ,y */
    2742/    EE69 :
    2743/    EE69 : 96 B4                      LDAA BASEOP
    2744/    EE6B : BD EF D9                   JSR  EMIT
    2745/    EE6E : BD EF BB                   JSR  ASSARG
    2746/    EE71 : 81 04                      CMPA #$04
    2747/    EE73 : 26 01                      BNE  DOSET22    ;     jump if arg ok
    2748/    EE75 : 39                         RTS
    2749/    EE76 : 96 97              DOSET22 LDAA SHFTREG+1   ;    index offset
    2750/    EE78 : BD EF D9                   JSR  EMIT
    2751/    EE7B : 96 C1                      LDAA AMODE
    2752/    EE7D : 81 01                      CMPA #INDX
    2753/    EE7F : 26 06                      BNE  DOSET3
    2754/    EE81 : BD E2 EE                   JSR  INCBUFF
    2755/    EE84 : BD E2 EE                   JSR  INCBUFF
    2756/    EE87 : =EE87              DOSET3  EQU  *
    2757/    EE87 :
    2758/    EE87 :                    ;*               a = assarg();
    2759/    EE87 :                    ;*               if(a = 4) return(a);
    2760/    EE87 :                    ;*               emit(mask);   /* mask */
    2761/    EE87 :                    ;*               if( class == SETCLR )
    2762/    EE87 :                    ;*                  return;
    2763/    EE87 :
    2764/    EE87 : BD EF BB                   JSR  ASSARG
    2765/    EE8A : 81 04                      CMPA #$04
    2766/    EE8C : 26 01                      BNE  DOSET33     ;    jump if arg ok
    2767/    EE8E : 39                         RTS
    2768/    EE8F : 96 97              DOSET33 LDAA SHFTREG+1    ;   mask
    2769/    EE91 : BD EF D9                   JSR  EMIT
    2770/    EE94 : 96 B5                      LDAA CLASS
    2771/    EE96 : 81 14                      CMPA #SETCLR
    2772/    EE98 : 26 02                      BNE  DOSET4
    2773/    EE9A : 4F                         CLRA
    2774/    EE9B : 39                         RTS
    2775/    EE9C : =EE9C              DOSET4  EQU  *
    2776/    EE9C :
    2777/    EE9C :                    ;*               a = assarg();
    2778/    EE9C :                    ;*               if(a = 4) return(a);
    2779/    EE9C :                    ;*               d = (pc+1) - shftreg;
    2780/    EE9C :                    ;*               if ($7f >= d >= $ff82)
    2781/    EE9C :                    ;*                  return (out of range);
    2782/    EE9C :                    ;*               emit(branch offset);
    2783/    EE9C :                    ;*               return(0);
    2784/    EE9C :
    2785/    EE9C : BD EF BB                   JSR  ASSARG
    2786/    EE9F : 81 04                      CMPA #$04
    2787/    EEA1 : 26 01                      BNE  DOSET5        ;  jump if arg ok
    2788/    EEA3 : 39                         RTS
    2789/    EEA4 : DE B0              DOSET5  LDX  PC             ; program counter
    2790/    EEA6 : 08                         INX                  ;point to next inst
    2791/    EEA7 : DF B8                      STX  BRADDR          ;save pc value
    2792/    EEA9 : DC 96                      LDD  SHFTREG         ;get branch address
    2793/    EEAB : 93 B8                      SUBD BRADDR          ;calculate offset
    2794/    EEAD : 1A 83 00 7F                CPD #$7F
    2795/    EEB1 : 23 0D                      BLS  DOSET6          ;jump if in range
    2796/    EEB3 : 1A 83 FF 80                CPD #$FF80
    2797/    EEB7 : 24 07                      BHS  DOSET6          ;jump if in range
    2798/    EEB9 : 4F                         CLRA
    2799/    EEBA : BD EF D9                   JSR  EMIT
    2800/    EEBD : 86 09                      LDAA #$09            ;'out of range'
    2801/    EEBF : 39                         RTS
    2802/    EEC0 : 17                 DOSET6  TBA                  ;offset
    2803/    EEC1 : BD EF D9                   JSR  EMIT
    2804/    EEC4 : 4F                         CLRA
    2805/    EEC5 : 39                         RTS
    2806/    EEC6 :
    2807/    EEC6 :
    2808/    EEC6 :                    ;**********
    2809/    EEC6 :                    ;**   bitop(baseop,amode,class) --- adjust opcode on bit
    2810/    EEC6 :                    ;**       manipulation instructions.  Returns opcode in a
    2811/    EEC6 :                    ;**       or a = 0 if error
    2812/    EEC6 :                    ;**********
    2813/    EEC6 :                    ;*if( amode == INDX || amode == INDY ) return(op);
    2814/    EEC6 :                    ;*if( class == SETCLR ) return(op-8);
    2815/    EEC6 :                    ;*else if(class==BTB) return(op-12);
    2816/    EEC6 :                    ;*else fatal("bitop");
    2817/    EEC6 :
    2818/    EEC6 : =EEC6              BITOP   EQU  *
    2819/    EEC6 : 96 C1                      LDAA AMODE
    2820/    EEC8 : D6 B5                      LDAB CLASS
    2821/    EECA : 81 01                      CMPA #INDX
    2822/    EECC : 26 01                      BNE  BITOP1
    2823/    EECE : 39                         RTS
    2824/    EECF : 81 02              BITOP1  CMPA #INDY
    2825/    EED1 : 26 01                      BNE  BITOP2  ;jump not indexed
    2826/    EED3 : 39                         RTS
    2827/    EED4 : C1 14              BITOP2  CMPB #SETCLR
    2828/    EED6 : 26 07                      BNE  BITOP3  ;jump not bset,bclr
    2829/    EED8 : 96 B4                      LDAA BASEOP  ;get opcode
    2830/    EEDA : 80 08                      SUBA #8
    2831/    EEDC : 97 B4                      STAA BASEOP
    2832/    EEDE : 39                         RTS
    2833/    EEDF : C1 13              BITOP3  CMPB #BTB
    2834/    EEE1 : 26 07                      BNE  BITOP4  ;jump not bit branch
    2835/    EEE3 : 96 B4                      LDAA BASEOP  ;get opcode
    2836/    EEE5 : 80 0C                      SUBA #12
    2837/    EEE7 : 97 B4                      STAA BASEOP
    2838/    EEE9 : 39                         RTS
    2839/    EEEA : 4F                 BITOP4  CLRA         ;0 = fatal bitop
    2840/    EEEB : 39                         RTS
    2841/    EEEC :
    2842/    EEEC :                    ;**********
    2843/    EEEC :                    ;**   dogen(baseop,mode,pnorm,px,py) - process
    2844/    EEEC :                    ;** general addressing modes. Returns a = error #.
    2845/    EEEC :                    ;**********
    2846/    EEEC :                    ;*pnorm = page for normal addressing modes: IMM,DIR,EXT
    2847/    EEEC :                    ;*px = page for INDX addressing
    2848/    EEEC :                    ;*py = page for INDY addressing
    2849/    EEEC :                    ;*switch(amode)
    2850/    EEEC : 96 C1              DOGEN   LDAA AMODE
    2851/    EEEE : 81 03                      CMPA #LIMMED
    2852/    EEF0 : 27 13                      BEQ  DOGLIM
    2853/    EEF2 : 81 00                      CMPA #IMMED
    2854/    EEF4 : 27 2C                      BEQ  DOGIMM
    2855/    EEF6 : 81 02                      CMPA #INDY
    2856/    EEF8 : 27 41                      BEQ  DOGINDY
    2857/    EEFA : 81 01                      CMPA #INDX
    2858/    EEFC : 27 4C                      BEQ  DOGINDX
    2859/    EEFE : 81 04                      CMPA #OTHER
    2860/    EF00 : 27 57                      BEQ  DOGOTH
    2861/    EF02 :
    2862/    EF02 :                    ;*default: error("Unknown Addressing Mode");
    2863/    EF02 :
    2864/    EF02 : 86 06              DOGDEF  LDAA #$06     ;   unknown addre...
    2865/    EF04 : 39                         RTS
    2866/    EF05 :
    2867/    EF05 :                    ;*case LIMMED: epage(pnorm);
    2868/    EF05 :                    ;*             emit(baseop);
    2869/    EF05 :                    ;*             a = assarg();
    2870/    EF05 :                    ;*             if(a = 4) return(a);
    2871/    EF05 :                    ;*             emit(2 bytes);
    2872/    EF05 :                    ;*             return(0);
    2873/    EF05 :
    2874/    EF05 : 96 C3              DOGLIM  LDAA PNORM
    2875/    EF07 : BD EF D1                   JSR  EPAGE
    2876/    EF0A : 96 B4              DOGLIM1 LDAA BASEOP
    2877/    EF0C : BD EF D9                   JSR  EMIT
    2878/    EF0F : BD EF BB                   JSR  ASSARG   ;get next argument
    2879/    EF12 : 81 04                      CMPA #$04
    2880/    EF14 : 26 01                      BNE  DOGLIM2   ;jump if arg ok
    2881/    EF16 : 39                         RTS
    2882/    EF17 : DC 96              DOGLIM2 LDD  SHFTREG
    2883/    EF19 : BD EF D9                   JSR  EMIT
    2884/    EF1C : 17                         TBA
    2885/    EF1D : BD EF D9                   JSR  EMIT
    2886/    EF20 : 4F                         CLRA
    2887/    EF21 : 39                         RTS
    2888/    EF22 :
    2889/    EF22 :                    ;*case IMMED: epage(pnorm);
    2890/    EF22 :                    ;*            emit(baseop);
    2891/    EF22 :                    ;*            a = assarg();
    2892/    EF22 :                    ;*            if(a = 4) return(a);
    2893/    EF22 :                    ;*            emit(lobyte);
    2894/    EF22 :                    ;*            return(0);
    2895/    EF22 :
    2896/    EF22 : 96 C3              DOGIMM  LDAA PNORM
    2897/    EF24 : BD EF D1                   JSR  EPAGE
    2898/    EF27 : 96 B4                      LDAA BASEOP
    2899/    EF29 : BD EF D9                   JSR  EMIT
    2900/    EF2C : BD EF BB                   JSR  ASSARG
    2901/    EF2F : 81 04                      CMPA #$04
    2902/    EF31 : 26 01                      BNE  DOGIMM1   ;jump if arg ok
    2903/    EF33 : 39                         RTS
    2904/    EF34 : 96 97              DOGIMM1 LDAA SHFTREG+1
    2905/    EF36 : BD EF D9                   JSR  EMIT
    2906/    EF39 : 4F                         CLRA
    2907/    EF3A : 39                         RTS
    2908/    EF3B :
    2909/    EF3B :                    ;*case INDY: epage(py);
    2910/    EF3B :                    ;*           a=doindex(op+0x20);
    2911/    EF3B :                    ;*           return(a);
    2912/    EF3B :
    2913/    EF3B : 96 B3              DOGINDY LDAA PY
    2914/    EF3D : BD EF D1                   JSR  EPAGE
    2915/    EF40 : 96 B4                      LDAA BASEOP
    2916/    EF42 : 8B 20                      ADDA #$20
    2917/    EF44 : 97 B4                      STAA BASEOP
    2918/    EF46 : BD EF 8C                   JSR  DOINDEX
    2919/    EF49 : 39                         RTS
    2920/    EF4A :
    2921/    EF4A :                    ;*case INDX: epage(px);
    2922/    EF4A :                    ;*           a=doindex(op+0x20);
    2923/    EF4A :                    ;*           return(a);
    2924/    EF4A :
    2925/    EF4A : 96 B2              DOGINDX LDAA PX
    2926/    EF4C : BD EF D1                   JSR  EPAGE
    2927/    EF4F : 96 B4                      LDAA BASEOP
    2928/    EF51 : 8B 20                      ADDA #$20
    2929/    EF53 : 97 B4                      STAA BASEOP
    2930/    EF55 : BD EF 8C                   JSR  DOINDEX
    2931/    EF58 : 39                         RTS
    2932/    EF59 :
    2933/    EF59 :                    ;*case OTHER: a = assarg();
    2934/    EF59 :                    ;*            if(a = 4) return(a);
    2935/    EF59 :                    ;*            epage(pnorm);
    2936/    EF59 :                    ;*            if(countu1 <= 2 digits)   /* direct */
    2937/    EF59 :                    ;*               emit(op+0x10);
    2938/    EF59 :                    ;*               emit(lobyte(Result));
    2939/    EF59 :                    ;*               return(0);
    2940/    EF59 :                    ;*            else    emit(op+0x30);    /* extended */
    2941/    EF59 :                    ;*               eword(Result);
    2942/    EF59 :                    ;*               return(0)
    2943/    EF59 :
    2944/    EF59 : BD EF BB           DOGOTH  JSR  ASSARG
    2945/    EF5C : 81 04                      CMPA #$04
    2946/    EF5E : 26 01                      BNE  DOGOTH0  ;jump if arg ok
    2947/    EF60 : 39                         RTS
    2948/    EF61 : 96 C3              DOGOTH0 LDAA PNORM
    2949/    EF63 : BD EF D1                   JSR  EPAGE
    2950/    EF66 : 96 A8                      LDAA COUNT
    2951/    EF68 : 81 02                      CMPA #$2
    2952/    EF6A : 2E 0E                      BGT  DOGOTH1
    2953/    EF6C : 96 B4                      LDAA BASEOP
    2954/    EF6E : 8B 10                      ADDA #$10      ;      direct mode opcode
    2955/    EF70 : BD EF D9                   JSR  EMIT
    2956/    EF73 : 96 97                      LDAA SHFTREG+1
    2957/    EF75 : BD EF D9                   JSR  EMIT
    2958/    EF78 : 4F                         CLRA
    2959/    EF79 : 39                         RTS
    2960/    EF7A : 96 B4              DOGOTH1 LDAA BASEOP
    2961/    EF7C : 8B 30                      ADDA #$30       ;     extended mode opcode
    2962/    EF7E : BD EF D9                   JSR  EMIT
    2963/    EF81 : DC 96                      LDD  SHFTREG
    2964/    EF83 : BD EF D9                   JSR  EMIT
    2965/    EF86 : 17                         TBA
    2966/    EF87 : BD EF D9                   JSR  EMIT
    2967/    EF8A : 4F                         CLRA
    2968/    EF8B : 39                         RTS
    2969/    EF8C :
    2970/    EF8C :                    ;**********
    2971/    EF8C :                    ;**  doindex(op) --- handle all wierd stuff for
    2972/    EF8C :                    ;**   indexed addressing. Returns a = error number.
    2973/    EF8C :                    ;**********
    2974/    EF8C :                    ;*emit(baseop);
    2975/    EF8C :                    ;*a=assarg();
    2976/    EF8C :                    ;*if(a = 4) return(a);
    2977/    EF8C :                    ;*if( a != ',' ) return("Syntax");
    2978/    EF8C :                    ;*buffptr++
    2979/    EF8C :                    ;*a=readbuff()
    2980/    EF8C :                    ;*if( a != 'x' &&  != 'y') warn("Ind Addr Assumed");
    2981/    EF8C :                    ;*emit(lobyte);
    2982/    EF8C :                    ;*return(0);
    2983/    EF8C :
    2984/    EF8C : 96 B4              DOINDEX LDAA BASEOP
    2985/    EF8E : BD EF D9                   JSR  EMIT
    2986/    EF91 : BD EF BB                   JSR  ASSARG
    2987/    EF94 : 81 04                      CMPA #$04
    2988/    EF96 : 26 01                      BNE  DOINDX0    ; jump if arg ok
    2989/    EF98 : 39                         RTS
    2990/    EF99 : 81 2C              DOINDX0 CMPA #','
    2991/    EF9B : 27 03                      BEQ  DOINDX1
    2992/    EF9D : 86 08                      LDAA #$08        ;"syntax error"
    2993/    EF9F : 39                         RTS
    2994/    EFA0 : BD E2 EE           DOINDX1 JSR  INCBUFF
    2995/    EFA3 : BD E2 E7                   JSR  READBUFF
    2996/    EFA6 : 81 59                      CMPA #'Y'
    2997/    EFA8 : 27 0A                      BEQ  DOINDX2
    2998/    EFAA : 81 58                      CMPA #'X'
    2999/    EFAC : 27 06                      BEQ  DOINDX2
    3000/    EFAE : FE EA D5                   LDX  MSGA7       ;"index addr assumed"
    3001/    EFB1 : BD E5 05                   JSR  OUTSTRG
    3002/    EFB4 : 96 97              DOINDX2 LDAA SHFTREG+1
    3003/    EFB6 : BD EF D9                   JSR  EMIT
    3004/    EFB9 : 4F                         CLRA
    3005/    EFBA : 39                         RTS
    3006/    EFBB :
    3007/    EFBB :                    ;**********
    3008/    EFBB :                    ;**   assarg(); - get argument.  Returns a = 4 if bad
    3009/    EFBB :                    ;** argument, else a = first non hex char.
    3010/    EFBB :                    ;**********
    3011/    EFBB :                    ;*a = buffarg()
    3012/    EFBB :                    ;*if(asschk(aa) && countu1 != 0) return(a);
    3013/    EFBB :                    ;*return(bad argument);
    3014/    EFBB :
    3015/    EFBB : BD E2 34           ASSARG  JSR  BUFFARG
    3016/    EFBE : BD EC 67                   JSR  ASSCHEK   ;check for command
    3017/    EFC1 : 27 05                      BEQ  ASSARG1   ;jump if ok
    3018/    EFC3 : BD E3 0C                   JSR  WCHEK     ;check for whitespace
    3019/    EFC6 : 26 06                      BNE  ASSARG2   ;jump if not ok
    3020/    EFC8 : 7D 00 A8           ASSARG1 TST  COUNT
    3021/    EFCB : 27 01                      BEQ  ASSARG2   ;jump if no argument
    3022/    EFCD : 39                         RTS
    3023/    EFCE : 86 04              ASSARG2 LDAA #$04      ;bad argument
    3024/    EFD0 : 39                         RTS
    3025/    EFD1 :
    3026/    EFD1 :                    ;**********
    3027/    EFD1 :                    ;**  epage(a) --- emit page prebyte
    3028/    EFD1 :                    ;**********
    3029/    EFD1 :                    ;*if( a != PAGE1 ) emit(a);
    3030/    EFD1 :
    3031/    EFD1 : 81 00              EPAGE   CMPA #PAGE1
    3032/    EFD3 : 27 03                      BEQ  EPAGRT  ;jump if page 1
    3033/    EFD5 : BD EF D9                   JSR  EMIT
    3034/    EFD8 : 39                 EPAGRT  RTS
    3035/    EFD9 :
    3036/    EFD9 :                    ;**********
    3037/    EFD9 :                    ;*   emit(a) --- emit contents of a
    3038/    EFD9 :                    ;**********
    3039/    EFD9 : DE B0              EMIT    LDX  PC
    3040/    EFDB : BD E2 8A                   JSR  WRITE      ;write a to x
    3041/    EFDE : BD E4 EC                   JSR  OUT1BSP
    3042/    EFE1 : DF B0                      STX  PC
    3043/    EFE3 : 39                         RTS
    3044/    EFE4 :
    3045/    EFE4 :                    ;*Mnemonic table for hc11 line assembler
    3046/    EFE4 : =0                 NULL    EQU  $0      ;nothing
    3047/    EFE4 : =1                 INH     EQU  $1      ;inherent
    3048/    EFE4 : =2                 P2INH   EQU  $2      ;page 2 inherent
    3049/    EFE4 : =3                 GEN     EQU  $3      ;general addressing
    3050/    EFE4 : =4                 GRP2    EQU  $4      ;group 2
    3051/    EFE4 : =5                 REL     EQU  $5      ;relative
    3052/    EFE4 : =6                 IMM     EQU  $6      ;immediate
    3053/    EFE4 : =7                 NIMM    EQU  $7      ;general except for immediate
    3054/    EFE4 : =8                 LIMM    EQU  $8      ;2 byte immediate
    3055/    EFE4 : =9                 XLIMM   EQU  $9      ;longimm for x
    3056/    EFE4 : =10                XNIMM   EQU  $10     ;no immediate for x
    3057/    EFE4 : =11                YLIMM   EQU  $11     ;longimm for y
    3058/    EFE4 : =12                YNIMM   EQU  $12     ;no immediate for y
    3059/    EFE4 : =13                BTB     EQU  $13     ;bit test and branch
    3060/    EFE4 : =14                SETCLR  EQU  $14     ;bit set or clear
    3061/    EFE4 : =15                CPD     EQU  $15     ;compare d
    3062/    EFE4 : =16                BTBD    EQU  $16     ;bit test and branch direct
    3063/    EFE4 : =17                SETCLRD EQU  $17     ;bit set or clear direct
    3064/    EFE4 :
    3065/    EFE4 :                    ;**********
    3066/    EFE4 :                    ;*   mnetabl - includes all '11 mnemonics, base opcodes,
    3067/    EFE4 :                    ;* and type of instruction.  The assembler search routine
    3068/    EFE4 :                    ;*depends on 4 characters for each mnemonic so that 3 char
    3069/    EFE4 :                    ;*mnemonics are extended with a space and 5 char mnemonics
    3070/    EFE4 :                    ;*are truncated.
    3071/    EFE4 :                    ;**********
    3072/    EFE4 :
    3073/    EFE4 : =EFE4              MNETABL EQU  *
    3074/    EFE4 : 41 42 41 20                FCC  'ABA ' ;  Mnemonic
    3075/    EFE8 : 1B                         FCB  $1B     ;Base opcode
    3076/    EFE9 : 01                         FCB  INH     ;Class
    3077/    EFEA : 41 42 58 20                FCC  'ABX '
    3078/    EFEE : 3A                         FCB  $3A
    3079/    EFEF : 01                         FCB  INH
    3080/    EFF0 : 41 42 59 20                FCC  'ABY '
    3081/    EFF4 : 3A                         FCB  $3A
    3082/    EFF5 : 02                         FCB  P2INH
    3083/    EFF6 : 41 44 43 41                FCC  'ADCA'
    3084/    EFFA : 89                         FCB  $89
    3085/    EFFB : 03                         FCB  GEN
    3086/    EFFC : 41 44 43 42                FCC  'ADCB'
    3087/    F000 : C9                         FCB  $C9
    3088/    F001 : 03                         FCB  GEN
    3089/    F002 : 41 44 44 41                FCC  'ADDA'
    3090/    F006 : 8B                         FCB  $8B
    3091/    F007 : 03                         FCB  GEN
    3092/    F008 : 41 44 44 42                FCC  'ADDB'
    3093/    F00C : CB                         FCB  $CB
    3094/    F00D : 03                         FCB  GEN
    3095/    F00E : 41 44 44 44                FCC  'ADDD'
    3096/    F012 : C3                         FCB  $C3
    3097/    F013 : 08                         FCB  LIMM
    3098/    F014 : 41 4E 44 41                FCC  'ANDA'
    3099/    F018 : 84                         FCB  $84
    3100/    F019 : 03                         FCB  GEN
    3101/    F01A : 41 4E 44 42                FCC  'ANDB'
    3102/    F01E : C4                         FCB  $C4
    3103/    F01F : 03                         FCB  GEN
    3104/    F020 : 41 53 4C 20                FCC  'ASL '
    3105/    F024 : 68                         FCB  $68
    3106/    F025 : 04                         FCB  GRP2
    3107/    F026 : 41 53 4C 41                FCC  'ASLA'
    3108/    F02A : 48                         FCB  $48
    3109/    F02B : 01                         FCB  INH
    3110/    F02C : 41 53 4C 42                FCC  'ASLB'
    3111/    F030 : 58                         FCB  $58
    3112/    F031 : 01                         FCB  INH
    3113/    F032 : 41 53 4C 44                FCC  'ASLD'
    3114/    F036 : 05                         FCB  $05
    3115/    F037 : 01                         FCB  INH
    3116/    F038 : 41 53 52 20                FCC  'ASR '
    3117/    F03C : 67                         FCB  $67
    3118/    F03D : 04                         FCB  GRP2
    3119/    F03E : 41 53 52 41                FCC  'ASRA'
    3120/    F042 : 47                         FCB  $47
    3121/    F043 : 01                         FCB  INH
    3122/    F044 : 41 53 52 42                FCC  'ASRB'
    3123/    F048 : 57                         FCB  $57
    3124/    F049 : 01                         FCB  INH
    3125/    F04A : 42 43 43 20                FCC  'BCC '
    3126/    F04E : 24                         FCB  $24
    3127/    F04F : 05                         FCB  REL
    3128/    F050 : 42 43 4C 52                FCC  'BCLR'
    3129/    F054 : 1D                         FCB  $1D
    3130/    F055 : 14                         FCB  SETCLR
    3131/    F056 : 42 43 53 20                FCC  'BCS '
    3132/    F05A : 25                         FCB  $25
    3133/    F05B : 05                         FCB  REL
    3134/    F05C : 42 45 51 20                FCC  'BEQ '
    3135/    F060 : 27                         FCB  $27
    3136/    F061 : 05                         FCB  REL
    3137/    F062 : 42 47 45 20                FCC  'BGE '
    3138/    F066 : 2C                         FCB  $2C
    3139/    F067 : 05                         FCB  REL
    3140/    F068 : 42 47 54 20                FCC  'BGT '
    3141/    F06C : 2E                         FCB  $2E
    3142/    F06D : 05                         FCB  REL
    3143/    F06E : 42 48 49 20                FCC  'BHI '
    3144/    F072 : 22                         FCB  $22
    3145/    F073 : 05                         FCB  REL
    3146/    F074 : 42 48 53 20                FCC  'BHS '
    3147/    F078 : 24                         FCB  $24
    3148/    F079 : 05                         FCB  REL
    3149/    F07A : 42 49 54 41                FCC  'BITA'
    3150/    F07E : 85                         FCB  $85
    3151/    F07F : 03                         FCB  GEN
    3152/    F080 : 42 49 54 42                FCC  'BITB'
    3153/    F084 : C5                         FCB  $C5
    3154/    F085 : 03                         FCB  GEN
    3155/    F086 : 42 4C 45 20                FCC  'BLE '
    3156/    F08A : 2F                         FCB  $2F
    3157/    F08B : 05                         FCB  REL
    3158/    F08C : 42 4C 4F 20                FCC  'BLO '
    3159/    F090 : 25                         FCB  $25
    3160/    F091 : 05                         FCB  REL
    3161/    F092 : 42 4C 53 20                FCC  'BLS '
    3162/    F096 : 23                         FCB  $23
    3163/    F097 : 05                         FCB  REL
    3164/    F098 : 42 4C 54 20                FCC  'BLT '
    3165/    F09C : 2D                         FCB  $2D
    3166/    F09D : 05                         FCB  REL
    3167/    F09E : 42 4D 49 20                FCC  'BMI '
    3168/    F0A2 : 2B                         FCB  $2B
    3169/    F0A3 : 05                         FCB  REL
    3170/    F0A4 : 42 4E 45 20                FCC  'BNE '
    3171/    F0A8 : 26                         FCB  $26
    3172/    F0A9 : 05                         FCB  REL
    3173/    F0AA : 42 50 4C 20                FCC  'BPL '
    3174/    F0AE : 2A                         FCB  $2A
    3175/    F0AF : 05                         FCB  REL
    3176/    F0B0 : 42 52 41 20                FCC  'BRA '
    3177/    F0B4 : 20                         FCB  $20
    3178/    F0B5 : 05                         FCB  REL
    3179/    F0B6 : 42 52 43 4C                FCC  'BRCL'   ;    (BRCLR)
    3180/    F0BA : 1F                         FCB  $1F
    3181/    F0BB : 13                         FCB  BTB
    3182/    F0BC : 42 52 4E 20                FCC  'BRN '
    3183/    F0C0 : 21                         FCB  $21
    3184/    F0C1 : 05                         FCB  REL
    3185/    F0C2 : 42 52 53 45                FCC  'BRSE'    ;   (BRSET)
    3186/    F0C6 : 1E                         FCB  $1E
    3187/    F0C7 : 13                         FCB  BTB
    3188/    F0C8 : 42 53 45 54                FCC  'BSET'
    3189/    F0CC : 1C                         FCB  $1C
    3190/    F0CD : 14                         FCB  SETCLR
    3191/    F0CE : 42 53 52 20                FCC  'BSR '
    3192/    F0D2 : 8D                         FCB  $8D
    3193/    F0D3 : 05                         FCB  REL
    3194/    F0D4 : 42 56 43 20                FCC  'BVC '
    3195/    F0D8 : 28                         FCB  $28
    3196/    F0D9 : 05                         FCB  REL
    3197/    F0DA : 42 56 53 20                FCC  'BVS '
    3198/    F0DE : 29                         FCB  $29
    3199/    F0DF : 05                         FCB  REL
    3200/    F0E0 : 43 42 41 20                FCC  'CBA '
    3201/    F0E4 : 11                         FCB  $11
    3202/    F0E5 : 01                         FCB  INH
    3203/    F0E6 : 43 4C 43 20                FCC  'CLC '
    3204/    F0EA : 0C                         FCB  $0C
    3205/    F0EB : 01                         FCB  INH
    3206/    F0EC : 43 4C 49 20                FCC  'CLI '
    3207/    F0F0 : 0E                         FCB  $0E
    3208/    F0F1 : 01                         FCB  INH
    3209/    F0F2 : 43 4C 52 20                FCC  'CLR '
    3210/    F0F6 : 6F                         FCB  $6F
    3211/    F0F7 : 04                         FCB  GRP2
    3212/    F0F8 : 43 4C 52 41                FCC  'CLRA'
    3213/    F0FC : 4F                         FCB  $4F
    3214/    F0FD : 01                         FCB  INH
    3215/    F0FE : 43 4C 52 42                FCC  'CLRB'
    3216/    F102 : 5F                         FCB  $5F
    3217/    F103 : 01                         FCB  INH
    3218/    F104 : 43 4C 56 20                FCC  'CLV '
    3219/    F108 : 0A                         FCB  $0A
    3220/    F109 : 01                         FCB  INH
    3221/    F10A : 43 4D 50 41                FCC  'CMPA'
    3222/    F10E : 81                         FCB  $81
    3223/    F10F : 03                         FCB  GEN
    3224/    F110 : 43 4D 50 42                FCC  'CMPB'
    3225/    F114 : C1                         FCB  $C1
    3226/    F115 : 03                         FCB  GEN
    3227/    F116 : 43 4F 4D 20                FCC  'COM '
    3228/    F11A : 63                         FCB  $63
    3229/    F11B : 04                         FCB  GRP2
    3230/    F11C : 43 4F 4D 41                FCC  'COMA'
    3231/    F120 : 43                         FCB  $43
    3232/    F121 : 01                         FCB  INH
    3233/    F122 : 43 4F 4D 42                FCC  'COMB'
    3234/    F126 : 53                         FCB  $53
    3235/    F127 : 01                         FCB  INH
    3236/    F128 : 43 50 44 20                FCC  'CPD '
    3237/    F12C : 83                         FCB  $83
    3238/    F12D : 15                         FCB  CPD
    3239/    F12E : 43 50 58 20                FCC  'CPX '
    3240/    F132 : 8C                         FCB  $8C
    3241/    F133 : 09                         FCB  XLIMM
    3242/    F134 : 43 50 59 20                FCC  'CPY '
    3243/    F138 : 8C                         FCB  $8C
    3244/    F139 : 11                         FCB  YLIMM
    3245/    F13A : 44 41 41 20                FCC  'DAA '
    3246/    F13E : 19                         FCB  $19
    3247/    F13F : 01                         FCB  INH
    3248/    F140 : 44 45 43 20                FCC  'DEC '
    3249/    F144 : 6A                         FCB  $6A
    3250/    F145 : 04                         FCB  GRP2
    3251/    F146 : 44 45 43 41                FCC  'DECA'
    3252/    F14A : 4A                         FCB  $4A
    3253/    F14B : 01                         FCB  INH
    3254/    F14C : 44 45 43 42                FCC  'DECB'
    3255/    F150 : 5A                         FCB  $5A
    3256/    F151 : 01                         FCB  INH
    3257/    F152 : 44 45 53 20                FCC  'DES '
    3258/    F156 : 34                         FCB  $34
    3259/    F157 : 01                         FCB  INH
    3260/    F158 : 44 45 58 20                FCC  'DEX '
    3261/    F15C : 09                         FCB  $09
    3262/    F15D : 01                         FCB  INH
    3263/    F15E : 44 45 59 20                FCC  'DEY '
    3264/    F162 : 09                         FCB  $09
    3265/    F163 : 02                         FCB  P2INH
    3266/    F164 : 45 4F 52 41                FCC  'EORA'
    3267/    F168 : 88                         FCB  $88
    3268/    F169 : 03                         FCB  GEN
    3269/    F16A : 45 4F 52 42                FCC  'EORB'
    3270/    F16E : C8                         FCB  $C8
    3271/    F16F : 03                         FCB  GEN
    3272/    F170 : 46 44 49 56                FCC  'FDIV'
    3273/    F174 : 03                         FCB  $03
    3274/    F175 : 01                         FCB  INH
    3275/    F176 : 49 44 49 56                FCC  'IDIV'
    3276/    F17A : 02                         FCB  $02
    3277/    F17B : 01                         FCB  INH
    3278/    F17C : 49 4E 43 20                FCC  'INC '
    3279/    F180 : 6C                         FCB  $6C
    3280/    F181 : 04                         FCB  GRP2
    3281/    F182 : 49 4E 43 41                FCC  'INCA'
    3282/    F186 : 4C                         FCB  $4C
    3283/    F187 : 01                         FCB  INH
    3284/    F188 : 49 4E 43 42                FCC  'INCB'
    3285/    F18C : 5C                         FCB  $5C
    3286/    F18D : 01                         FCB  INH
    3287/    F18E : 49 4E 53 20                FCC  'INS '
    3288/    F192 : 31                         FCB  $31
    3289/    F193 : 01                         FCB  INH
    3290/    F194 : 49 4E 58 20                FCC  'INX '
    3291/    F198 : 08                         FCB  $08
    3292/    F199 : 01                         FCB  INH
    3293/    F19A : 49 4E 59 20                FCC  'INY '
    3294/    F19E : 08                         FCB  $08
    3295/    F19F : 02                         FCB  P2INH
    3296/    F1A0 : 4A 4D 50 20                FCC  'JMP '
    3297/    F1A4 : 6E                         FCB  $6E
    3298/    F1A5 : 04                         FCB  GRP2
    3299/    F1A6 : 4A 53 52 20                FCC  'JSR '
    3300/    F1AA : 8D                         FCB  $8D
    3301/    F1AB : 07                         FCB  NIMM
    3302/    F1AC : 4C 44 41 41                FCC  'LDAA'
    3303/    F1B0 : 86                         FCB  $86
    3304/    F1B1 : 03                         FCB  GEN
    3305/    F1B2 : 4C 44 41 42                FCC  'LDAB'
    3306/    F1B6 : C6                         FCB  $C6
    3307/    F1B7 : 03                         FCB  GEN
    3308/    F1B8 : 4C 44 44 20                FCC  'LDD '
    3309/    F1BC : CC                         FCB  $CC
    3310/    F1BD : 08                         FCB  LIMM
    3311/    F1BE : 4C 44 53 20                FCC  'LDS '
    3312/    F1C2 : 8E                         FCB  $8E
    3313/    F1C3 : 08                         FCB  LIMM
    3314/    F1C4 : 4C 44 58 20                FCC  'LDX '
    3315/    F1C8 : CE                         FCB  $CE
    3316/    F1C9 : 09                         FCB  XLIMM
    3317/    F1CA : 4C 44 59 20                FCC  'LDY '
    3318/    F1CE : CE                         FCB  $CE
    3319/    F1CF : 11                         FCB  YLIMM
    3320/    F1D0 : 4C 53 4C 20                FCC  'LSL '
    3321/    F1D4 : 68                         FCB  $68
    3322/    F1D5 : 04                         FCB  GRP2
    3323/    F1D6 : 4C 53 4C 41                FCC  'LSLA'
    3324/    F1DA : 48                         FCB  $48
    3325/    F1DB : 01                         FCB  INH
    3326/    F1DC : 4C 53 4C 42                FCC  'LSLB'
    3327/    F1E0 : 58                         FCB  $58
    3328/    F1E1 : 01                         FCB  INH
    3329/    F1E2 : 4C 53 4C 44                FCC  'LSLD'
    3330/    F1E6 : 05                         FCB  $05
    3331/    F1E7 : 01                         FCB  INH
    3332/    F1E8 : 4C 53 52 20                FCC  'LSR '
    3333/    F1EC : 64                         FCB  $64
    3334/    F1ED : 04                         FCB  GRP2
    3335/    F1EE : 4C 53 52 41                FCC  'LSRA'
    3336/    F1F2 : 44                         FCB  $44
    3337/    F1F3 : 01                         FCB  INH
    3338/    F1F4 : 4C 53 52 42                FCC  'LSRB'
    3339/    F1F8 : 54                         FCB  $54
    3340/    F1F9 : 01                         FCB  INH
    3341/    F1FA : 4C 53 52 44                FCC  'LSRD'
    3342/    F1FE : 04                         FCB  $04
    3343/    F1FF : 01                         FCB  INH
    3344/    F200 : 4D 55 4C 20                FCC  'MUL '
    3345/    F204 : 3D                         FCB  $3D
    3346/    F205 : 01                         FCB  INH
    3347/    F206 : 4E 45 47 20                FCC  'NEG '
    3348/    F20A : 60                         FCB  $60
    3349/    F20B : 04                         FCB  GRP2
    3350/    F20C : 4E 45 47 41                FCC  'NEGA'
    3351/    F210 : 40                         FCB  $40
    3352/    F211 : 01                         FCB  INH
    3353/    F212 : 4E 45 47 42                FCC  'NEGB'
    3354/    F216 : 50                         FCB  $50
    3355/    F217 : 01                         FCB  INH
    3356/    F218 : 4E 4F 50 20                FCC  'NOP '
    3357/    F21C : 01                         FCB  $01
    3358/    F21D : 01                         FCB  INH
    3359/    F21E : 4F 52 41 41                FCC  'ORAA'
    3360/    F222 : 8A                         FCB  $8A
    3361/    F223 : 03                         FCB  GEN
    3362/    F224 : 4F 52 41 42                FCC  'ORAB'
    3363/    F228 : CA                         FCB  $CA
    3364/    F229 : 03                         FCB  GEN
    3365/    F22A : 50 53 48 41                FCC  'PSHA'
    3366/    F22E : 36                         FCB  $36
    3367/    F22F : 01                         FCB  INH
    3368/    F230 : 50 53 48 42                FCC  'PSHB'
    3369/    F234 : 37                         FCB  $37
    3370/    F235 : 01                         FCB  INH
    3371/    F236 : 50 53 48 58                FCC  'PSHX'
    3372/    F23A : 3C                         FCB  $3C
    3373/    F23B : 01                         FCB  INH
    3374/    F23C : 50 53 48 59                FCC  'PSHY'
    3375/    F240 : 3C                         FCB  $3C
    3376/    F241 : 02                         FCB  P2INH
    3377/    F242 : 50 55 4C 41                FCC  'PULA'
    3378/    F246 : 32                         FCB  $32
    3379/    F247 : 01                         FCB  INH
    3380/    F248 : 50 55 4C 42                FCC  'PULB'
    3381/    F24C : 33                         FCB  $33
    3382/    F24D : 01                         FCB  INH
    3383/    F24E : 50 55 4C 58                FCC  'PULX'
    3384/    F252 : 38                         FCB  $38
    3385/    F253 : 01                         FCB  INH
    3386/    F254 : 50 55 4C 59                FCC  'PULY'
    3387/    F258 : 38                         FCB  $38
    3388/    F259 : 02                         FCB  P2INH
    3389/    F25A : 52 4F 4C 20                FCC  'ROL '
    3390/    F25E : 69                         FCB  $69
    3391/    F25F : 04                         FCB  GRP2
    3392/    F260 : 52 4F 4C 41                FCC  'ROLA'
    3393/    F264 : 49                         FCB  $49
    3394/    F265 : 01                         FCB  INH
    3395/    F266 : 52 4F 4C 42                FCC  'ROLB'
    3396/    F26A : 59                         FCB  $59
    3397/    F26B : 01                         FCB  INH
    3398/    F26C : 52 4F 52 20                FCC  'ROR '
    3399/    F270 : 66                         FCB  $66
    3400/    F271 : 04                         FCB  GRP2
    3401/    F272 : 52 4F 52 41                FCC  'RORA'
    3402/    F276 : 46                         FCB  $46
    3403/    F277 : 01                         FCB  INH
    3404/    F278 : 52 4F 52 42                FCC  'RORB'
    3405/    F27C : 56                         FCB  $56
    3406/    F27D : 01                         FCB  INH
    3407/    F27E : 52 54 49 20                FCC  'RTI '
    3408/    F282 : 3B                         FCB  $3B
    3409/    F283 : 01                         FCB  INH
    3410/    F284 : 52 54 53 20                FCC  'RTS '
    3411/    F288 : 39                         FCB  $39
    3412/    F289 : 01                         FCB  INH
    3413/    F28A : 53 42 41 20                FCC  'SBA '
    3414/    F28E : 10                         FCB  $10
    3415/    F28F : 01                         FCB  INH
    3416/    F290 : 53 42 43 41                FCC  'SBCA'
    3417/    F294 : 82                         FCB  $82
    3418/    F295 : 03                         FCB  GEN
    3419/    F296 : 53 42 43 42                FCC  'SBCB'
    3420/    F29A : C2                         FCB  $C2
    3421/    F29B : 03                         FCB  GEN
    3422/    F29C : 53 45 43 20                FCC  'SEC '
    3423/    F2A0 : 0D                         FCB  $0D
    3424/    F2A1 : 01                         FCB  INH
    3425/    F2A2 : 53 45 49 20                FCC  'SEI '
    3426/    F2A6 : 0F                         FCB  $0F
    3427/    F2A7 : 01                         FCB  INH
    3428/    F2A8 : 53 45 56 20                FCC  'SEV '
    3429/    F2AC : 0B                         FCB  $0B
    3430/    F2AD : 01                         FCB  INH
    3431/    F2AE : 53 54 41 41                FCC  'STAA'
    3432/    F2B2 : 87                         FCB  $87
    3433/    F2B3 : 07                         FCB  NIMM
    3434/    F2B4 : 53 54 41 42                FCC  'STAB'
    3435/    F2B8 : C7                         FCB  $C7
    3436/    F2B9 : 07                         FCB  NIMM
    3437/    F2BA : 53 54 44 20                FCC  'STD '
    3438/    F2BE : CD                         FCB  $CD
    3439/    F2BF : 07                         FCB  NIMM
    3440/    F2C0 : 53 54 4F 50                FCC  'STOP'
    3441/    F2C4 : CF                         FCB  $CF
    3442/    F2C5 : 01                         FCB  INH
    3443/    F2C6 : 53 54 53 20                FCC  'STS '
    3444/    F2CA : 8F                         FCB  $8F
    3445/    F2CB : 07                         FCB  NIMM
    3446/    F2CC : 53 54 58 20                FCC  'STX '
    3447/    F2D0 : CF                         FCB  $CF
    3448/    F2D1 : 10                         FCB  XNIMM
    3449/    F2D2 : 53 54 59 20                FCC  'STY '
    3450/    F2D6 : CF                         FCB  $CF
    3451/    F2D7 : 12                         FCB  YNIMM
    3452/    F2D8 : 53 55 42 41                FCC  'SUBA'
    3453/    F2DC : 80                         FCB  $80
    3454/    F2DD : 03                         FCB  GEN
    3455/    F2DE : 53 55 42 42                FCC  'SUBB'
    3456/    F2E2 : C0                         FCB  $C0
    3457/    F2E3 : 03                         FCB  GEN
    3458/    F2E4 : 53 55 42 44                FCC  'SUBD'
    3459/    F2E8 : 83                         FCB  $83
    3460/    F2E9 : 08                         FCB  LIMM
    3461/    F2EA : 53 57 49 20                FCC  'SWI '
    3462/    F2EE : 3F                         FCB  $3F
    3463/    F2EF : 01                         FCB  INH
    3464/    F2F0 : 54 41 42 20                FCC  'TAB '
    3465/    F2F4 : 16                         FCB  $16
    3466/    F2F5 : 01                         FCB  INH
    3467/    F2F6 : 54 41 50 20                FCC  'TAP '
    3468/    F2FA : 06                         FCB  $06
    3469/    F2FB : 01                         FCB  INH
    3470/    F2FC : 54 42 41 20                FCC  'TBA '
    3471/    F300 : 17                         FCB  $17
    3472/    F301 : 01                         FCB  INH
    3473/    F302 : 54 50 41 20                FCC  'TPA '
    3474/    F306 : 07                         FCB  $07
    3475/    F307 : 01                         FCB  INH
    3476/    F308 : 54 45 53 54                FCC  'TEST'
    3477/    F30C : 00                         FCB  $00
    3478/    F30D : 01                         FCB  INH
    3479/    F30E : 54 53 54 20                FCC  'TST '
    3480/    F312 : 6D                         FCB  $6D
    3481/    F313 : 04                         FCB  GRP2
    3482/    F314 : 54 53 54 41                FCC  'TSTA'
    3483/    F318 : 4D                         FCB  $4D
    3484/    F319 : 01                         FCB  INH
    3485/    F31A : 54 53 54 42                FCC  'TSTB'
    3486/    F31E : 5D                         FCB  $5D
    3487/    F31F : 01                         FCB  INH
    3488/    F320 : 54 53 58 20                FCC  'TSX '
    3489/    F324 : 30                         FCB  $30
    3490/    F325 : 01                         FCB  INH
    3491/    F326 : 54 53 59 20                FCC  'TSY '
    3492/    F32A : 30                         FCB  $30
    3493/    F32B : 02                         FCB  P2INH
    3494/    F32C : 54 58 53 20                FCC  'TXS '
    3495/    F330 : 35                         FCB  $35
    3496/    F331 : 01                         FCB  INH
    3497/    F332 : 54 59 53 20                FCC  'TYS '
    3498/    F336 : 35                         FCB  $35
    3499/    F337 : 02                         FCB  P2INH
    3500/    F338 : 57 41 49 20                FCC  'WAI '
    3501/    F33C : 3E                         FCB  $3E
    3502/    F33D : 01                         FCB  INH
    3503/    F33E : 58 47 44 58                FCC  'XGDX'
    3504/    F342 : 8F                         FCB  $8F
    3505/    F343 : 01                         FCB  INH
    3506/    F344 : 58 47 44 59                FCC  'XGDY'
    3507/    F348 : 8F                         FCB  $8F
    3508/    F349 : 02                         FCB  P2INH
    3509/    F34A : 42 52 53 45                FCC  'BRSE'     ;   bit direct modes for
    3510/    F34E : 12                         FCB  $12         ;    disassembler.
    3511/    F34F : 16                         FCB  BTBD
    3512/    F350 : 42 52 43 4C                FCC  'BRCL'
    3513/    F354 : 13                         FCB  $13
    3514/    F355 : 16                         FCB  BTBD
    3515/    F356 : 42 53 45 54                FCC  'BSET'
    3516/    F35A : 14                         FCB  $14
    3517/    F35B : 17                         FCB  SETCLRD
    3518/    F35C : 42 43 4C 52                FCC  'BCLR'
    3519/    F360 : 15                         FCB  $15
    3520/    F361 : 17                         FCB  SETCLRD
    3521/    F362 : 04                         FCB  EOT          ;   End of table
    3522/    F363 :
    3523/    F363 :                    ;**********************************************
    3524/    F363 : =0                 PG1     EQU     $0
    3525/    F363 : =1                 PG2     EQU     $1
    3526/    F363 : =2                 PG3     EQU     $2
    3527/    F363 : =3                 PG4     EQU     $3
    3528/    F363 :
    3529/    F363 :                    ;******************
    3530/    F363 :                    ;*disassem() - disassemble the opcode.
    3531/    F363 :                    ;******************
    3532/    F363 :                    ;*(check for page prebyte)
    3533/    F363 :                    ;*baseop=pc[0];
    3534/    F363 :                    ;*pnorm=PG1;
    3535/    F363 :                    ;*if(baseop==$18) pnorm=PG2;
    3536/    F363 :                    ;*if(baseop==$1A) pnorm=PG3;
    3537/    F363 :                    ;*if(baseop==$CD) pnorm=PG4;
    3538/    F363 :                    ;*if(pnorm != PG1) dispc=pc+1;
    3539/    F363 :                    ;*else dispc=pc; (dispc points to next byte)
    3540/    F363 :
    3541/    F363 : =F363              DISASSM EQU  *
    3542/    F363 : DE B0                      LDX  PC      ;   address
    3543/    F365 : A6 00                      LDAA 0,X      ;  opcode
    3544/    F367 : C6 00                      LDAB #PG1
    3545/    F369 : 81 18                      CMPA #$18
    3546/    F36B : 27 0A                      BEQ  DISP2     ; jump if page2
    3547/    F36D : 81 1A                      CMPA #$1A
    3548/    F36F : 27 05                      BEQ  DISP3      ;jump if page3
    3549/    F371 : 81 CD                      CMPA #$CD
    3550/    F373 : 26 04                      BNE  DISP1      ;jump if not page4
    3551/    F375 : 5C                 DISP4   INCB            ;set up page value
    3552/    F376 : 5C                 DISP3   INCB
    3553/    F377 : 5C                 DISP2   INCB
    3554/    F378 : 08                         INX
    3555/    F379 : DF B6              DISP1   STX  DISPC      ;point to opcode
    3556/    F37B : D7 C3                      STAB PNORM      ;save page
    3557/    F37D :
    3558/    F37D :                    ;*If(opcode == ($00-$5F or $8D or $8F or $CF))
    3559/    F37D :                    ;*  if(pnorm == (PG3 or PG4))
    3560/    F37D :                    ;*      disillop(); return();
    3561/    F37D :                    ;*  b=disrch(opcode,NULL);
    3562/    F37D :                    ;*  if(b==0) disillop(); return();
    3563/    F37D :
    3564/    F37D : A6 00                      LDAA 0,X  ;get current opcode
    3565/    F37F : 97 B4                      STAA BASEOP
    3566/    F381 : 08                         INX
    3567/    F382 : DF B6                      STX  DISPC      ;point to next byte
    3568/    F384 : 81 5F                      CMPA #$5F
    3569/    F386 : 23 0F                      BLS  DIS1       ;jump if in range
    3570/    F388 : 81 8D                      CMPA #$8D
    3571/    F38A : 27 0B                      BEQ  DIS1       ;jump if bsr
    3572/    F38C : 81 8F                      CMPA #$8F
    3573/    F38E : 27 07                      BEQ  DIS1       ;jump if xgdx
    3574/    F390 : 81 CF                      CMPA #$CF
    3575/    F392 : 27 03                      BEQ  DIS1       ;jump if stop
    3576/    F394 : 7E F4 2E                   JMP  DISGRP     ;try next part of map
    3577/    F397 : D6 C3              DIS1    LDAB PNORM
    3578/    F399 : C1 02                      CMPB #PG3
    3579/    F39B : 25 04                      BLO  DIS2       ;jump if page 1 or 2
    3580/    F39D : BD F5 E8                   JSR  DISILLOP   ;"illegal opcode"
    3581/    F3A0 : 39                         RTS
    3582/    F3A1 : D6 B4              DIS2    LDAB BASEOP     ;opcode
    3583/    F3A3 : 5F                         CLRB            ;class=null
    3584/    F3A4 : BD F5 17                   JSR  DISRCH
    3585/    F3A7 : 5D                         TSTB
    3586/    F3A8 : 26 04                      BNE  DISPEC     ;jump if opcode found
    3587/    F3AA : BD F5 E8                   JSR  DISILLOP   ;"illegal opcode"
    3588/    F3AD : 39                         RTS
    3589/    F3AE :
    3590/    F3AE :                    ;*   if(opcode==$8D) dissrch(opcode,REL);
    3591/    F3AE :                    ;*   if(opcode==($8F or $CF)) disrch(opcode,INH);
    3592/    F3AE :
    3593/    F3AE : 96 B4              DISPEC  LDAA BASEOP
    3594/    F3B0 : 81 8D                      CMPA #$8D
    3595/    F3B2 : 26 04                      BNE  DISPEC1
    3596/    F3B4 : C6 05                      LDAB #REL
    3597/    F3B6 : 20 0A                      BRA  DISPEC3    ;look for BSR opcode
    3598/    F3B8 : 81 8F              DISPEC1 CMPA #$8F
    3599/    F3BA : 27 04                      BEQ  DISPEC2    ;jump if XGDX opcode
    3600/    F3BC : 81 CF                      CMPA #$CF
    3601/    F3BE : 26 05                      BNE  DISINH     ;jump not STOP opcode
    3602/    F3C0 : C6 01              DISPEC2 LDAB #INH
    3603/    F3C2 : BD F5 17           DISPEC3 JSR  DISRCH     ;find other entry in table
    3604/    F3C5 :
    3605/    F3C5 :                    ;*   if(class==INH)           /* INH */
    3606/    F3C5 :                    ;*      if(pnorm==PG2)
    3607/    F3C5 :                    ;*         b=disrch(baseop,P2INH);
    3608/    F3C5 :                    ;*         if(b==0) disillop(); return();
    3609/    F3C5 :                    ;*      prntmne();
    3610/    F3C5 :                    ;*      return();
    3611/    F3C5 :
    3612/    F3C5 : =F3C5              DISINH  EQU  *
    3613/    F3C5 : D6 B5                      LDAB CLASS
    3614/    F3C7 : C1 01                      CMPB #INH
    3615/    F3C9 : 26 18                      BNE  DISREL     ;jump if not inherent
    3616/    F3CB : D6 C3                      LDAB PNORM
    3617/    F3CD : C1 00                      CMPB #PG1
    3618/    F3CF : 27 0E                      BEQ  DISINH1    ;jump if page1
    3619/    F3D1 : 96 B4                      LDAA BASEOP     ;get opcode
    3620/    F3D3 : C6 02                      LDAB #P2INH     ;class=p2inh
    3621/    F3D5 : BD F5 17                   JSR  DISRCH
    3622/    F3D8 : 5D                         TSTB
    3623/    F3D9 : 26 04                      BNE  DISINH1    ;jump if found
    3624/    F3DB : BD F5 E8                   JSR  DISILLOP   ;"illegal opcode"
    3625/    F3DE : 39                         RTS
    3626/    F3DF : BD F5 3A           DISINH1 JSR  PRNTMNE
    3627/    F3E2 : 39                         RTS
    3628/    F3E3 :
    3629/    F3E3 :                    ;*   elseif(class=REL)       /* REL */
    3630/    F3E3 :                    ;*      if(pnorm != PG1)
    3631/    F3E3 :                    ;*         disillop(); return();
    3632/    F3E3 :                    ;*      prntmne();
    3633/    F3E3 :                    ;*      disrelad();
    3634/    F3E3 :                    ;*      return();
    3635/    F3E3 :
    3636/    F3E3 : =F3E3              DISREL  EQU  *
    3637/    F3E3 : D6 B5                      LDAB CLASS
    3638/    F3E5 : C1 05                      CMPB #REL
    3639/    F3E7 : 26 10                      BNE  DISBTD
    3640/    F3E9 : 7D 00 C3                   TST  PNORM
    3641/    F3EC : 27 04                      BEQ  DISREL1    ;jump if page1
    3642/    F3EE : BD F5 E8                   JSR  DISILLOP   ;"illegal opcode"
    3643/    F3F1 : 39                         RTS
    3644/    F3F2 : BD F5 3A           DISREL1 JSR  PRNTMNE    ;output mnemonic
    3645/    F3F5 : BD F5 70                   JSR  DISRELAD   ;compute relative address
    3646/    F3F8 : 39                         RTS
    3647/    F3F9 :
    3648/    F3F9 :                    ;*   else           /* SETCLR,SETCLRD,BTB,BTBD */
    3649/    F3F9 :                    ;*      if(class == (SETCLRD or BTBD))
    3650/    F3F9 :                    ;*         if(pnorm != PG1)
    3651/    F3F9 :                    ;*            disillop(); return();   /* illop */
    3652/    F3F9 :                    ;*         prntmne();           /* direct */
    3653/    F3F9 :                    ;*         disdir();           /* output $byte */
    3654/    F3F9 :                    ;*      else (class == (SETCLR or BTB))
    3655/    F3F9 :                    ;*         prntmne();           /* indexed */
    3656/    F3F9 :                    ;*         disindx();
    3657/    F3F9 :                    ;*      outspac();
    3658/    F3F9 :                    ;*      disdir();
    3659/    F3F9 :                    ;*      outspac();
    3660/    F3F9 :                    ;*      if(class == (BTB or BTBD))
    3661/    F3F9 :                    ;*         disrelad();
    3662/    F3F9 :                    ;*   return();
    3663/    F3F9 :
    3664/    F3F9 : =F3F9              DISBTD  EQU  *
    3665/    F3F9 : D6 B5                      LDAB CLASS
    3666/    F3FB : C1 17                      CMPB #SETCLRD
    3667/    F3FD : 27 04                      BEQ  DISBTD1
    3668/    F3FF : C1 16                      CMPB #BTBD
    3669/    F401 : 26 11                      BNE  DISBIT     ;jump not direct bitop
    3670/    F403 : 7D 00 C3           DISBTD1 TST  PNORM
    3671/    F406 : 27 04                      BEQ  DISBTD2    ;jump if page 1
    3672/    F408 : BD F5 E8                   JSR  DISILLOP
    3673/    F40B : 39                         RTS
    3674/    F40C : BD F5 3A           DISBTD2 JSR  PRNTMNE
    3675/    F40F : BD F5 C8                   JSR  DISDIR     ;operand(direct)
    3676/    F412 : 20 06                      BRA  DISBIT1
    3677/    F414 : =F414              DISBIT  EQU  *
    3678/    F414 : BD F5 3A                   JSR  PRNTMNE
    3679/    F417 : BD F5 54                   JSR  DISINDX    ;operand(indexed)
    3680/    F41A : BD E4 EF           DISBIT1 JSR  OUTSPAC
    3681/    F41D : BD F5 C8                   JSR  DISDIR     ;mask
    3682/    F420 : D6 B5                      LDAB CLASS
    3683/    F422 : C1 13                      CMPB #BTB
    3684/    F424 : 27 04                      BEQ  DISBIT2    ;jump if btb
    3685/    F426 : C1 16                      CMPB #BTBD
    3686/    F428 : 26 03                      BNE  DISBIT3    ;jump if not bit branch
    3687/    F42A : BD F5 70           DISBIT2 JSR  DISRELAD   ;relative address
    3688/    F42D : 39                 DISBIT3 RTS
    3689/    F42E :
    3690/    F42E :
    3691/    F42E :                    ;*Elseif($60 <= opcode <= $7F)  /*  GRP2 */
    3692/    F42E :                    ;*   if(pnorm == (PG3 or PG4))
    3693/    F42E :                    ;*      disillop(); return();
    3694/    F42E :                    ;*   if((pnorm==PG2) and (opcode != $6x))
    3695/    F42E :                    ;*      disillop(); return();
    3696/    F42E :                    ;*   b=disrch(baseop & $6F,NULL);
    3697/    F42E :                    ;*   if(b==0) disillop(); return();
    3698/    F42E :                    ;*   prntmne();
    3699/    F42E :                    ;*   if(opcode == $6x)
    3700/    F42E :                    ;*      disindx();
    3701/    F42E :                    ;*   else
    3702/    F42E :                    ;*      disext();
    3703/    F42E :                    ;*   return();
    3704/    F42E :
    3705/    F42E : =F42E              DISGRP  EQU  *
    3706/    F42E : 81 7F                      CMPA #$7F       ;a=opcode
    3707/    F430 : 22 2A                      BHI  DISNEXT    ;try next part of map
    3708/    F432 : D6 C3                      LDAB PNORM
    3709/    F434 : C1 02                      CMPB #PG3
    3710/    F436 : 25 04                      BLO  DISGRP2    ;jump if page 1 or 2
    3711/    F438 : BD F5 E8                   JSR  DISILLOP   ;"illegal opcode"
    3712/    F43B : 39                         RTS
    3713/    F43C : 84 6F              DISGRP2 ANDA #$6F       ;mask bit 4
    3714/    F43E : 5F                         CLRB            ;class=null
    3715/    F43F : BD F5 17                   JSR  DISRCH
    3716/    F442 : 5D                         TSTB
    3717/    F443 : 26 04                      BNE  DISGRP3    ;jump if found
    3718/    F445 : BD F5 E8                   JSR  DISILLOP   ;"illegal opcode"
    3719/    F448 : 39                         RTS
    3720/    F449 : BD F5 3A           DISGRP3 JSR  PRNTMNE
    3721/    F44C : 96 B4                      LDAA BASEOP     ;get opcode
    3722/    F44E : 84 F0                      ANDA #$F0
    3723/    F450 : 81 60                      CMPA #$60
    3724/    F452 : 26 04                      BNE  DISGRP4    ;jump if not 6x
    3725/    F454 : BD F5 54                   JSR  DISINDX    ;operand(indexed)
    3726/    F457 : 39                         RTS
    3727/    F458 : BD F5 D5           DISGRP4 JSR  DISEXT     ;operand(extended)
    3728/    F45B : 39                         RTS
    3729/    F45C :
    3730/    F45C :                    ;*Else  ($80 <= opcode <= $FF)
    3731/    F45C :                    ;*   if(opcode == ($87 or $C7))
    3732/    F45C :                    ;*      disillop(); return();
    3733/    F45C :                    ;*   b=disrch(opcode&$CF,NULL);
    3734/    F45C :                    ;*   if(b==0) disillop(); return();
    3735/    F45C :
    3736/    F45C : =F45C              DISNEXT EQU  *
    3737/    F45C : 81 87                      CMPA #$87       ;a=opcode
    3738/    F45E : 27 04                      BEQ  DISNEX1
    3739/    F460 : 81 C7                      CMPA #$C7
    3740/    F462 : 26 04                      BNE  DISNEX2
    3741/    F464 : BD F5 E8           DISNEX1 JSR  DISILLOP   ;"illegal opcode"
    3742/    F467 : 39                         RTS
    3743/    F468 : 84 CF              DISNEX2 ANDA #$CF
    3744/    F46A : 5F                         CLRB            ;class=null
    3745/    F46B : BD F5 17                   JSR  DISRCH
    3746/    F46E : 5D                         TSTB
    3747/    F46F : 26 04                      BNE  DISNEW     ;jump if mne found
    3748/    F471 : BD F5 E8                   JSR  DISILLOP   ;"illegal opcode"
    3749/    F474 : 39                         RTS
    3750/    F475 :
    3751/    F475 :                    ;*   if(opcode&$CF==$8D) disrch(baseop,NIMM; (jsr)
    3752/    F475 :                    ;*   if(opcode&$CF==$8F) disrch(baseop,NIMM; (sts)
    3753/    F475 :                    ;*   if(opcode&$CF==$CF) disrch(baseop,XNIMM; (stx)
    3754/    F475 :                    ;*   if(opcode&$CF==$83) disrch(baseop,LIMM); (subd)
    3755/    F475 :
    3756/    F475 : 96 B4              DISNEW  LDAA BASEOP
    3757/    F477 : 84 CF                      ANDA #$CF
    3758/    F479 : 81 8D                      CMPA #$8D
    3759/    F47B : 26 04                      BNE  DISNEW1    ;jump not jsr
    3760/    F47D : C6 07                      LDAB #NIMM
    3761/    F47F : 20 16                      BRA  DISNEW4
    3762/    F481 : 81 8F              DISNEW1 CMPA #$8F
    3763/    F483 : 26 04                      BNE  DISNEW2    ;jump not sts
    3764/    F485 : C6 07                      LDAB #NIMM
    3765/    F487 : 20 0E                      BRA  DISNEW4
    3766/    F489 : 81 CF              DISNEW2 CMPA #$CF
    3767/    F48B : 26 04                      BNE  DISNEW3    ;jump not stx
    3768/    F48D : C6 10                      LDAB #XNIMM
    3769/    F48F : 20 06                      BRA  DISNEW4
    3770/    F491 : 81 83              DISNEW3 CMPA #$83
    3771/    F493 : 26 0C                      BNE  DISGEN     ;jump not subd
    3772/    F495 : C6 08                      LDAB #LIMM
    3773/    F497 : BD F5 17           DISNEW4 JSR  DISRCH
    3774/    F49A : 5D                         TSTB
    3775/    F49B : 26 04                      BNE  DISGEN     ;jump if found
    3776/    F49D : BD F5 E8                   JSR  DISILLOP   ;"illegal opcode"
    3777/    F4A0 : 39                         RTS
    3778/    F4A1 :
    3779/    F4A1 :                    ;*   if(class == (GEN or NIMM or LIMM   ))   /* GEN,NIMM,LIMM,CPD */
    3780/    F4A1 :                    ;*      if(opcode&$CF==$83)
    3781/    F4A1 :                    ;*         if(pnorm==(PG3 or PG4)) disrch(opcode#$CF,CPD)
    3782/    F4A1 :                    ;*         class=LIMM;
    3783/    F4A1 :                    ;*      if((pnorm == (PG2 or PG4) and (opcode != ($Ax or $Ex)))
    3784/    F4A1 :                    ;*         disillop(); return();
    3785/    F4A1 :                    ;*      disgenrl();
    3786/    F4A1 :                    ;*      return();
    3787/    F4A1 :
    3788/    F4A1 : D6 B5              DISGEN  LDAB CLASS      ;get class
    3789/    F4A3 : C1 03                      CMPB #GEN
    3790/    F4A5 : 27 08                      BEQ  DISGEN1
    3791/    F4A7 : C1 07                      CMPB #NIMM
    3792/    F4A9 : 27 04                      BEQ  DISGEN1
    3793/    F4AB : C1 08                      CMPB #LIMM
    3794/    F4AD : 26 31                      BNE  DISXLN     ;jump if other class
    3795/    F4AF : 96 B4              DISGEN1 LDAA BASEOP
    3796/    F4B1 : 84 CF                      ANDA #$CF
    3797/    F4B3 : 81 83                      CMPA #$83
    3798/    F4B5 : 26 0F                      BNE  DISGEN3    ;jump if not #$83
    3799/    F4B7 : D6 C3                      LDAB PNORM
    3800/    F4B9 : C1 02                      CMPB #PG3
    3801/    F4BB : 25 09                      BLO  DISGEN3    ;jump not pg3 or 4
    3802/    F4BD : C6 15                      LDAB #CPD
    3803/    F4BF : BD F5 17                   JSR  DISRCH     ;look for cpd mne
    3804/    F4C2 : C6 08                      LDAB #LIMM
    3805/    F4C4 : D7 B5                      STAB CLASS      ;set class to limm
    3806/    F4C6 : D6 C3              DISGEN3 LDAB PNORM
    3807/    F4C8 : C1 01                      CMPB #PG2
    3808/    F4CA : 27 04                      BEQ  DISGEN4    ;jump if page 2
    3809/    F4CC : C1 03                      CMPB #PG4
    3810/    F4CE : 26 0C                      BNE  DISGEN5   ;jump not page 2 or 4
    3811/    F4D0 : 96 B4              DISGEN4 LDAA BASEOP
    3812/    F4D2 : 84 B0                      ANDA #$B0       ;mask bits 6,3-0
    3813/    F4D4 : 81 A0                      CMPA #$A0
    3814/    F4D6 : 27 04                      BEQ  DISGEN5     ;jump if $Ax or $Ex
    3815/    F4D8 : BD F5 E8                   JSR  DISILLOP   ;"illegal opcode"
    3816/    F4DB : 39                         RTS
    3817/    F4DC : BD F5 92           DISGEN5 JSR  DISGENRL   ;process general class
    3818/    F4DF : 39                         RTS
    3819/    F4E0 :
    3820/    F4E0 :                    ;*   else       /* XLIMM,XNIMM,YLIMM,YNIMM */
    3821/    F4E0 :                    ;*      if(pnorm==(PG2 or PG3))
    3822/    F4E0 :                    ;*         if(class==XLIMM) disrch(opcode&$CF,YLIMM);
    3823/    F4E0 :                    ;*         else disrch(opcode&$CF,YNIMM);
    3824/    F4E0 :                    ;*      if((pnorm == (PG3 or PG4))
    3825/    F4E0 :                    ;*         if(opcode != ($Ax or $Ex))
    3826/    F4E0 :                    ;*            disillop(); return();
    3827/    F4E0 :                    ;*      class=LIMM;
    3828/    F4E0 :                    ;*      disgen();
    3829/    F4E0 :                    ;*   return();
    3830/    F4E0 :
    3831/    F4E0 : D6 C3              DISXLN  LDAB PNORM
    3832/    F4E2 : C1 01                      CMPB #PG2
    3833/    F4E4 : 27 04                      BEQ  DISXLN1    ;jump if page2
    3834/    F4E6 : C1 02                      CMPB #PG3
    3835/    F4E8 : 26 13                      BNE  DISXLN4    ;jump not page3
    3836/    F4EA : 96 B4              DISXLN1 LDAA BASEOP
    3837/    F4EC : 84 CF                      ANDA #$CF
    3838/    F4EE : D6 B5                      LDAB CLASS
    3839/    F4F0 : C1 09                      CMPB #XLIMM
    3840/    F4F2 : 26 04                      BNE  DISXLN2
    3841/    F4F4 : C6 11                      LDAB #YLIMM
    3842/    F4F6 : 20 02                      BRA  DISXLN3    ;look for ylimm
    3843/    F4F8 : C6 12              DISXLN2 LDAB #YNIMM     ;look for ynimm
    3844/    F4FA : BD F5 17           DISXLN3 JSR  DISRCH
    3845/    F4FD : D6 C3              DISXLN4 LDAB PNORM
    3846/    F4FF : C1 02                      CMPB #PG3
    3847/    F501 : 25 0C                      BLO  DISXLN5    ;jump if page 1 or 2
    3848/    F503 : 96 B4                      LDAA BASEOP     ;get opcode
    3849/    F505 : 84 B0                      ANDA #$B0       ;mask bits 6,3-0
    3850/    F507 : 81 A0                      CMPA #$A0
    3851/    F509 : 27 04                      BEQ  DISXLN5    ;jump opcode = $Ax or $Ex
    3852/    F50B : BD F5 E8                   JSR  DISILLOP   ;"illegal opcode"
    3853/    F50E : 39                         RTS
    3854/    F50F : C6 08              DISXLN5 LDAB #LIMM
    3855/    F511 : D7 B5                      STAB CLASS
    3856/    F513 : BD F5 92                   JSR  DISGENRL   ;process general class
    3857/    F516 : 39                         RTS
    3858/    F517 :
    3859/    F517 :
    3860/    F517 :                    ;******************
    3861/    F517 :                    ;*disrch(a=opcode,b=class)
    3862/    F517 :                    ;*return b=0 if not found
    3863/    F517 :                    ;*  else mneptr=points to mnemonic
    3864/    F517 :                    ;*        class=class of opcode
    3865/    F517 :                    ;******************
    3866/    F517 :                    ;*x=#MNETABL
    3867/    F517 :                    ;*while(x[0] != eot)
    3868/    F517 :                    ;*   if((opcode==x[4]) && ((class=NULL) || (class=x[5])))
    3869/    F517 :                    ;*      mneptr=x;
    3870/    F517 :                    ;*      class=x[5];
    3871/    F517 :                    ;*      return(1);
    3872/    F517 :                    ;*   x += 6;
    3873/    F517 :                    ;*return(0);      /* not found */
    3874/    F517 :
    3875/    F517 : =F517              DISRCH  EQU  *
    3876/    F517 : CE EF E4                   LDX  #MNETABL   ;point to top of table
    3877/    F51A : A1 04              DISRCH1 CMPA 4,X        ;test opcode
    3878/    F51C : 26 0F                      BNE  DISRCH3    ;jump not this entry
    3879/    F51E : 5D                         TSTB
    3880/    F51F : 27 04                      BEQ  DISRCH2    ;jump if class=null
    3881/    F521 : E1 05                      CMPB 5,X        ;test class
    3882/    F523 : 26 08                      BNE  DISRCH3    ;jump not this entry
    3883/    F525 : E6 05              DISRCH2 LDAB 5,X
    3884/    F527 : D7 B5                      STAB CLASS
    3885/    F529 : DF BA                      STX  MNEPTR     ;return ptr to mnemonic
    3886/    F52B : 5C                         INCB
    3887/    F52C : 39                         RTS             ;return found
    3888/    F52D : 37                 DISRCH3 PSHB            ;save class
    3889/    F52E : C6 06                      LDAB #6
    3890/    F530 : 3A                         ABX
    3891/    F531 : E6 00                      LDAB 0,X
    3892/    F533 : C1 04                      CMPB #EOT       ;test end of table
    3893/    F535 : 33                         PULB
    3894/    F536 : 26 E2                      BNE  DISRCH1
    3895/    F538 : 5F                         CLRB
    3896/    F539 : 39                         RTS             ;return not found
    3897/    F53A :
    3898/    F53A :                    ;******************
    3899/    F53A :                    ;*prntmne() - output the mnemonic pointed
    3900/    F53A :                    ;*at by mneptr.
    3901/    F53A :                    ;******************
    3902/    F53A :                    ;*outa(mneptr[0-3]);
    3903/    F53A :                    ;*outspac;
    3904/    F53A :                    ;*return();
    3905/    F53A :
    3906/    F53A : =F53A              PRNTMNE EQU  *
    3907/    F53A : DE BA                      LDX  MNEPTR
    3908/    F53C : A6 00                      LDAA 0,X
    3909/    F53E : BD E4 D9                   JSR  OUTA       ;output char1
    3910/    F541 : A6 01                      LDAA 1,X
    3911/    F543 : BD E4 D9                   JSR  OUTA       ;output char2
    3912/    F546 : A6 02                      LDAA 2,X
    3913/    F548 : BD E4 D9                   JSR  OUTA       ;output char3
    3914/    F54B : A6 03                      LDAA 3,X
    3915/    F54D : BD E4 D9                   JSR  OUTA       ;output char4
    3916/    F550 : BD E4 EF                   JSR  OUTSPAC
    3917/    F553 : 39                         RTS
    3918/    F554 :
    3919/    F554 :                    ;******************
    3920/    F554 :                    ;*disindx() - process indexed mode
    3921/    F554 :                    ;******************
    3922/    F554 :                    ;*disdir();
    3923/    F554 :                    ;*outa(',');
    3924/    F554 :                    ;*if(pnorm == (PG2 or PG4)) outa('Y');
    3925/    F554 :                    ;*else outa('X');
    3926/    F554 :                    ;*return();
    3927/    F554 :
    3928/    F554 : =F554              DISINDX EQU  *
    3929/    F554 : BD F5 C8                   JSR  DISDIR     ;output $byte
    3930/    F557 : 86 2C                      LDAA #','
    3931/    F559 : BD E4 D9                   JSR  OUTA       ;output ,
    3932/    F55C : D6 C3                      LDAB PNORM
    3933/    F55E : C1 01                      CMPB #PG2
    3934/    F560 : 27 04                      BEQ  DISIND1    ;jump if page2
    3935/    F562 : C1 03                      CMPB #PG4
    3936/    F564 : 26 04                      BNE  DISIND2    ;jump if not page4
    3937/    F566 : 86 59              DISIND1 LDAA #'Y'
    3938/    F568 : 20 02                      BRA DISIND3
    3939/    F56A : 86 58              DISIND2 LDAA #'X'
    3940/    F56C : BD E4 D9           DISIND3 JSR  OUTA       ;output x or y
    3941/    F56F : 39                         RTS
    3942/    F570 :
    3943/    F570 :                    ;******************
    3944/    F570 :                    ;*disrelad() - compute and output relative address.
    3945/    F570 :                    ;******************
    3946/    F570 :                    ;* braddr = dispc[0] + (dispc++);( 2's comp arith)
    3947/    F570 :                    ;*outa('$');
    3948/    F570 :                    ;*out2bsp(braddr);
    3949/    F570 :                    ;*return();
    3950/    F570 :
    3951/    F570 : =F570              DISRELAD EQU *
    3952/    F570 : DE B6                      LDX  DISPC
    3953/    F572 : E6 00                      LDAB 0,X        ;get relative offset
    3954/    F574 : 08                         INX
    3955/    F575 : DF B6                      STX  DISPC
    3956/    F577 : 5D                         TSTB
    3957/    F578 : 2B 03                      BMI  DISRLD1    ;jump if negative
    3958/    F57A : 3A                         ABX
    3959/    F57B : 20 04                      BRA  DISRLD2
    3960/    F57D : 09                 DISRLD1 DEX
    3961/    F57E : 5C                         INCB
    3962/    F57F : 26 FC                      BNE  DISRLD1    ;subtract
    3963/    F581 : DF B8              DISRLD2 STX  BRADDR     ;save address
    3964/    F583 : BD E4 EF                   JSR  OUTSPAC
    3965/    F586 : 86 24                      LDAA #'$'
    3966/    F588 : BD E4 D9                   JSR  OUTA
    3967/    F58B : CE 00 B8                   LDX  #BRADDR
    3968/    F58E : BD E4 E9                   JSR  OUT2BSP    ;output address
    3969/    F591 : 39                         RTS
    3970/    F592 :
    3971/    F592 :
    3972/    F592 :                    ;******************
    3973/    F592 :                    ;*disgenrl() - output data for the general cases which
    3974/    F592 :                    ;*includes immediate, direct, indexed, and extended modes.
    3975/    F592 :                    ;******************
    3976/    F592 :                    ;*prntmne();
    3977/    F592 :                    ;*if(baseop == ($8x or $Cx))   /* immediate */
    3978/    F592 :                    ;*   outa('#');
    3979/    F592 :                    ;*   disdir();
    3980/    F592 :                    ;*   if(class == LIMM)
    3981/    F592 :                    ;*      out1byt(dispc++);
    3982/    F592 :                    ;*elseif(baseop == ($9x or $Dx))  /* direct */
    3983/    F592 :                    ;*   disdir();
    3984/    F592 :                    ;*elseif(baseop == ($Ax or $Ex)) /* indexed */
    3985/    F592 :                    ;*   disindx();
    3986/    F592 :                    ;*else  (baseop == ($Bx or $Fx)) /* extended */
    3987/    F592 :                    ;*   disext();
    3988/    F592 :                    ;*return();
    3989/    F592 :
    3990/    F592 : =F592              DISGENRL EQU *
    3991/    F592 : BD F5 3A                   JSR  PRNTMNE    ;print mnemonic
    3992/    F595 : 96 B4                      LDAA BASEOP     ;get opcode
    3993/    F597 : 84 B0                      ANDA #$B0       ;mask bits 6,3-0
    3994/    F599 : 81 80                      CMPA #$80
    3995/    F59B : 26 17                      BNE  DISGRL2   ;jump if not immed
    3996/    F59D : 86 23                      LDAA #'#'       ;do immediate
    3997/    F59F : BD E4 D9                   JSR  OUTA
    3998/    F5A2 : BD F5 C8                   JSR  DISDIR
    3999/    F5A5 : D6 B5                      LDAB CLASS
    4000/    F5A7 : C1 08                      CMPB #LIMM
    4001/    F5A9 : 27 01                      BEQ  DISGRL1   ;jump class = limm
    4002/    F5AB : 39                         RTS
    4003/    F5AC : DE B6              DISGRL1 LDX  DISPC
    4004/    F5AE : BD E4 DD                   JSR  OUT1BYT
    4005/    F5B1 : DF B6                      STX  DISPC
    4006/    F5B3 : 39                         RTS
    4007/    F5B4 : 81 90              DISGRL2 CMPA #$90
    4008/    F5B6 : 26 04                      BNE  DISGRL3    ;jump not direct
    4009/    F5B8 : BD F5 C8                   JSR  DISDIR     ;do direct
    4010/    F5BB : 39                         RTS
    4011/    F5BC : 81 A0              DISGRL3 CMPA #$A0
    4012/    F5BE : 26 04                      BNE  DISGRL4    ;jump not indexed
    4013/    F5C0 : BD F5 54                   JSR  DISINDX    ;do extended
    4014/    F5C3 : 39                         RTS
    4015/    F5C4 : BD F5 D5           DISGRL4 JSR  DISEXT     ;do extended
    4016/    F5C7 : 39                         RTS
    4017/    F5C8 :
    4018/    F5C8 :                    ;*****************
    4019/    F5C8 :                    ;*disdir() - output "$ next byte"
    4020/    F5C8 :                    ;*****************
    4021/    F5C8 : =F5C8              DISDIR  EQU  *
    4022/    F5C8 : 86 24                      LDAA #'$'
    4023/    F5CA : BD E4 D9                   JSR  OUTA
    4024/    F5CD : DE B6                      LDX  DISPC
    4025/    F5CF : BD E4 DD                   JSR  OUT1BYT
    4026/    F5D2 : DF B6                      STX  DISPC
    4027/    F5D4 : 39                         RTS
    4028/    F5D5 :
    4029/    F5D5 :                    ;*****************
    4030/    F5D5 :                    ;*disext() - output "$ next 2 bytes"
    4031/    F5D5 :                    ;*****************
    4032/    F5D5 : =F5D5              DISEXT  EQU  *
    4033/    F5D5 : 86 24                      LDAA #'$'
    4034/    F5D7 : BD E4 D9                   JSR  OUTA
    4035/    F5DA : DE B6                      LDX  DISPC
    4036/    F5DC : BD E4 E9                   JSR  OUT2BSP
    4037/    F5DF : DF B6                      STX  DISPC
    4038/    F5E1 : 39                         RTS
    4039/    F5E2 :
    4040/    F5E2 :
    4041/    F5E2 :                    ;*****************
    4042/    F5E2 :                    ;*disillop() - output "illegal opcode"
    4043/    F5E2 :                    ;*****************
    4044/    F5E2 : 49 4C 4C 4F 50     DISMSG1 FCC  'ILLOP'
    4045/    F5E7 : 04                         FCB  EOT
    4046/    F5E8 : =F5E8              DISILLOP EQU *
    4047/    F5E8 : 3C                         PSHX
    4048/    F5E9 : CE F5 E2                   LDX  #DISMSG1
    4049/    F5EC : BD E5 08                   JSR  OUTSTRG0   ;no cr
    4050/    F5EF : 38                         PULX
    4051/    F5F0 : 39                         RTS
    4052/    F5F1 :
    4053/    F5F1 :
    4054/    F5F1 :
    4055/    F5F1 :                    ;**********
    4056/    F5F1 :                    ;*   help  -  List buffalo commands to terminal.
    4057/    F5F1 :                    ;**********
    4058/    F5F1 : =F5F1              HELP     EQU  *
    4059/    F5F1 : CE F5 F8                    LDX  #HELPMSG1
    4060/    F5F4 : BD E5 05                    JSR  OUTSTRG    ;print help screen
    4061/    F5F7 : 39                          RTS
    4062/    F5F8 :
    4063/    F5F8 : =F5F8              HELPMSG1 EQU  *
    4064/    F5F8 : 41 53 4D 20 5B 3C           FCC  'ASM [<addr>]  Line asm/disasm'
             F5FE : 61 64 64 72 3E 5D
             F604 : 20 20 4C 69 6E 65
             F60A : 20 61 73 6D 2F 64
             F610 : 69 73 61 73 6D
    4065/    F615 : 0D                          FCB  $0D
    4066/    F616 : 20 20 5B 2F 2C 3D           FCC  '  [/,=]  Same addr,       [^,-]  Prev addr,       [+,CTLJ] Next addr'
             F61C : 5D 20 20 53 61 6D
             F622 : 65 20 61 64 64 72
             F628 : 2C 20 20 20 20 20
             F62E : 20 20 5B 5E 2C 2D
             F634 : 5D 20 20 50 72 65
             F63A : 76 20 61 64 64 72
             F640 : 2C 20 20 20 20 20
             F646 : 20 20 5B 2B 2C 43
             F64C : 54 4C 4A 5D 20 4E
             F652 : 65 78 74 20 61 64
             F658 : 64 72
    4067/    F65A : 0D                          FCB  $0D
    4068/    F65B : 20 20 5B 43 52 5D           FCC  '  [CR]  Next opcode,                              [CTLA,.]  Quit'
             F661 : 20 20 4E 65 78 74
             F667 : 20 6F 70 63 6F 64
             F66D : 65 2C 20 20 20 20
             F673 : 20 20 20 20 20 20
             F679 : 20 20 20 20 20 20
             F67F : 20 20 20 20 20 20
             F685 : 20 20 20 20 20 20
             F68B : 20 20 5B 43 54 4C
             F691 : 41 2C 2E 5D 20 20
             F697 : 51 75 69 74
    4069/    F69B : 0D                          FCB  $0D
    4070/    F69C : 42 46 20 3C 61 64           FCC  'BF <addr1> <addr2> [<data>]  Block fill memory'
             F6A2 : 64 72 31 3E 20 3C
             F6A8 : 61 64 64 72 32 3E
             F6AE : 20 5B 3C 64 61 74
             F6B4 : 61 3E 5D 20 20 42
             F6BA : 6C 6F 63 6B 20 66
             F6C0 : 69 6C 6C 20 6D 65
             F6C6 : 6D 6F 72 79
    4071/    F6CA : 0D                          FCB  $0D
    4072/    F6CB : 42 52 20 5B 2D 5D           FCC  'BR [-][<addr>] Set up bkpt table'
             F6D1 : 5B 3C 61 64 64 72
             F6D7 : 3E 5D 20 53 65 74
             F6DD : 20 75 70 20 62 6B
             F6E3 : 70 74 20 74 61 62
             F6E9 : 6C 65
    4073/    F6EB : 0D                          FCB  $0D
    4074/    F6EC : 42 55 4C 4B 20 20           FCC  'BULK  Erase EEPROM,                 BULKALL  Erase EEPROM and CONFIG'
             F6F2 : 45 72 61 73 65 20
             F6F8 : 45 45 50 52 4F 4D
             F6FE : 2C 20 20 20 20 20
             F704 : 20 20 20 20 20 20
             F70A : 20 20 20 20 20 20
             F710 : 42 55 4C 4B 41 4C
             F716 : 4C 20 20 45 72 61
             F71C : 73 65 20 45 45 50
             F722 : 52 4F 4D 20 61 6E
             F728 : 64 20 43 4F 4E 46
             F72E : 49 47
    4075/    F730 : 0D                          FCB  $0D
    4076/    F731 : 43 41 4C 4C 20 5B           FCC  'CALL [<addr>] Call subroutine'
             F737 : 3C 61 64 64 72 3E
             F73D : 5D 20 43 61 6C 6C
             F743 : 20 73 75 62 72 6F
             F749 : 75 74 69 6E 65
    4077/    F74E : 0D                          FCB  $0D
    4078/    F74F : 47 4F 20 5B 3C 61           FCC  'GO [<addr>] Execute code at addr,        PROCEED  Continue execution'
             F755 : 64 64 72 3E 5D 20
             F75B : 45 78 65 63 75 74
             F761 : 65 20 63 6F 64 65
             F767 : 20 61 74 20 61 64
             F76D : 64 72 2C 20 20 20
             F773 : 20 20 20 20 20 50
             F779 : 52 4F 43 45 45 44
             F77F : 20 20 43 6F 6E 74
             F785 : 69 6E 75 65 20 65
             F78B : 78 65 63 75 74 69
             F791 : 6F 6E
    4079/    F793 : 0D                          FCB  $0D
    4080/    F794 : 45 45 4D 4F 44 20           FCC  'EEMOD [<addr> [<addr>]] Modify EEPROM range'
             F79A : 5B 3C 61 64 64 72
             F7A0 : 3E 20 5B 3C 61 64
             F7A6 : 64 72 3E 5D 5D 20
             F7AC : 4D 6F 64 69 66 79
             F7B2 : 20 45 45 50 52 4F
             F7B8 : 4D 20 72 61 6E 67
             F7BE : 65
    4081/    F7BF : 0D                          FCB  $0D
    4082/    F7C0 : 4C 4F 41 44 2C 20           FCC  'LOAD, VERIFY [T] <host dwnld command>  Load or verify S-records'
             F7C6 : 56 45 52 49 46 59
             F7CC : 20 5B 54 5D 20 3C
             F7D2 : 68 6F 73 74 20 64
             F7D8 : 77 6E 6C 64 20 63
             F7DE : 6F 6D 6D 61 6E 64
             F7E4 : 3E 20 20 4C 6F 61
             F7EA : 64 20 6F 72 20 76
             F7F0 : 65 72 69 66 79 20
             F7F6 : 53 2D 72 65 63 6F
             F7FC : 72 64 73
    4083/    F7FF : 0D                          FCB  $0D
    4084/    F800 : 4D 44 20 5B 3C 61           FCC  'MD [<addr1> [<addr2>]]  Memory dump'
             F806 : 64 64 72 31 3E 20
             F80C : 5B 3C 61 64 64 72
             F812 : 32 3E 5D 5D 20 20
             F818 : 4D 65 6D 6F 72 79
             F81E : 20 64 75 6D 70
    4085/    F823 : 0D                          FCB  $0D
    4086/    F824 : 4D 4D 20 5B 3C 61           FCC  'MM [<addr>] or [<addr>]/  Memory Modify'
             F82A : 64 64 72 3E 5D 20
             F830 : 6F 72 20 5B 3C 61
             F836 : 64 64 72 3E 5D 2F
             F83C : 20 20 4D 65 6D 6F
             F842 : 72 79 20 4D 6F 64
             F848 : 69 66 79
    4087/    F84B : 0D                          FCB  $0D
    4088/    F84C : 20 20 5B 2F 2C 3D           FCC  '  [/,=]  Same addr,  [^,-,CTLH] Prev addr,  [+,CTLJ,SPACE] Next addr'
             F852 : 5D 20 20 53 61 6D
             F858 : 65 20 61 64 64 72
             F85E : 2C 20 20 5B 5E 2C
             F864 : 2D 2C 43 54 4C 48
             F86A : 5D 20 50 72 65 76
             F870 : 20 61 64 64 72 2C
             F876 : 20 20 5B 2B 2C 43
             F87C : 54 4C 4A 2C 53 50
             F882 : 41 43 45 5D 20 4E
             F888 : 65 78 74 20 61 64
             F88E : 64 72
    4089/    F890 : 0D                          FCB  $0D
    4090/    F891 : 20 20 3C 61 64 64           FCC  '  <addr>O Compute offset,                   [CR]  Quit'
             F897 : 72 3E 4F 20 43 6F
             F89D : 6D 70 75 74 65 20
             F8A3 : 6F 66 66 73 65 74
             F8A9 : 2C 20 20 20 20 20
             F8AF : 20 20 20 20 20 20
             F8B5 : 20 20 20 20 20 20
             F8BB : 20 20 5B 43 52 5D
             F8C1 : 20 20 51 75 69 74
    4091/    F8C7 : 0D                          FCB  $0D
    4092/    F8C8 : 4D 4F 56 45 20 3C           FCC  'MOVE <s1> <s2> [<d>]  Block move'
             F8CE : 73 31 3E 20 3C 73
             F8D4 : 32 3E 20 5B 3C 64
             F8DA : 3E 5D 20 20 42 6C
             F8E0 : 6F 63 6B 20 6D 6F
             F8E6 : 76 65
    4093/    F8E8 : 0D                          FCB  $0D
    4094/    F8E9 : 4F 46 46 53 45 54           FCC  'OFFSET [-]<arg>  Offset for download'
             F8EF : 20 5B 2D 5D 3C 61
             F8F5 : 72 67 3E 20 20 4F
             F8FB : 66 66 73 65 74 20
             F901 : 66 6F 72 20 64 6F
             F907 : 77 6E 6C 6F 61 64
    4095/    F90D : 0D                          FCB  $0D
    4096/    F90E : 52 4D 20 5B 50 2C           FCC  'RM [P,Y,X,A,B,C,S]  Register modify'
             F914 : 59 2C 58 2C 41 2C
             F91A : 42 2C 43 2C 53 5D
             F920 : 20 20 52 65 67 69
             F926 : 73 74 65 72 20 6D
             F92C : 6F 64 69 66 79
    4097/    F931 : 0D                          FCB  $0D
    4098/    F932 : 53 54 4F 50 41 54           FCC  'STOPAT <addr>  Trace until addr'
             F938 : 20 3C 61 64 64 72
             F93E : 3E 20 20 54 72 61
             F944 : 63 65 20 75 6E 74
             F94A : 69 6C 20 61 64 64
             F950 : 72
    4099/    F951 : 0D                          FCB  $0D
    4100/    F952 : 54 20 5B 3C 6E 3E           FCC  'T [<n>]  Trace n instructions'
             F958 : 5D 20 20 54 72 61
             F95E : 63 65 20 6E 20 69
             F964 : 6E 73 74 72 75 63
             F96A : 74 69 6F 6E 73
    4101/    F96F : 0D                          FCB  $0D
    4102/    F970 : 54 4D 20 20 54 72           FCC  'TM  Transparent mode (CTLA = exit, CTLB = send brk)'
             F976 : 61 6E 73 70 61 72
             F97C : 65 6E 74 20 6D 6F
             F982 : 64 65 20 28 43 54
             F988 : 4C 41 20 3D 20 65
             F98E : 78 69 74 2C 20 43
             F994 : 54 4C 42 20 3D 20
             F99A : 73 65 6E 64 20 62
             F9A0 : 72 6B 29
    4103/    F9A3 : 0D                          FCB  $0D
    4104/    F9A4 : 5B 43 54 4C 57 5D           FCC  '[CTLW]  Wait,          [CTLX,DEL] Abort         [CR] Repeat last cmd'
             F9AA : 20 20 57 61 69 74
             F9B0 : 2C 20 20 20 20 20
             F9B6 : 20 20 20 20 20 5B
             F9BC : 43 54 4C 58 2C 44
             F9C2 : 45 4C 5D 20 41 62
             F9C8 : 6F 72 74 20 20 20
             F9CE : 20 20 20 20 20 20
             F9D4 : 5B 43 52 5D 20 52
             F9DA : 65 70 65 61 74 20
             F9E0 : 6C 61 73 74 20 63
             F9E6 : 6D 64
    4105/    F9E8 : 0D                          FCB  $0D
    4106/    F9E9 : 04                          FCB  4
    4107/    F9EA :
    4108/    F9EA :
    4109/    F9EA :
    4110/    F9EA :                    ;**********
    4111/    F9EA :                    ;*   call [<addr>] - Execute a jsr to <addr> or user
    4112/    F9EA :                    ;*pc value.  Return to monitor via  rts or breakpoint.
    4113/    F9EA :                    ;**********
    4114/    F9EA :                    ;*a = wskip();
    4115/    F9EA :                    ;*if(a != cr)
    4116/    F9EA :                    ;*     a = buffarg();
    4117/    F9EA :                    ;*     a = wskip();
    4118/    F9EA :                    ;*     if(a != cr) return(bad argument)
    4119/    F9EA :                    ;*     pc = shftreg;
    4120/    F9EA : BD E2 FC           CALL     JSR  WSKIP
    4121/    F9ED : 27 13                       BEQ  CALL3       ;jump if no arg
    4122/    F9EF : BD E2 34                    JSR  BUFFARG
    4123/    F9F2 : BD E2 FC                    JSR  WSKIP
    4124/    F9F5 : 27 07                       BEQ  CALL2       ;jump if cr
    4125/    F9F7 : CE E6 98                    LDX  #MSG9       ;"bad argument"
    4126/    F9FA : BD E5 05                    JSR  OUTSTRG
    4127/    F9FD : 39                          RTS
    4128/    F9FE : DE 96              CALL2    LDX  SHFTREG
    4129/    FA00 : DF 60                       STX  REGS        ;pc = <addr>
    4130/    FA02 :
    4131/    FA02 :                    ;*put return address on user stack
    4132/    FA02 :                    ;*setbps();
    4133/    FA02 :                    ;*restack();     /* restack and go*/
    4134/    FA02 : DE 69              CALL3    LDX  SP
    4135/    FA04 : 09                          DEX              ;user stack pointer
    4136/    FA05 : CC FA 16                    LDD  #RETURN     ;return address
    4137/    FA08 : ED 00                       STD  0,X
    4138/    FA0A : 09                          DEX
    4139/    FA0B : DF 69                       STX  SP          ;new user stack pointer
    4140/    FA0D : BD FA 87                    JSR  SETBPS
    4141/    FA10 : 7F 00 C1                    CLR  TMP2        ;1=go, 0=call
    4142/    FA13 : 7E FB 72                    JMP  RESTACK     ;go to user code
    4143/    FA16 :
    4144/    FA16 :                    ;**********
    4145/    FA16 :                    ;*   return() - Return here from rts after
    4146/    FA16 :                    ;*call command.
    4147/    FA16 :                    ;**********
    4148/    FA16 : 36                 RETURN   PSHA             ;save a register
    4149/    FA17 : 07                          TPA
    4150/    FA18 : 97 68                       STAA REGS+8      ;cc register
    4151/    FA1A : 0F                          SEI              ;mask interrupts
    4152/    FA1B : 32                          PULA
    4153/    FA1C : DD 66                       STD  REGS+6      ;a and b registers
    4154/    FA1E : DF 64                       STX  REGS+4      ;x register
    4155/    FA20 : 18 DF 62                    STY  REGS+2      ;y register
    4156/    FA23 : 9F 69                       STS  SP          ;user stack pointer
    4157/    FA25 : 9E B2                       LDS  PTR2        ;monitor stack pointer
    4158/    FA27 : BD FA B4                    JSR  REMBPS      ;remove breakpoints
    4159/    FA2A : BD E4 F5                    JSR  OUTCRLF
    4160/    FA2D : BD E1 F3                    JSR  RPRINT      ;print user registers
    4161/    FA30 : 39                          RTS
    4162/    FA31 :
    4163/    FA31 :
    4164/    FA31 :                    ;**********
    4165/    FA31 :                    ;*   proceed - Same as go except it ignores
    4166/    FA31 :                    ;*a breakpoint at the first opcode.  Calls
    4167/    FA31 :                    ;*runone for the first instruction only.
    4168/    FA31 :                    ;**********
    4169/    FA31 : =FA31              PROCEED  EQU  *
    4170/    FA31 : BD FB 56                    JSR  RUNONE      ;run one instruction
    4171/    FA34 : BD E3 1F                    JSR  CHKABRT     ;check for abort
    4172/    FA37 : 7F 00 C1                    CLR  TMP2        ;flag for breakpoints
    4173/    FA3A : 7C 00 C1                    INC  TMP2        ;  1=go 0=call
    4174/    FA3D : BD FA 87                    JSR  SETBPS
    4175/    FA40 : 7E FB 72                    JMP  RESTACK     ;go execute
    4176/    FA43 :
    4177/    FA43 :                    ;**********
    4178/    FA43 :                    ;*   go [<addr>] - Execute starting at <addr> or
    4179/    FA43 :                    ;*user's pc value.  Executes an rti to user code.
    4180/    FA43 :                    ;*Returns to monitor via an swi through swiin.
    4181/    FA43 :                    ;**********
    4182/    FA43 :                    ;*a = wskip();
    4183/    FA43 :                    ;*if(a != cr)
    4184/    FA43 :                    ;*     a = buffarg();
    4185/    FA43 :                    ;*     a = wskip();
    4186/    FA43 :                    ;*     if(a != cr) return(bad argument)
    4187/    FA43 :                    ;*     pc = shftreg;
    4188/    FA43 :                    ;*setbps();
    4189/    FA43 :                    ;*restack();     /* restack and go*/
    4190/    FA43 : BD E2 FC           GO       JSR  WSKIP
    4191/    FA46 : 27 13                       BEQ  GO2         ;jump if no arg
    4192/    FA48 : BD E2 34                    JSR  BUFFARG
    4193/    FA4B : BD E2 FC                    JSR  WSKIP
    4194/    FA4E : 27 07                       BEQ  GO1         ;jump if cr
    4195/    FA50 : CE E6 98                    LDX  #MSG9       ;"bad argument"
    4196/    FA53 : BD E5 05                    JSR  OUTSTRG
    4197/    FA56 : 39                          RTS
    4198/    FA57 : DE 96              GO1      LDX  SHFTREG
    4199/    FA59 : DF 60                       STX  REGS        ;pc = <addr>
    4200/    FA5B : 7F 00 C1           GO2      CLR  TMP2
    4201/    FA5E : 7C 00 C1                    INC  TMP2        ;1=go, 0=call
    4202/    FA61 : BD FA 87                    JSR  SETBPS
    4203/    FA64 : 7E FB 72                    JMP  RESTACK     ;go to user code
    4204/    FA67 :
    4205/    FA67 :                    ;*****
    4206/    FA67 :                    ;** SWIIN - Breakpoints from go or call commands enter here.
    4207/    FA67 :                    ;*Remove breakpoints, save user registers, return
    4208/    FA67 : =FA67              SWIIN    EQU  *        ;swi entry point
    4209/    FA67 : 30                          TSX           ;user sp -> x
    4210/    FA68 : 9E B2                       LDS  PTR2     ;restore monitor sp
    4211/    FA6A : BD FB 91                    JSR  SAVSTACK ;save user regs
    4212/    FA6D : BD FA B4                    JSR  REMBPS   ;remove breakpoints from code
    4213/    FA70 : DE 60                       LDX  REGS
    4214/    FA72 : 09                          DEX
    4215/    FA73 : DF 60                       STX  REGS     ;save user pc value
    4216/    FA75 :
    4217/    FA75 :                    ;*if(call command) remove call return addr from user stack;
    4218/    FA75 : 7D 00 C1                    TST  TMP2     ;1=go, 0=call
    4219/    FA78 : 26 06                       BNE  GO3      ;jump if go command
    4220/    FA7A : DE 69                       LDX  SP       ;remove return address
    4221/    FA7C : 08                          INX            ; user stack pointer
    4222/    FA7D : 08                          INX
    4223/    FA7E : DF 69                       STX  SP
    4224/    FA80 : BD E4 F5           GO3      JSR  OUTCRLF  ;print register values
    4225/    FA83 : BD E1 F3                    JSR  RPRINT
    4226/    FA86 : 39                          RTS           ;done
    4227/    FA87 :
    4228/    FA87 :                    ;**********
    4229/    FA87 :                    ;*  setbps - Replace user code with swi's at
    4230/    FA87 :                    ;*breakpoint addresses.
    4231/    FA87 :                    ;**********
    4232/    FA87 :                    ;*for(b=0; b=6; b =+ 2)
    4233/    FA87 :                    ;*     x = brktabl[b];
    4234/    FA87 :                    ;*     if(x != 0)
    4235/    FA87 :                    ;*          optabl[b] = x[0];
    4236/    FA87 :                    ;*          x[0] = $3F;
    4237/    FA87 :                    ;*Put monitor SWI vector into jump table
    4238/    FA87 :
    4239/    FA87 : 5F                 SETBPS   CLRB
    4240/    FA88 : CE 00 9C           SETBPS1  LDX  #BRKTABL
    4241/    FA8B : 18 CE 00 B6                 LDY  #PTR4
    4242/    FA8F : 3A                          ABX
    4243/    FA90 : 18 3A                       ABY
    4244/    FA92 : EE 00                       LDX  0,X         ;breakpoint table entry
    4245/    FA94 : 27 0A                       BEQ  SETBPS2     ;jump if 0
    4246/    FA96 : A6 00                       LDAA 0,X         ;save user opcode
    4247/    FA98 : 18 A7 00                    STAA 0,Y
    4248/    FA9B : 86 3F                       LDAA #SWI
    4249/    FA9D : BD E2 8A                    JSR  WRITE       ;insert swi into code
    4250/    FAA0 : CB 02              SETBPS2  ADDB #$2
    4251/    FAA2 : C1 06                       CMPB #$6
    4252/    FAA4 : 2F E2                       BLE  SETBPS1     ;loop 4 times
    4253/    FAA6 : DE F5                       LDX  JSWI+1
    4254/    FAA8 : DF B4                       STX  PTR3        ;save user swi vector
    4255/    FAAA : 86 7E                       LDAA #$7E        ;jmp opcode
    4256/    FAAC : 97 F4                       STAA JSWI
    4257/    FAAE : CE FA 67                    LDX  #SWIIN
    4258/    FAB1 : DF F5                       STX  JSWI+1      ;monitor swi vector
    4259/    FAB3 : 39                          RTS
    4260/    FAB4 :
    4261/    FAB4 :                    ;**********
    4262/    FAB4 :                    ;*   rembps - Remove breakpoints from user code.
    4263/    FAB4 :                    ;**********
    4264/    FAB4 :                    ;*for(b=0; b=6; b =+ 2)
    4265/    FAB4 :                    ;*     x = brktabl[b];
    4266/    FAB4 :                    ;*     if(x != 0)
    4267/    FAB4 :                    ;*          x[0] = optabl[b];
    4268/    FAB4 :                    ;*Replace user's SWI vector
    4269/    FAB4 : 5F                 REMBPS   CLRB
    4270/    FAB5 : CE 00 9C           REMBPS1  LDX  #BRKTABL
    4271/    FAB8 : 18 CE 00 B6                 LDY  #PTR4
    4272/    FABC : 3A                          ABX
    4273/    FABD : 18 3A                       ABY
    4274/    FABF : EE 00                       LDX  0,X         ;breakpoint table entry
    4275/    FAC1 : 27 06                       BEQ  REMBPS2     ;jump if 0
    4276/    FAC3 : 18 A6 00                    LDAA 0,Y
    4277/    FAC6 : BD E2 8A                    JSR  WRITE       ;restore user opcode
    4278/    FAC9 : CB 02              REMBPS2  ADDB #$2
    4279/    FACB : C1 06                       CMPB #$6
    4280/    FACD : 2F E6                       BLE  REMBPS1     ;loop 4 times
    4281/    FACF : DE B4                       LDX  PTR3        ;restore user swi vector
    4282/    FAD1 : DF F5                       STX  JSWI+1
    4283/    FAD3 : 39                          RTS
    4284/    FAD4 :
    4285/    FAD4 :
    4286/    FAD4 :                    ;**********
    4287/    FAD4 :                    ;*   trace <n> - Trace n instructions starting
    4288/    FAD4 :                    ;*at user's pc value. n is a hex number less than
    4289/    FAD4 :                    ;*$FF (defaults to 1).
    4290/    FAD4 :                    ;**********
    4291/    FAD4 :                    ;*a = wskip();
    4292/    FAD4 :                    ;*if(a != cr)
    4293/    FAD4 :                    ;*     a = buffarg(); a = wskip();
    4294/    FAD4 :                    ;*     if(a != cr) return(bad argument);
    4295/    FAD4 :                    ;*     countt1 = n
    4296/    FAD4 : 7F 00 C3           TRACE    CLR  TMP4
    4297/    FAD7 : 7C 00 C3                    INC  TMP4        ;default count=1
    4298/    FADA : 7F 00 A9                    CLR  CHRCNT      ;set up for display
    4299/    FADD : BD E2 FC                    JSR  WSKIP
    4300/    FAE0 : 27 13                       BEQ  TRACE2      ;jump if cr
    4301/    FAE2 : BD E2 34                    JSR  BUFFARG
    4302/    FAE5 : BD E2 FC                    JSR  WSKIP
    4303/    FAE8 : 27 07                       BEQ  TRACE1      ;jump if cr
    4304/    FAEA : CE E6 98                    LDX  #MSG9       ;"bad argument"
    4305/    FAED : BD E5 05                    JSR  OUTSTRG
    4306/    FAF0 : 39                          RTS
    4307/    FAF1 : 96 97              TRACE1   LDAA SHFTREG+1   ;n
    4308/    FAF3 : 97 C3                       STAA TMP4
    4309/    FAF5 :
    4310/    FAF5 :                    ;*Disassemble the line about to be traced
    4311/    FAF5 : =FAF5              TRACE2   EQU  *
    4312/    FAF5 : D6 C3                       LDAB TMP4
    4313/    FAF7 : 37                          PSHB
    4314/    FAF8 : DE 60                       LDX  REGS
    4315/    FAFA : DF B0                       STX  PTR1        ;pc value for disass
    4316/    FAFC : BD F3 63                    JSR  DISASSM
    4317/    FAFF : 33                          PULB
    4318/    FB00 : D7 C3                       STAB TMP4
    4319/    FB02 :
    4320/    FB02 :                    ;*run one instruction
    4321/    FB02 :                    ;*rprint();
    4322/    FB02 :                    ;*while(count > 0) continue trace;
    4323/    FB02 : BD FB 56                    JSR  RUNONE
    4324/    FB05 : BD E3 1F                    JSR  CHKABRT     ;check for abort
    4325/    FB08 : BD E5 25                    JSR  TABTO       ;print registers for
    4326/    FB0B : BD E1 F3                    JSR  RPRINT       ;   result of trace
    4327/    FB0E : 7A 00 C3                    DEC  TMP4
    4328/    FB11 : 27 05                       BEQ  TRACDON     ;quit if count=0
    4329/    FB13 : BD E4 F5           TRACE3   JSR  OUTCRLF
    4330/    FB16 : 20 DD                       BRA  TRACE2
    4331/    FB18 : 39                 TRACDON  RTS
    4332/    FB19 :
    4333/    FB19 :
    4334/    FB19 :                    ;**********
    4335/    FB19 :                    ;*   stopat <addr> - Trace instructions until <addr>
    4336/    FB19 :                    ;*is reached.
    4337/    FB19 :                    ;**********
    4338/    FB19 :                    ;*if((a=wskip) != cr)
    4339/    FB19 :                    ;*     a = buffarg(); a = wskip();
    4340/    FB19 :                    ;*     if(a != cr) return(bad argument);
    4341/    FB19 :                    ;*else return(bad argument);
    4342/    FB19 : =FB19              STOPAT   EQU  *
    4343/    FB19 : BD E2 FC                    JSR  WSKIP
    4344/    FB1C : 27 18                       BEQ  STOPGO    ;jump if cr - no argument
    4345/    FB1E : BD E2 34                    JSR  BUFFARG
    4346/    FB21 : BD E2 FC                    JSR  WSKIP
    4347/    FB24 : 27 07                       BEQ  STOPAT1   ;jump if cr
    4348/    FB26 : CE E6 98                    LDX  #MSG9     ;"bad argument"
    4349/    FB29 : BD E5 05                    JSR  OUTSTRG
    4350/    FB2C : 39                          RTS
    4351/    FB2D : 7D 00 A8           STOPAT1  TST  COUNT
    4352/    FB30 : 27 04                       BEQ  STOPGO    ;jump if no argument
    4353/    FB32 : DE 96                       LDX  SHFTREG
    4354/    FB34 : DF AA                       STX  PTRMEM    ;update "current location"
    4355/    FB36 :
    4356/    FB36 :                    ;*while(!(ptrmem <= userpc < ptrmem+10)) runone();
    4357/    FB36 :                    ;*rprint();
    4358/    FB36 : DC 60              STOPGO   LDD  REGS      ;userpc
    4359/    FB38 : 1A 93 AA                    CPD  PTRMEM
    4360/    FB3B : 25 0A                       BLO  STOPNEXT  ;if(userpc < ptrmem) runone
    4361/    FB3D : DC AA                       LDD  PTRMEM
    4362/    FB3F : C3 00 0A                    ADDD #10
    4363/    FB42 : 1A 93 60                    CPD  REGS
    4364/    FB45 : 22 08                       BHI  STOPDON   ;quit if ptrmem+10 > userpc
    4365/    FB47 : BD FB 56           STOPNEXT JSR  RUNONE
    4366/    FB4A : BD E3 1F                    JSR  CHKABRT   ;check for abort
    4367/    FB4D : 20 E7                       BRA  STOPGO
    4368/    FB4F : BD E4 F5           STOPDON  JSR  OUTCRLF
    4369/    FB52 : BD E1 F3                    JSR  RPRINT    ;result of trace
    4370/    FB55 : 39                          RTS            ;done
    4371/    FB56 :
    4372/    FB56 :
    4373/    FB56 :                    ;*************************
    4374/    FB56 :                    ;* runone - This routine is used by the trace and
    4375/    FB56 :                    ;* execute commands to run one only one user instruction.
    4376/    FB56 :                    ;*   Control is passed to the user code via an RTI.  OC5
    4377/    FB56 :                    ;* is then used to trigger an XIRQ as soon as the first user
    4378/    FB56 :                    ;* opcode is fetched.  Control then returns to the monitor
    4379/    FB56 :                    ;* through XIRQIN.
    4380/    FB56 :                    ;*  Externally, the OC5 pin must be wired to the XIRQ pin.
    4381/    FB56 :                    ;************************
    4382/    FB56 :                    ;* Disable oc5 interrupts
    4383/    FB56 :                    ;* Put monitor XIRQ vector into jump table
    4384/    FB56 :                    ;* Unmask x bit in user ccr
    4385/    FB56 :                    ;* Setup OC5 to go low when first user instruction executed
    4386/    FB56 : =FB56              RUNONE  EQU  *
    4387/    FB56 : 86 7E                      LDAA #$7E        ;put "jmp xirqin" in jump table
    4388/    FB58 : 97 D3                      STAA JTOC5
    4389/    FB5A : CE FB 8E                   LDX  #XIRQIN
    4390/    FB5D : DF F2                      STX  JXIRQ+1
    4391/    FB5F : 96 68                      LDAA REGS+8      ;x bit will be cleared when
    4392/    FB61 : 84 BF                      ANDA #$BF         ;   rti is executed below
    4393/    FB63 : 97 68                      STAA REGS+8
    4394/    FB65 : C6 57                      LDAB #87        ;cycles to end of rti
    4395/    FB67 : DE 0E                      LDX  TCNT
    4396/    FB69 : 3A                         ABX             ;                        3~ \
    4397/    FB6A : DF 1E                      STX  TOC5       ;oc5 match register      5~  \
    4398/    FB6C : 96 20                      LDAA TCTL1      ;                        4~   \
    4399/    FB6E : 84 FE                      ANDA #$FE       ;set up oc5 low on match 2~    \
    4400/    FB70 : 97 20                      STAA TCTL1      ;enable oc5 interrupt    4~    / 86~
    4401/    FB72 :
    4402/    FB72 :                    ;** RESTACK - Restore user stack and RTI to user code.
    4403/    FB72 :                    ;* This code is the pathway to execution of user code.
    4404/    FB72 :                    ;*(Force extended addressing to maintain cycle count)
    4405/    FB72 :                    ;*Restore user stack and rti to user code
    4406/    FB72 : =FB72              RESTACK EQU  *                                 ;68~
    4407/    FB72 : BF 00 B2                   STS  >PTR2      ;save monitor sp
    4408/    FB75 : BE 00 69                   LDS  >SP        ;user stack pointer
    4409/    FB78 : FE 00 60                   LDX  >REGS
    4410/    FB7B : 3C                         PSHX            ;pc
    4411/    FB7C : FE 00 62                   LDX  >REGS+2
    4412/    FB7F : 3C                         PSHX            ;y
    4413/    FB80 : FE 00 64                   LDX  >REGS+4
    4414/    FB83 : 3C                         PSHX            ;x
    4415/    FB84 : FC 00 66                   LDD  >REGS+6
    4416/    FB87 : 36                         PSHA            ;a
    4417/    FB88 : 37                         PSHB            ;b
    4418/    FB89 : B6 00 68                   LDAA >REGS+8
    4419/    FB8C : 36                         PSHA            ;ccr
    4420/    FB8D : 3B                         RTI
    4421/    FB8E :
    4422/    FB8E :                    ;** Return here from run one line of user code.
    4423/    FB8E : =FB8E              XIRQIN  EQU  *
    4424/    FB8E : 30                         TSX             ;user sp -> x
    4425/    FB8F : 9E B2                      LDS  PTR2       ;restore monitor sp
    4426/    FB91 :
    4427/    FB91 :                    ;** SAVSTACK - Save user's registers.
    4428/    FB91 :                    ;* On entry - x points to top of user stack.
    4429/    FB91 : =FB91              SAVSTACK EQU *
    4430/    FB91 : A6 00                      LDAA 0,X
    4431/    FB93 : 97 68                      STAA REGS+8      ;user ccr
    4432/    FB95 : EC 01                      LDD  1,X
    4433/    FB97 : 97 67                      STAA REGS+7      ;b
    4434/    FB99 : D7 66                      STAB REGS+6      ;a
    4435/    FB9B : EC 03                      LDD  3,X
    4436/    FB9D : DD 64                      STD  REGS+4      ;x
    4437/    FB9F : EC 05                      LDD  5,X
    4438/    FBA1 : DD 62                      STD  REGS+2      ;y
    4439/    FBA3 : EC 07                      LDD  7,X
    4440/    FBA5 : DD 60                      STD  REGS        ;pc
    4441/    FBA7 : C6 08                      LDAB #8
    4442/    FBA9 : 3A                         ABX
    4443/    FBAA : DF 69                      STX  SP          ;user stack pointer
    4444/    FBAC : 96 20                      LDAA TCTL1       ;force oc5 pin high which
    4445/    FBAE : 8A 03                      ORAA #$03        ;  is tied to xirq line
    4446/    FBB0 : 97 20                      STAA TCTL1
    4447/    FBB2 : 86 08                      LDAA #$08
    4448/    FBB4 : 97 0B                      STAA CFORC
    4449/    FBB6 : 39                         RTS
    4450/    FBB7 :
    4451/    FBB7 :
    4452/    FBB7 :                    ;**********
    4453/    FBB7 :                    ;*   HOST() - Establishes transparent link between
    4454/    FBB7 :                    ;*       terminal and host.  Port used for host is
    4455/    FBB7 :                    ;*       determined in the reset initialization routine
    4456/    FBB7 :                    ;*       and stored in HOSTDEV.
    4457/    FBB7 :                    ;*          To exit type control A.
    4458/    FBB7 :                    ;*          To send break to host type control B.
    4459/    FBB7 :                    ;*if(no external device) return;
    4460/    FBB7 :                    ;*initialize host port;
    4461/    FBB7 :                    ;*While( !(control A))
    4462/    FBB7 :                    ;*     input(terminal); output(host);
    4463/    FBB7 :                    ;*     input(host); output(terminal);
    4464/    FBB7 :
    4465/    FBB7 : 96 A6              HOST      LDAA EXTDEV
    4466/    FBB9 : 26 07                        BNE  HOST0    ;jump if host port avail.
    4467/    FBBB : CE E6 A5                     LDX  #MSG10   ;"no host port avail"
    4468/    FBBE : BD E5 05                     JSR  OUTSTRG
    4469/    FBC1 : 39                           RTS
    4470/    FBC2 : 7F 00 A4           HOST0     CLR  AUTOLF    ;turn off autolf
    4471/    FBC5 : BD E3 3D                     JSR  HOSTCO    ;connect sci (evb board)
    4472/    FBC8 : BD FC 27                     JSR  HOSTINIT  ;initialize host port
    4473/    FBCB : BD E3 94           HOST1     JSR  INPUT     ;read terminal
    4474/    FBCE : 4D                           TSTA
    4475/    FBCF : 27 10                        BEQ  HOST3     ;jump if no char
    4476/    FBD1 : 81 01                        CMPA #CTLA
    4477/    FBD3 : 27 17                        BEQ  HOSTEND   ;jump if control a
    4478/    FBD5 : 81 02                        CMPA #CTLB
    4479/    FBD7 : 26 05                        BNE  HOST2     ;jump if not control b
    4480/    FBD9 : BD FB F3                     JSR  TXBREAK   ;send break to host
    4481/    FBDC : 20 03                        BRA  HOST3
    4482/    FBDE : BD FC 3F           HOST2     JSR  HOSTOUT   ;echo to host
    4483/    FBE1 : BD FC 33           HOST3     JSR  HOSTIN    ;read host
    4484/    FBE4 : 4D                           TSTA
    4485/    FBE5 : 27 E4                        BEQ  HOST1     ;jump if no char
    4486/    FBE7 : BD E3 BE                     JSR  OUTPUT    ;echo to terminal
    4487/    FBEA : 20 DF                        BRA  HOST1
    4488/    FBEC : 7C 00 A4           HOSTEND   INC  AUTOLF    ;turn on autolf
    4489/    FBEF : BD E3 45                     JSR  TARGCO    ;disconnect sci (evb board)
    4490/    FBF2 : 39                           RTS            ;return
    4491/    FBF3 :
    4492/    FBF3 :                    ;**********
    4493/    FBF3 :                    ;* txbreak() - transmit break to host port.
    4494/    FBF3 :                    ;* The duration of the transmitted break is
    4495/    FBF3 :                    ;* approximately 200,000 E-clock cycles, or
    4496/    FBF3 :                    ;* 100ms at 2.0 MHz.
    4497/    FBF3 :                    ;***********
    4498/    FBF3 : =FBF3              TXBREAK   EQU  *
    4499/    FBF3 : 96 A7                        LDAA HOSTDEV
    4500/    FBF5 : 81 03                        CMPA #$03
    4501/    FBF7 : 27 0D                        BEQ  TXBDU    ;jump if duartb is host
    4502/    FBF9 :
    4503/    FBF9 : CE 00 2D           TXBSCI    LDX  #SCCR2   ;sci is host
    4504/    FBFC : 1C 00 01                     BSET 0,X,#01  ;set send break bit
    4505/    FBFF : 8D 1D                        BSR  TXBWAIT
    4506/    FC01 : 1D 00 01                     BCLR 0,X,#01  ;clear send break bit
    4507/    FC04 : 20 0D                        BRA TXB1
    4508/    FC06 :
    4509/    FC06 : CE D0 08           TXBDU     LDX  #PORTB   ;duart host port
    4510/    FC09 : 86 60                        LDAA #$60     ;start break cmd
    4511/    FC0B : A7 02                        STAA 2,X      ;port b command register
    4512/    FC0D : 8D 0F                        BSR  TXBWAIT
    4513/    FC0F : 86 70                        LDAA #$70     ;stop break cmd
    4514/    FC11 : A7 02                        STAA 2,X      ;port b command register
    4515/    FC13 :
    4516/    FC13 : 86 0D              TXB1      LDAA #$0D
    4517/    FC15 : BD FC 3F                     JSR  HOSTOUT  ;send carriage return
    4518/    FC18 : 86 0A                        LDAA #$0A
    4519/    FC1A : BD FC 3F                     JSR  HOSTOUT  ;send linefeed
    4520/    FC1D : 39                           RTS
    4521/    FC1E :
    4522/    FC1E : 18 CE 6F 9B        TXBWAIT   LDY  #$6F9B   ;loop count = 28571
    4523/    FC22 : 18 09              TXBWAIT1  DEY           ;7 cycle loop
    4524/    FC24 : 26 FC                        BNE  TXBWAIT1
    4525/    FC26 : 39                           RTS
    4526/    FC27 :
    4527/    FC27 :
    4528/    FC27 :                    ;**********
    4529/    FC27 :                    ;*   hostinit(), hostin(), hostout() - host i/o
    4530/    FC27 :                    ;*routines.  Restores original terminal device.
    4531/    FC27 :                    ;**********
    4532/    FC27 : D6 A5              HOSTINIT  LDAB IODEV    ;save terminal
    4533/    FC29 : 37                           PSHB
    4534/    FC2A : D6 A7                        LDAB HOSTDEV
    4535/    FC2C : D7 A5                        STAB IODEV    ;point to host
    4536/    FC2E : BD E3 6E                     JSR  INIT     ;initialize host
    4537/    FC31 : 20 16                        BRA  TERMRES  ;restore terminal
    4538/    FC33 : D6 A5              HOSTIN    LDAB IODEV    ;save terminal
    4539/    FC35 : 37                           PSHB
    4540/    FC36 : D6 A7                        LDAB HOSTDEV
    4541/    FC38 : D7 A5                        STAB IODEV    ;point to host
    4542/    FC3A : BD E3 94                     JSR  INPUT    ;read host
    4543/    FC3D : 20 0A                        BRA  TERMRES  ;restore terminal
    4544/    FC3F : D6 A5              HOSTOUT   LDAB IODEV    ;save terminal
    4545/    FC41 : 37                           PSHB
    4546/    FC42 : D6 A7                        LDAB HOSTDEV
    4547/    FC44 : D7 A5                        STAB IODEV    ;point to host
    4548/    FC46 : BD E3 BE                     JSR  OUTPUT   ;write to host
    4549/    FC49 : 33                 TERMRES   PULB          ;restore terminal device
    4550/    FC4A : D7 A5                        STAB IODEV
    4551/    FC4C : 39                           RTS
    4552/    FC4D :
    4553/    FC4D :
    4554/    FC4D :                    ;**********
    4555/    FC4D :                    ;*   load(ptrbuff[]) - Load s1/s9 records from
    4556/    FC4D :                    ;*host to memory.  Ptrbuff[] points to string in
    4557/    FC4D :                    ;*input buffer which is a command to output s1/s9
    4558/    FC4D :                    ;*records from the host ("cat filename" for unix).
    4559/    FC4D :                    ;*    Returns error and address if it can't write
    4560/    FC4D :                    ;*to a particular location.
    4561/    FC4D :                    ;**********
    4562/    FC4D :                    ;*   verify(ptrbuff[]) - Verify memory from load
    4563/    FC4D :                    ;*command.  Ptrbuff[] is same as for load.
    4564/    FC4D :                    ;* tmp3 is used as an error indication, 0=no errors,
    4565/    FC4D :                    ;* 1=receiver, 2=rom error, 3=checksum error.
    4566/    FC4D :                    ;**********
    4567/    FC4D : 7F 00 C1           VERIFY    CLR  TMP2
    4568/    FC50 : 7C 00 C1                     INC  TMP2      ;TMP2=1=verify
    4569/    FC53 : 20 03                        BRA  LOAD1
    4570/    FC55 : 7F 00 C1           LOAD      CLR  TMP2       ;    0=load
    4571/    FC58 :
    4572/    FC58 :                    ;*a=wskip();
    4573/    FC58 :                    ;*if(a = cr) goto transparent mode;
    4574/    FC58 :                    ;*if(t option) hostdev = iodev;
    4575/    FC58 : =FC58              LOAD1     EQU  *
    4576/    FC58 : 7F 00 C2                     CLR  TMP3      ;clear error flag
    4577/    FC5B : BD E2 FC                     JSR  WSKIP
    4578/    FC5E : 26 03                        BNE  LOAD2
    4579/    FC60 : 7E FB B7                     JMP  HOST      ;go to host if no args
    4580/    FC63 : BD E1 A7           LOAD2     JSR  UPCASE
    4581/    FC66 : 81 54                        CMPA #'T'      ;look for t option
    4582/    FC68 : 26 16                        BNE  LOAD3     ;jump not t option
    4583/    FC6A : BD E2 EE                     JSR  INCBUFF
    4584/    FC6D : BD E2 E7                     JSR  READBUFF  ;get next character
    4585/    FC70 : BD E2 F4                     JSR  DECBUFF
    4586/    FC73 : 81 0D                        CMPA #$0D
    4587/    FC75 : 26 09                        BNE  LOAD3     ;jump if not t option
    4588/    FC77 : 7F 00 A4                     CLR  AUTOLF
    4589/    FC7A : 96 A5                        LDAA IODEV
    4590/    FC7C : 97 A7                        STAA HOSTDEV   ;set host port = terminal
    4591/    FC7E : 20 1B                        BRA  LOAD10    ;go wait for s1 records
    4592/    FC80 :
    4593/    FC80 :                    ;*else while(not cr)
    4594/    FC80 :                    ;*     read character from input buffer;
    4595/    FC80 :                    ;*     send character to host;
    4596/    FC80 : 7F 00 A4           LOAD3     CLR  AUTOLF
    4597/    FC83 : BD E3 3D                     JSR  HOSTCO    ;connect sci (evb board)
    4598/    FC86 : BD FC 27                     JSR  HOSTINIT  ;initialize host port
    4599/    FC89 : BD E2 E7           LOAD4     JSR  READBUFF  ;get next char
    4600/    FC8C : BD E2 EE                     JSR  INCBUFF
    4601/    FC8F : 36                           PSHA           ;save char
    4602/    FC90 : BD FC 3F                     JSR  HOSTOUT   ;output to host
    4603/    FC93 : BD E3 BE                     JSR  OUTPUT    ;echo to terminal
    4604/    FC96 : 32                           PULA
    4605/    FC97 : 81 0D                        CMPA #$0D
    4606/    FC99 : 26 EE                        BNE  LOAD4     ;jump if not cr
    4607/    FC9B :
    4608/    FC9B :                    ;*repeat:                           /* look for s records */
    4609/    FC9B :                    ;*      if(hostdev != iodev) check abort;
    4610/    FC9B :                    ;*      a = hostin();
    4611/    FC9B :                    ;*      if(a = 'S')
    4612/    FC9B :                    ;*          a = hostin;
    4613/    FC9B :                    ;*          if(a = '1')
    4614/    FC9B :                    ;*              checksum = 0;
    4615/    FC9B :                    ;*              get byte count in b;
    4616/    FC9B :                    ;*              get base address in x;
    4617/    FC9B :                    ;*              while(byte count > 0)
    4618/    FC9B :                    ;*                  byte();
    4619/    FC9B :                    ;*                  x++; b--;
    4620/    FC9B :                    ;*                  if(tmp3=0)           /* no error */
    4621/    FC9B :                    ;*                      if(load) x[0] = shftreg+1;
    4622/    FC9B :                    ;*                      if(x[0] != shftreg+1)
    4623/    FC9B :                    ;*                          tmp3 = 2;    /* rom error */
    4624/    FC9B :                    ;*                          ptr3 = x;    /* save address */
    4625/    FC9B :                    ;*              if(tmp3 = 0) do checksum;
    4626/    FC9B :                    ;*              if(checksum err) tmp3 = 3; /* checksum error */
    4627/    FC9B :                    ;** Look for s-record header
    4628/    FC9B : =FC9B              LOAD10    EQU  *
    4629/    FC9B : 96 A7                        LDAA HOSTDEV
    4630/    FC9D : 91 A5                        CMPA IODEV
    4631/    FC9F : 27 03                        BEQ  LOAD11    ;jump if hostdev=iodev
    4632/    FCA1 : BD E3 1F                     JSR  CHKABRT   ;check for abort
    4633/    FCA4 : BD FC 33           LOAD11    JSR  HOSTIN    ;read host
    4634/    FCA7 : 4D                           TSTA
    4635/    FCA8 : 27 F1                        BEQ  LOAD10    ;jump if no input
    4636/    FCAA : 81 53                        CMPA #'S'
    4637/    FCAC : 26 ED                        BNE  LOAD10    ;jump if not S
    4638/    FCAE : BD FC 33           LOAD12    JSR  HOSTIN    ;read host
    4639/    FCB1 : 4D                           TSTA
    4640/    FCB2 : 27 FA                        BEQ  LOAD12    ;jump if no input
    4641/    FCB4 : 81 39                        CMPA #'9'
    4642/    FCB6 : 27 4E                        BEQ  LOAD90    ;jump if S9 record
    4643/    FCB8 : 81 31                        CMPA #'1'
    4644/    FCBA : 26 DF                        BNE  LOAD10    ;jump if not S1
    4645/    FCBC : 7F 00 C3                     CLR  TMP4      ;clear checksum
    4646/    FCBF :                    ;** Get Byte Count and Starting Address
    4647/    FCBF : BD FD 4C                     JSR  BYTE
    4648/    FCC2 : D6 97                        LDAB SHFTREG+1
    4649/    FCC4 : C0 02                        SUBB #$2       ;b = byte count
    4650/    FCC6 : BD FD 4C                     JSR  BYTE
    4651/    FCC9 : BD FD 4C                     JSR  BYTE
    4652/    FCCC : 37                           PSHB           ;save byte count
    4653/    FCCD : DC 96                        LDD  SHFTREG
    4654/    FCCF : D3 AC                        ADDD LDOFFST   ;add offset
    4655/    FCD1 : 8F                           XGDX           ;x = address+offset
    4656/    FCD2 : 33                           PULB           ;restore byte count
    4657/    FCD3 : 09                           DEX            ;condition for loop
    4658/    FCD4 :                    ;** Get and Store Incoming Data Byte
    4659/    FCD4 : BD FD 4C           LOAD20    JSR  BYTE      ;get next byte
    4660/    FCD7 : 08                           INX
    4661/    FCD8 : 5A                           DECB           ;check byte count
    4662/    FCD9 : 27 1B                        BEQ  LOAD30    ;if b=0, go do checksum
    4663/    FCDB : 7D 00 C2                     TST  TMP3
    4664/    FCDE : 26 BB                        BNE  LOAD10    ;jump if error flagged
    4665/    FCE0 : 7D 00 C1                     TST  TMP2
    4666/    FCE3 : 26 05                        BNE  LOAD21    ;jump if verify
    4667/    FCE5 : 96 97                        LDAA SHFTREG+1
    4668/    FCE7 : BD E2 8A                     JSR  WRITE     ;load only
    4669/    FCEA : A1 00              LOAD21    CMPA 0,X       ;verify ram location
    4670/    FCEC : 27 E6                        BEQ  LOAD20    ;jump if ram ok
    4671/    FCEE : 86 02                        LDAA #$02
    4672/    FCF0 : 97 C2                        STAA TMP3      ;indicate rom error
    4673/    FCF2 : DF B4                        STX  PTR3      ;save error address
    4674/    FCF4 : 20 DE                        BRA  LOAD20    ;finish download
    4675/    FCF6 :                    ;** Get and Test Checksum
    4676/    FCF6 : 7D 00 C2           LOAD30    TST  TMP3
    4677/    FCF9 : 26 A0                        BNE  LOAD10    ;jump if error already
    4678/    FCFB : 96 C3                        LDAA TMP4
    4679/    FCFD : 4C                           INCA           ;do checksum
    4680/    FCFE : 27 9B                        BEQ  LOAD10    ;jump if s1 record okay
    4681/    FD00 : 86 03                        LDAA #$03
    4682/    FD02 : 97 C2                        STAA TMP3      ;indicate checksum error
    4683/    FD04 : 20 95                        BRA  LOAD10
    4684/    FD06 :
    4685/    FD06 :                    ;*          if(a = '9')
    4686/    FD06 :                    ;*              read rest of record;
    4687/    FD06 :                    ;*              if(tmp3=2) return("[ptr3]");
    4688/    FD06 :                    ;*              if(tmp3=1) return("rcv error");
    4689/    FD06 :                    ;*              if(tmp3=3) return("checksum err");
    4690/    FD06 :                    ;*              else return("done");
    4691/    FD06 : BD FD 4C           LOAD90    JSR  BYTE
    4692/    FD09 : D6 97                        LDAB SHFTREG+1 ;b = byte count
    4693/    FD0B : BD FD 4C           LOAD91    JSR  BYTE
    4694/    FD0E : 5A                           DECB
    4695/    FD0F : 26 FA                        BNE  LOAD91    ;loop until end of record
    4696/    FD11 : C6 64                        LDAB #$64
    4697/    FD13 : BD E2 DB           LOAD91A   JSR  DLY10MS   ;delay 1 sec -let host finish
    4698/    FD16 : 5A                           DECB
    4699/    FD17 : 26 FA                        BNE  LOAD91A
    4700/    FD19 : BD E3 94                     JSR  INPUT     ;clear comm device
    4701/    FD1C : CC 7E 0D                     LDD  #$7E0D    ;put dummy command in inbuff
    4702/    FD1F : DD 6B                        STD  INBUFF
    4703/    FD21 : 7C 00 A4                     INC  AUTOLF    ;turn on autolf
    4704/    FD24 : BD E3 45                     JSR  TARGCO    ;disconnect sci (evb)
    4705/    FD27 : CE E6 B2                     LDX  #MSG11    ;"done" default msg
    4706/    FD2A : 96 C2                        LDAA TMP3
    4707/    FD2C : 81 02                        CMPA #$02
    4708/    FD2E : 26 08                        BNE  LOAD92    ;jump not rom error
    4709/    FD30 : CE 00 B4                     LDX  #PTR3
    4710/    FD33 : BD E4 E9                     JSR  OUT2BSP   ;address of rom error
    4711/    FD36 : 20 13                        BRA  LOAD95
    4712/    FD38 : 81 01              LOAD92    CMPA #$01
    4713/    FD3A : 26 05                        BNE  LOAD93    ;jump not rcv error
    4714/    FD3C : CE E6 D0                     LDX  #MSG14    ;"rcv error"
    4715/    FD3F : 20 07                        BRA  LOAD94
    4716/    FD41 : 81 03              LOAD93    CMPA #$03
    4717/    FD43 : 26 03                        BNE  LOAD94    ;jump not checksum error
    4718/    FD45 : CE E6 B7                     LDX  #MSG12    ;"checksum error"
    4719/    FD48 : BD E5 05           LOAD94    JSR  OUTSTRG
    4720/    FD4B : 39                 LOAD95    RTS
    4721/    FD4C :
    4722/    FD4C :
    4723/    FD4C :                    ;**********
    4724/    FD4C :                    ;*  byte() -  Read 2 ascii bytes from host and
    4725/    FD4C :                    ;*convert to one hex byte.  Returns byte
    4726/    FD4C :                    ;*shifted into shftreg and added to tmp4.
    4727/    FD4C :                    ;**********
    4728/    FD4C : 37                 BYTE      PSHB
    4729/    FD4D : 3C                           PSHX
    4730/    FD4E : BD FC 33           BYTE0     JSR  HOSTIN    ;read host (1st byte)
    4731/    FD51 : 4D                           TSTA
    4732/    FD52 : 27 FA                        BEQ  BYTE0     ;loop until input
    4733/    FD54 : BD E2 01                     JSR  HEXBIN
    4734/    FD57 : BD FC 33           BYTE1     JSR  HOSTIN    ;read host (2nd byte)
    4735/    FD5A : 4D                           TSTA
    4736/    FD5B : 27 FA                        BEQ  BYTE1     ;loop until input
    4737/    FD5D : BD E2 01                     JSR  HEXBIN
    4738/    FD60 : 96 97                        LDAA SHFTREG+1
    4739/    FD62 : 9B C3                        ADDA TMP4
    4740/    FD64 : 97 C3                        STAA TMP4      ;add to checksum
    4741/    FD66 : 38                           PULX
    4742/    FD67 : 33                           PULB
    4743/    FD68 : 39                           RTS
    4744/    FD69 :
    4745/    FD69 :
    4746/    FD69 :                    ;**********
    4747/    FD69 :                    ;*   offset [<addr>]
    4748/    FD69 :                    ;* Specify offset to be added to s-record address when
    4749/    FD69 :                    ;* downloading from the host.
    4750/    FD69 :                    ;*  OFFSET                -show the current offset
    4751/    FD69 :                    ;*  OFFSET <data>         -current offset = data
    4752/    FD69 :                    ;*  OFFSET -<data>        -current offset = 0 - data
    4753/    FD69 :                    ;**********
    4754/    FD69 :                    ;*if(<data>) then offset = data;
    4755/    FD69 :                    ;*print(offset);
    4756/    FD69 : =FD69              OFFSET   EQU  *
    4757/    FD69 : 7F 00 C3                    CLR  TMP4      ;minus indicator
    4758/    FD6C : BD E2 FC                    JSR  WSKIP
    4759/    FD6F : 27 28                       BEQ  OFFST3    ;jump if cr (no argument)
    4760/    FD71 : 81 2D                       CMPA #'-'
    4761/    FD73 : 26 09                       BNE  OFFST1    ;jump not -
    4762/    FD75 : 7C 00 C3                    INC  TMP4      ;set minus sign flag
    4763/    FD78 : BD E2 EE                    JSR  INCBUFF   ;move buffer pointer
    4764/    FD7B : BD E2 FC                    JSR  WSKIP
    4765/    FD7E : BD E2 34           OFFST1   JSR  BUFFARG   ;read argument
    4766/    FD81 : 7D 00 A8                    TST  COUNT
    4767/    FD84 : 27 1D                       BEQ  OFFSTER  ;jump if bad argument
    4768/    FD86 : BD E2 FC                    JSR  WSKIP
    4769/    FD89 : 26 18                       BNE  OFFSTER   ;jump if not cr
    4770/    FD8B : DC 96                       LDD  SHFTREG   ;get offset value
    4771/    FD8D : 7D 00 C3                    TST  TMP4
    4772/    FD90 : 27 05                       BEQ  OFFST2    ;jump if positive
    4773/    FD92 : CC 00 00                    LDD  #$0000    ;negative - sub from 0
    4774/    FD95 : 93 96                       SUBD SHFTREG
    4775/    FD97 : DD AC              OFFST2   STD  LDOFFST
    4776/    FD99 : BD E4 F5           OFFST3   JSR  OUTCRLF   ;display current offset
    4777/    FD9C : CE 00 AC                    LDX  #LDOFFST
    4778/    FD9F : BD E4 E9                    JSR  OUT2BSP
    4779/    FDA2 : 39                          RTS
    4780/    FDA3 :
    4781/    FDA3 : CE E6 98           OFFSTER  LDX  #MSG9     ;"bad argument"
    4782/    FDA6 : BD E5 05                    JSR  OUTSTRG
    4783/    FDA9 : 39                          RTS
    4784/    FDAA :
    4785/    FDAA :
    4786/    FDAA :
    4787/    FDAA :
    4788/    FDAA :
    4789/    FDAA :                    ;**********
    4790/    FDAA :                    ;*   register [<name>]  - prints the user regs
    4791/    FDAA :                    ;*and opens them for modification.  <name> is
    4792/    FDAA :                    ;*the first register opened (default = P).
    4793/    FDAA :                    ;*   Subcommands:
    4794/    FDAA :                    ;* [<nn>]<space>  Opens the next register.
    4795/    FDAA :                    ;* [<nn>]<cr>     Return.
    4796/    FDAA :                    ;*    The register value is only changed if
    4797/    FDAA :                    ;*    <nn> is entered before the subcommand.
    4798/    FDAA :                    ;**********
    4799/    FDAA :                    ;*x[] = reglist
    4800/    FDAA :                    ;*a = wskip(); a = upcase(a);
    4801/    FDAA :                    ;*if(a != cr)
    4802/    FDAA :                    ;*     while( a != x[0] )
    4803/    FDAA :                    ;*          if( x[0] = "s") return(bad argument);
    4804/    FDAA :                    ;*          x[]++;
    4805/    FDAA :                    ;*     incbuff(); a = wskip();
    4806/    FDAA :                    ;*     if(a != cr) return(bad argument);
    4807/    FDAA :
    4808/    FDAA : CE E1 BE           REGISTER LDX  #REGLIST
    4809/    FDAD : BD E2 FC                    JSR  WSKIP      ; a = first char of arg
    4810/    FDB0 : BD E1 A7                    JSR  UPCASE      ;convert to upper case
    4811/    FDB3 : 81 0D                       CMPA #$D
    4812/    FDB5 : 27 1C                       BEQ  REG4        ;jump if no argument
    4813/    FDB7 : A1 00              REG1     CMPA 0,X
    4814/    FDB9 : 27 0E                       BEQ  REG3
    4815/    FDBB : E6 00                       LDAB 0,X
    4816/    FDBD : 08                          INX
    4817/    FDBE : C1 53                       CMPB #'S'
    4818/    FDC0 : 26 F5                       BNE  REG1        ;jump if not "s"
    4819/    FDC2 : CE E6 98           REG2     LDX  #MSG9       ;"bad argument"
    4820/    FDC5 : BD E5 05                    JSR  OUTSTRG
    4821/    FDC8 : 39                          RTS
    4822/    FDC9 : 3C                 REG3     PSHX
    4823/    FDCA : BD E2 EE                    JSR  INCBUFF
    4824/    FDCD : BD E2 FC                    JSR  WSKIP       ;next char after arg
    4825/    FDD0 : 38                          PULX
    4826/    FDD1 : 26 EF                       BNE  REG2        ;jump if not cr
    4827/    FDD3 :
    4828/    FDD3 :                    ;*rprint();
    4829/    FDD3 :                    ;*     while(x[0] != "s")
    4830/    FDD3 :                    ;*          rprnt1(x);
    4831/    FDD3 :                    ;*          a = termarg();    /* read from terminal */
    4832/    FDD3 :                    ;*          if( ! dchek(a) ) return(bad argument);
    4833/    FDD3 :                    ;*          if(countu1 != 0)
    4834/    FDD3 :                    ;*               if(x[14] = 1)
    4835/    FDD3 :                    ;*                    regs[x[7]++ = shftreg;
    4836/    FDD3 :                    ;*               regs[x[7]] = shftreg+1;
    4837/    FDD3 :                    ;*          if(a = cr) break;
    4838/    FDD3 :                    ;*return;
    4839/    FDD3 :
    4840/    FDD3 : BD E1 F3           REG4     JSR  RPRINT      ;print all registers
    4841/    FDD6 : BD E4 F5           REG5     JSR  OUTCRLF
    4842/    FDD9 : BD E1 D3                    JSR  RPRNT1      ;print reg name
    4843/    FDDC : 7F 00 96                    CLR  SHFTREG
    4844/    FDDF : 7F 00 97                    CLR  SHFTREG+1
    4845/    FDE2 : BD E2 57                    JSR  TERMARG     ;read subcommand
    4846/    FDE5 : BD E3 17                    JSR  DCHEK
    4847/    FDE8 : 27 07                       BEQ  REG6        ;jump if delimeter
    4848/    FDEA : CE E6 98                    LDX  #MSG9       ;"bad argument"
    4849/    FDED : BD E5 05                    JSR  OUTSTRG
    4850/    FDF0 : 39                          RTS
    4851/    FDF1 : 36                 REG6     PSHA
    4852/    FDF2 : 3C                          PSHX
    4853/    FDF3 : 7D 00 A8                    TST  COUNT
    4854/    FDF6 : 27 14                       BEQ  REG8        ;jump if no input
    4855/    FDF8 : E6 07                       LDAB 7,X         ;get reg offset
    4856/    FDFA : A6 0E                       LDAA 14,X        ;byte size
    4857/    FDFC : CE 00 60                    LDX  #REGS       ;user registers
    4858/    FDFF : 3A                          ABX
    4859/    FE00 : 4D                          TSTA
    4860/    FE01 : 27 05                       BEQ  REG7        ;jump if 1 byte reg
    4861/    FE03 : 96 96                       LDAA SHFTREG
    4862/    FE05 : A7 00                       STAA 0,X         ;put in top byte
    4863/    FE07 : 08                          INX
    4864/    FE08 : 96 97              REG7     LDAA SHFTREG+1
    4865/    FE0A : A7 00                       STAA 0,X         ;put in bottom byte
    4866/    FE0C : 38                 REG8     PULX
    4867/    FE0D : 32                          PULA
    4868/    FE0E : E6 00                       LDAB 0,X         ;CHECK FOR REGISTER S
    4869/    FE10 : C1 53                       CMPB #'S'
    4870/    FE12 : 27 05                       BEQ  REG9        ;jump if "s"
    4871/    FE14 : 08                          INX              ;point to next register
    4872/    FE15 : 81 0D                       CMPA #$D
    4873/    FE17 : 26 BD                       BNE  REG5        ;jump if not cr
    4874/    FE19 : 39                 REG9     RTS
    4875/    FE1A :
    4876/    FE1A :
    4877/    FE1A :                    ;* Equates
    4878/    FE1A : =8                 JPORTD  EQU   $08
    4879/    FE1A : =9                 JDDRD   EQU   $09
    4880/    FE1A : =2B                JBAUD   EQU   $2B
    4881/    FE1A : =2C                JSCCR1  EQU   $2C
    4882/    FE1A : =2D                JSCCR2  EQU   $2D
    4883/    FE1A : =2E                JSCSR   EQU   $2E
    4884/    FE1A : =2F                JSCDAT  EQU   $2F
    4885/    FE1A :                    ;*
    4886/    FE1A :
    4887/    FE1A :                    ;************
    4888/    FE1A :                    ;*  xboot [<addr1> [<addr2>]] - Use SCI to talk to an 'hc11 in
    4889/    FE1A :                    ;* boot mode.  Downloads bytes from addr1 thru addr2.
    4890/    FE1A :                    ;* Default addr1 = $C000 and addr2 = $C0ff.
    4891/    FE1A :                    ;*
    4892/    FE1A :                    ;* IMPORTANT:
    4893/    FE1A :                    ;* if talking to an 'A8 or 'A2: use either default addresses or ONLY
    4894/    FE1A :                    ;*    addr1 - this sends 256 bytes
    4895/    FE1A :                    ;* if talking to an 'E9: include BOTH addr1 and addr2 for variable
    4896/    FE1A :                    ;*    length
    4897/    FE1A :                    ;************
    4898/    FE1A :
    4899/    FE1A :                    ;*Get arguments
    4900/    FE1A :                    ;*If no args, default $C000
    4901/    FE1A : BD E2 FC           BOOT    JSR   WSKIP
    4902/    FE1D : 26 0B                      BNE   BOT1       ;jump if arguments
    4903/    FE1F : CE C0 FF                   LDX   #$C0FF     ;addr2 default
    4904/    FE22 : DF B8                      STX   PTR5
    4905/    FE24 : 18 CE C0 00                LDY   #$C000     ;addr1 default
    4906/    FE28 : 20 36                      BRA   BOT2       ;go - use default address
    4907/    FE2A :
    4908/    FE2A :                    ;*Else get arguments
    4909/    FE2A : BD E2 34           BOT1    JSR   BUFFARG
    4910/    FE2D : 7D 00 A8                   TST   COUNT
    4911/    FE30 : 27 27                      BEQ   BOTERR    ;jump if no address
    4912/    FE32 : 18 DE 96                   LDY   SHFTREG   ;start address (addr1)
    4913/    FE35 : BD E2 FC                   JSR   WSKIP
    4914/    FE38 : 26 0C                      BNE   BOT1A     ;go get addr2
    4915/    FE3A : 18 DF B8                   STY   PTR5      ;default addr2...
    4916/    FE3D : DC B8                      LDD   PTR5      ;...by taking addr1...
    4917/    FE3F : C3 00 FF                   ADDD  #$FF      ;...and adding 255 to it...
    4918/    FE42 : DD B8                      STD   PTR5      ;...for a total download of 256
    4919/    FE44 : 20 1A                      BRA   BOT2      ;continue
    4920/    FE46 :                    ;*
    4921/    FE46 : BD E2 34           BOT1A   JSR   BUFFARG
    4922/    FE49 : 7D 00 A8                   TST   COUNT
    4923/    FE4C : 27 0B                      BEQ   BOTERR    ;jump if no address
    4924/    FE4E : DE 96                      LDX   SHFTREG   ;end address (addr2)
    4925/    FE50 : DF B8                      STX   PTR5
    4926/    FE52 : BD E2 FC                   JSR   WSKIP
    4927/    FE55 : 26 02                      BNE   BOTERR    ;go use addr1 and addr2
    4928/    FE57 : 20 07                      BRA   BOT2
    4929/    FE59 :
    4930/    FE59 :                    ;*
    4931/    FE59 : CE E6 98           BOTERR  LDX   #MSG9     ;"bad argument"
    4932/    FE5C : BD E5 05                   JSR   OUTSTRG
    4933/    FE5F : 39                         RTS
    4934/    FE60 :
    4935/    FE60 :                    ;*Boot routine
    4936/    FE60 : C6 FF              BOT2    LDAB  #$FF       ;control character ($ff -> download)
    4937/    FE62 : BD FE 78                   JSR   BTSUB      ;set up SCI and send control char
    4938/    FE65 :                    ;*                        initializes X as register pointer
    4939/    FE65 :                    ;*Download block
    4940/    FE65 : 18 A6 00           BLOP    LDAA  0,Y
    4941/    FE68 : A7 2F                      STAA  JSCDAT,X   ;write to transmitter
    4942/    FE6A : 1F 2E 50 FC                BRCLR JSCSR,X,#80,*      ;wait for TDRE
    4943/    FE6E : 18 9C B8                   CPY   PTR5       ;if last...
    4944/    FE71 : 27 04                      BEQ   BTDONE      ;    ...quit
    4945/    FE73 : 18 08                      INY              ;else...
    4946/    FE75 : 20 EE                      BRA   BLOP        ;    ...send next
    4947/    FE77 : 39                 BTDONE  RTS
    4948/    FE78 :
    4949/    FE78 :                    ;************************************************
    4950/    FE78 :                    ;*Subroutine
    4951/    FE78 :                    ;*  btsub   - sets up SCI and outputs control character
    4952/    FE78 :                    ;* On entry, B = control character
    4953/    FE78 :                    ;* On exit,  X = REGBS
    4954/    FE78 :                    ;*           A = $0C
    4955/    FE78 :                    ;***************************
    4956/    FE78 :
    4957/    FE78 : =FE78              BTSUB   EQU   *
    4958/    FE78 : CE 00 00                   LDX   #REGBS    ;to use indexed addressing
    4959/    FE7B : 86 02                      LDAA  #$02
    4960/    FE7D : A7 08                      STAA  JPORTD,X  ;drive transmitter line
    4961/    FE7F : A7 09                      STAA  JDDRD,X   ;  high
    4962/    FE81 : 6F 2D                      CLR   JSCCR2,X  ;turn off XMTR and RCVR
    4963/    FE83 : 86 22                      LDAA  #$22      ;BAUD = /16
    4964/    FE85 : A7 2B                      STAA  JBAUD,X
    4965/    FE87 : 86 0C                      LDAA  #$0C      ;TURN ON XMTR & RCVR
    4966/    FE89 : A7 2D                      STAA  JSCCR2,X
    4967/    FE8B : E7 2F                      STAB  JSCDAT,X
    4968/    FE8D : 1F 2E 50 FC                BRCLR JSCSR,X,#80,*   ;wait for TDRE
    4969/    FE91 : 39                         RTS
    4970/    FE92 :
    4971/    FE92 :
    4972/    FE92 :                    ;***********
    4973/    FE92 :                    ;* TILDE - This command is put into the combuff by the
    4974/    FE92 :                    ;* load command so that extraneous carriage returns after
    4975/    FE92 :                    ;* the load will not hang up.
    4976/    FE92 : 39                 TILDE   RTS
    4977/    FE93 :
    4978/    FE93 :                    ;******************
    4979/    FE93 :                    ;*
    4980/    FE93 :                    ;*       EVBTEST - This routine makes it a little easier
    4981/    FE93 :                    ;*       on us to test this board.
    4982/    FE93 :                    ;*
    4983/    FE93 :                    ;******************
    4984/    FE93 :
    4985/    FE93 : 86 FF              EVBTEST  LDAA  #$FF
    4986/    FE95 : 97 00                       STAA  REGBS+0  ;Write ones to port A
    4987/    FE97 : 7F 00 A4                    CLR  AUTOLF    ;Turn off auto lf
    4988/    FE9A : BD E3 3D                    JSR  HOSTCO    ;Connect host
    4989/    FE9D : BD FC 27                    JSR  HOSTINIT  ;Initialize host
    4990/    FEA0 : 86 7F                       LDAA #$7f
    4991/    FEA2 : BD FC 3F                    JSR  HOSTOUT   ;Send Delete to Altos
    4992/    FEA5 : 86 0D                       LDAA #$0d
    4993/    FEA7 : BD FC 3F                    JSR  HOSTOUT   ;Send <CR>
    4994/    FEAA : 7C 00 A4                    INC  AUTOLF    ;Turn on Auto LF
    4995/    FEAD : CE 00 70                    LDX  #INBUFF+5 ;Point at Load message
    4996/    FEB0 : DF AE                       STX  PTR0      ;Set pointer for load command
    4997/    FEB2 : 18 CE FE D0                 LDY  #MSGEVB   ;Point at cat line
    4998/    FEB6 : 18 A6 00           LOOP     LDAA 0,Y       ;Loop to xfer command line
    4999/    FEB9 : 81 04                       CMPA #04       ;Into buffalo line buffer
    5000/    FEBB : 27 07                       BEQ  DONE      ;Quit on $04
    5001/    FEBD : A7 00                       STAA 0,X
    5002/    FEBF : 08                          INX            ;next character
    5003/    FEC0 : 18 08                       INY
    5004/    FEC2 : 20 F2                       BRA  LOOP
    5005/    FEC4 : 7F 00 C1           DONE     CLR  TMP2      ;Set load vs. verify
    5006/    FEC7 : BD FC 80                    JSR  LOAD3     ;Jmp into middle of load
    5007/    FECA : 8E 00 5F                    LDS  #STACK    ;Reset Stack
    5008/    FECD : 7E C0 B3                    JMP  $C0B3     ;Jump to Downloaded code
    5009/    FED0 :
    5010/    FED0 : 63 61 74 20 65 76  MSGEVB   FCC  /cat evbtest.out/
             FED6 : 62 74 65 73 74 2E
             FEDC : 6F 75 74
    5011/    FEDF : 0D                          FCB  $0D
    5012/    FEE0 : 04                          FCB  $04
    5013/    FEE1 :
    5014/    FEE1 :
    5015/    FEE1 :
    5016/    FEE1 :                    ;*** Jump table ***
    5017/    FF7C :                            ORG     ROMBS+$1F7C
    5018/    FF7C : 7E E0 C8           _WARMST JMP     MAIN        ;warm start
    5019/    FF7F : 7E E1 B2           _BPCLR  JMP     BPCLR       ;clear breakpoint table
    5020/    FF82 : 7E E1 F3           _RPRINT JMP     RPRINT      ;display user registers
    5021/    FF85 : 7E E2 01           _HEXBIN JMP     HEXBIN      ;convert ascii hex char to binary
    5022/    FF88 : 7E E2 34           _BUFFAR JMP     BUFFARG     ;build hex argument from buffer
    5023/    FF8B : 7E E2 57           _TERMAR JMP     TERMARG     ;read hex argument from terminal
    5024/    FF8E : 7E E2 7F           _CHGBYT JMP     CHGBYT      ;modify memory at address in x
    5025/    FF91 : 7E E2 E7           _READBU JMP     READBUFF    ;read character from buffer
    5026/    FF94 : 7E E2 EE           _INCBUF JMP     INCBUFF     ;increment buffer pointer
    5027/    FF97 : 7E E2 F4           _DECBUF JMP     DECBUFF     ;decrement buffer pointer
    5028/    FF9A : 7E E2 FC           _WSKIP  JMP     WSKIP       ;find non-whitespace char in buffer
    5029/    FF9D : 7E E3 1F           _CHKABR JMP     CHKABRT     ;check for abort from terminal
    5030/    FFA0 :
    5031/    FFA0 :                            ORG     ROMBS+$1FA0
    5032/    FFA0 : 7E E1 A7           _UPCASE JMP     UPCASE      ;convert to upper case
    5033/    FFA3 : 7E E3 0C           _WCHEK  JMP     WCHEK       ;check for white space
    5034/    FFA6 : 7E E3 17           _DCHEK  JMP     DCHEK       ;check for delimeter
    5035/    FFA9 : 7E E3 6E           _INIT   JMP     INIT        ;initialize i/o device
    5036/    FFAC : 7E E3 94           _INPUT  JMP     INPUT       ;low level input routine
    5037/    FFAF : 7E E3 BE           _OUTPUT JMP     OUTPUT      ;low level output routine
    5038/    FFB2 : 7E E4 CB           _OUTLHL JMP     OUTLHLF     ;display top 4 bits as hex digit
    5039/    FFB5 : 7E E4 CF           _OUTRHL JMP     OUTRHLF     ;display bottom 4 bits as hex digit
    5040/    FFB8 : 7E E4 D9           _OUTA   JMP     OUTA        ;output ascii character in A
    5041/    FFBB : 7E E4 DD           _OUT1BY JMP     OUT1BYT     ;display the hex value of byte at X
    5042/    FFBE : 7E E4 EC           _OUT1BS JMP     OUT1BSP     ;out1byt followed by space
    5043/    FFC1 : 7E E4 E9           _OUT2BS JMP     OUT2BSP     ;display 2 hex bytes at x and a space
    5044/    FFC4 : 7E E4 F5           _OUTCRL JMP     OUTCRLF     ;carriage return, line feed to terminal
    5045/    FFC7 : 7E E5 05           _OUTSTR JMP     OUTSTRG     ;display string at X (term with $04)
    5046/    FFCA : 7E E5 08           _OUTST0 JMP     OUTSTRG0    ;outstrg with no initial carr ret
    5047/    FFCD : 7E E5 31           _INCHAR JMP     INCHAR      ;wait for and input a char from term
    5048/    FFD0 : 7E E3 4D           _VECINT JMP     VECINIT     ;initialize RAM vector table
    5049/    FFD3 :
    5050/    FFD6 :                             ORG    ROMBS+$1FD6
    5051/    FFD6 :                    ;*** Vectors ***
    5052/    FFD6 : 00 C4              VSCI     FDB    JSCI
    5053/    FFD8 : 00 C7              VSPI     FDB    JSPI
    5054/    FFDA : 00 CA              VPAIE    FDB    JPAIE
    5055/    FFDC : 00 CD              VPAO     FDB    JPAO
    5056/    FFDE : 00 D0              VTOF     FDB    JTOF
    5057/    FFE0 : 00 D3              VTOC5    FDB    JTOC5
    5058/    FFE2 : 00 D6              VTOC4    FDB    JTOC4
    5059/    FFE4 : 00 D9              VTOC3    FDB    JTOC3
    5060/    FFE6 : 00 DC              VTOC2    FDB    JTOC2
    5061/    FFE8 : 00 DF              VTOC1    FDB    JTOC1
    5062/    FFEA : 00 E2              VTIC3    FDB    JTIC3
    5063/    FFEC : 00 E5              VTIC2    FDB    JTIC2
    5064/    FFEE : 00 E8              VTIC1    FDB    JTIC1
    5065/    FFF0 : 00 EB              VRTI     FDB    JRTI
    5066/    FFF2 : 00 EE              VIRQ     FDB    JIRQ
    5067/    FFF4 : 00 F1              VXIRQ    FDB    JXIRQ
    5068/    FFF6 : 00 F4              VSWI     FDB    JSWI
    5069/    FFF8 : 00 F7              VILLOP   FDB    JILLOP
    5070/    FFFA : 00 FA              VCOP     FDB    JCOP
    5071/    FFFC : 00 FD              VCLM     FDB    JCLM
    5072/    FFFE : E0 00              VRST     FDB    BUFFALO
    5073/   10000 :                             END
